#!/usr/bin/perl -w
use strict;
use lib "/hwfssz4/BC_PUB/Software/03.Soft_ALL/PerlInfo/lib/perl5/";
use Getopt::Long;
use FindBin qw($Bin $RealBin);
use Data::Dumper;

BEGIN{
	use FindBin qw($Bin $RealBin);
	my $PID=$$;
	my $commod=`ps uf -A | awk \'\$2==$PID\' `;
	my @temp=split /\s+/,$commod;
	my $StaCount=12;
	my $BinCC=$temp[12];
	if ($temp[10] eq "|")
	{
	}
	else
	{
		$StaCount=11;
		$BinCC=$temp[11];
	}

	if (($BinCC eq "perl")  ||  ($BinCC eq "/usr/bin/perl") )
	{
		$StaCount++;
		$BinCC=$temp[$StaCount];
		if (($BinCC eq "-w")  ||  ($BinCC eq "-e"))
		{
			$StaCount++;
			$BinCC=$temp[$StaCount];
		}
	}
	$RealBin=`dirname $BinCC `; chomp $RealBin;	
}


my $today=`date +%Y%m%d`; chomp  $today ;   if  ($today  > 20251001 ) {print "\tWarning:1.38版本过老,强制定期升级到最新版本\n\t请在这下载最新版本的 https://github.com/hewm2008/RectChr\n\t1.39以下的版本建议在20260101之后不再用\n";  }

my $SVGTest=`  perl -MSVG -e " print\\\"SVG\\\" "  2>  /dev/null  `;
if (!((defined $SVGTest)  && ($SVGTest eq "SVG" )) )
{
	print "Warining: SVG module in Perl is missing, trying to loading the built-in [SVG.pm]...\n";
	$SVGTest=` perl -I$Bin/svg_kit -I$RealBin/svg_kit -MSVG -e "print\\\"SVG\\\""   2>  /dev/null  `;
	if ( !((defined $SVGTest)  &&  ($SVGTest eq "SVG" )) )
	{
		print "Warining: Can't load the [SVG.pm] Modules in myself,please install the SVG module from this URL [ https://metacpan.org/release/SVG ]\n"; 
		print "Error:\tPre-installations perl SVG.pm before installing/run RectChr\n";
		exit ;
	}
	else
	{
		use lib "$RealBin/svg_kit";
		use lib "$Bin/svg_kit";
		use SVG;
		print "Loading SVG module done\n";
	}
}
else
{
	use SVG;
}


use Switch;


sub  usage2
{
	print STDERR <<USAGE;

		Version:1.38         hewm2008\@gmail.com

		Usage: $RealBin/RectChr  -InConfi	in.cofi	-OutPut	OUT\n

		Options

		-InConfi      <s> : InPut Configuration File
		-OutPut       <s> : OutPut svg file resultl

		-help             : Show more help with *Manual.pdf

USAGE
}

sub  usage
{
	print STDERR <<USAGE;

		Version:1.38         hewm2008\@gmail.com

		Options

		-InConfi      <s> : InPut Configuration File
		-OutPut       <s> : OutPut svg file result

		-help             : Show more help with more parameter

USAGE
}

my $InConfi;
my $OutPut;
my $help;



GetOptions(
	"InConfi:s"=>\$InConfi,
	"OutPut:s"=>\$OutPut,
	"help"=>\$help,
);


#############swimming in the sky and flying in the sea #########

if (  defined($help)  )
{
	usage2 ;
	exit(1) ;
}
elsif ( (!defined($InConfi))  && (!defined($OutPut)) )
{
	usage ;
	exit(1) ;
}

if( (!defined($InConfi))  || (!defined($OutPut)) )
{
	usage ;
	exit(1) ;
}
######################swimming in the sky and flying in the sea ###########################
my %Asc2Int=();
$Asc2Int{0}=0;$Asc2Int{1}=1;$Asc2Int{2}=2;$Asc2Int{3}=3;$Asc2Int{4}=4;$Asc2Int{5}=5;
$Asc2Int{6}=6;$Asc2Int{7}=7;$Asc2Int{8}=8;$Asc2Int{9}=9;
$Asc2Int{'A'}=10;$Asc2Int{'B'}=11;$Asc2Int{'C'}=12;$Asc2Int{'D'}=13;$Asc2Int{'E'}=14;$Asc2Int{'F'}=15;
$Asc2Int{'a'}=10;$Asc2Int{'b'}=11;$Asc2Int{'c'}=12;$Asc2Int{'d'}=13;$Asc2Int{'e'}=14;$Asc2Int{'f'}=15;

my %Int2Asc=();
$Asc2Int{0}=0;$Asc2Int{1}=1;$Asc2Int{2}=2;$Asc2Int{3}=3;$Asc2Int{4}=4;$Asc2Int{5}=5;
$Asc2Int{6}=6;$Asc2Int{7}=7;$Asc2Int{8}=8;$Asc2Int{9}=9;
$Asc2Int{10}='A';$Asc2Int{11}='B';$Asc2Int{12}='C';$Asc2Int{13}='D';$Asc2Int{14}='E'; $Asc2Int{15}='F';

sub  HTML2RGB 
{
	my  $sColor = shift ;
	my $R=0;
	my $G=0;
	my $B=0;
	#十六进制颜色值的正则表达式
	if (($sColor =~ /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/)  &&  (length ($sColor)==7))
	{
		my @temp=split //,$sColor;
		$R=$Asc2Int{$temp[1]}*16+$Asc2Int{$temp[2]};
		$G=$Asc2Int{$temp[3]}*16+$Asc2Int{$temp[4]};
		$B=$Asc2Int{$temp[5]}*16+$Asc2Int{$temp[6]};
	}
	return ($R,$G,$B);
};
##
sub RGB2HTML
{
	my  $sColor = shift ;
	if ( $sColor=~s/#/#/)
	{
		return $sColor;
	}
	$sColor=~s/rgb\(//;
	$sColor=~s/\)//;
	my @RGB=split/\,/,$sColor;
	my $A1=$Asc2Int{int($RGB[0]/16)};	my $A2=$Asc2Int{$RGB[0]%16};
	my $B1=$Asc2Int{int($RGB[1]/16)};	my $B2=$Asc2Int{$RGB[1]%16};
	my $C1=$Asc2Int{int($RGB[2]/16)};	my $C2=$Asc2Int{$RGB[2]%16};
	my $HTML="#$A1$A2$B1$B2$C1$C2";
	return $HTML;
}





######################swimming in the sky and flying in the sea ###########################

my %MaxColNum=();
my %QualColNum=();

$MaxColNum{"Accent"}=8;  $MaxColNum{"Dark2"}=8;   $MaxColNum{"Paired"}=12;   $MaxColNum{"Pastel1"}=9;   $MaxColNum{"Pastel2"}=8;   $MaxColNum{"Set1"}=9;   $MaxColNum{"Set2"}=8;   $MaxColNum{"Set3"}=12;
$QualColNum{"Accent"}=8; $QualColNum{"Dark2"}=8;   $QualColNum{"Paired"}=12;   $QualColNum{"Pastel1"}=9;   $QualColNum{"Pastel2"}=8;   $QualColNum{"Set1"}=9;   $QualColNum{"Set2"}=8;   $QualColNum{"Set3"}=12;


$MaxColNum{"BrBG"}=11;
$MaxColNum{"PRGn"}=11;
$MaxColNum{"PuOr"}=11;
$MaxColNum{"RdBu"}=11;
$MaxColNum{"RdGy"}=11;
$MaxColNum{"RdYlBu"}=11;
$MaxColNum{"RdYlGn"}=11;
$MaxColNum{"GnYlRd"}=11;
$MaxColNum{"Spectral"}=11;
$MaxColNum{"Blues"}=9;
$MaxColNum{"BuGn"}=9;
$MaxColNum{"BuPu"}=9;
$MaxColNum{"GnBu"}=9;
$MaxColNum{"Greens"}=9;
$MaxColNum{"Greys"}=9;
$MaxColNum{"Oranges"}=9;
$MaxColNum{"OrRd"}=9;
$MaxColNum{"PuBu"}=9;
$MaxColNum{"PuBuGn"}=9;
$MaxColNum{"PuRd"}=9;
$MaxColNum{"Purples"}=9;
$MaxColNum{"RdPu"}=9;
$MaxColNum{"Reds"}=9;
$MaxColNum{"YlGn"}=9;
$MaxColNum{"YlGnBu"}=9;
$MaxColNum{"YlOrBr"}=9;
$MaxColNum{"YlOrRd"}=9;




sub GetColGradien
{
	my  $Flag=$_[0];
	my $Num=$_[1];
	my $CorArry=$_[2];

	my %HashColData=();


	######################swimming in the sky and flying in the sea ###########################
	$HashColData{"Accent"}{3}{R}="127,190,253";
	$HashColData{"Accent"}{3}{G}="201,174,192";
	$HashColData{"Accent"}{3}{B}="127,212,134";
	$HashColData{"Accent"}{4}{R}="127,190,253,255";
	$HashColData{"Accent"}{4}{G}="201,174,192,255";
	$HashColData{"Accent"}{4}{B}="127,212,134,153";
	$HashColData{"Accent"}{5}{R}="127,190,253,255,56";
	$HashColData{"Accent"}{5}{G}="201,174,192,255,108";
	$HashColData{"Accent"}{5}{B}="127,212,134,153,176";
	$HashColData{"Accent"}{6}{R}="127,190,253,255,56,240";
	$HashColData{"Accent"}{6}{G}="201,174,192,255,108,2";
	$HashColData{"Accent"}{6}{B}="127,212,134,153,176,127";
	$HashColData{"Accent"}{7}{R}="127,190,253,255,56,240,191";
	$HashColData{"Accent"}{7}{G}="201,174,192,255,108,2,91";
	$HashColData{"Accent"}{7}{B}="127,212,134,153,176,127,23";
	$HashColData{"Accent"}{8}{R}="127,190,253,255,56,240,191,102";
	$HashColData{"Accent"}{8}{G}="201,174,192,255,108,2,91,102";
	$HashColData{"Accent"}{8}{B}="127,212,134,153,176,127,23,102";
	$HashColData{"Blues"}{3}{R}="222,158,49";
	$HashColData{"Blues"}{3}{G}="235,202,130";
	$HashColData{"Blues"}{3}{B}="247,225,189";
	$HashColData{"Blues"}{4}{R}="239,189,107,33";
	$HashColData{"Blues"}{4}{G}="243,215,174,113";
	$HashColData{"Blues"}{4}{B}="255,231,214,181";
	$HashColData{"Blues"}{5}{R}="239,189,107,49,8";
	$HashColData{"Blues"}{5}{G}="243,215,174,130,81";
	$HashColData{"Blues"}{5}{B}="255,231,214,189,156";
	$HashColData{"Blues"}{6}{R}="239,198,158,107,49,8";
	$HashColData{"Blues"}{6}{G}="243,219,202,174,130,81";
	$HashColData{"Blues"}{6}{B}="255,239,225,214,189,156";
	$HashColData{"Blues"}{7}{R}="239,198,158,107,66,33,8";
	$HashColData{"Blues"}{7}{G}="243,219,202,174,146,113,69";
	$HashColData{"Blues"}{7}{B}="255,239,225,214,198,181,148";
	$HashColData{"Blues"}{8}{R}="247,222,198,158,107,66,33,8";
	$HashColData{"Blues"}{8}{G}="251,235,219,202,174,146,113,69";
	$HashColData{"Blues"}{8}{B}="255,247,239,225,214,198,181,148";
	$HashColData{"Blues"}{9}{R}="247,222,198,158,107,66,33,8,8";
	$HashColData{"Blues"}{9}{G}="251,235,219,202,174,146,113,81,48";
	$HashColData{"Blues"}{9}{B}="255,247,239,225,214,198,181,156,107";
	$HashColData{"BrBG"}{3}{R}="216,245,90";
	$HashColData{"BrBG"}{3}{G}="179,245,180";
	$HashColData{"BrBG"}{3}{B}="101,245,172";
	$HashColData{"BrBG"}{4}{R}="166,223,128,1";
	$HashColData{"BrBG"}{4}{G}="97,194,205,133";
	$HashColData{"BrBG"}{4}{B}="26,125,193,113";
	$HashColData{"BrBG"}{5}{R}="166,223,245,128,1";
	$HashColData{"BrBG"}{5}{G}="97,194,245,205,133";
	$HashColData{"BrBG"}{5}{B}="26,125,245,193,113";
	$HashColData{"BrBG"}{6}{R}="140,216,246,199,90,1";
	$HashColData{"BrBG"}{6}{G}="81,179,232,234,180,102";
	$HashColData{"BrBG"}{6}{B}="10,101,195,229,172,94";
	$HashColData{"BrBG"}{7}{R}="140,216,246,245,199,90,1";
	$HashColData{"BrBG"}{7}{G}="81,179,232,245,234,180,102";
	$HashColData{"BrBG"}{7}{B}="10,101,195,245,229,172,94";
	$HashColData{"BrBG"}{8}{R}="140,191,223,246,199,128,53,1";
	$HashColData{"BrBG"}{8}{G}="81,129,194,232,234,205,151,102";
	$HashColData{"BrBG"}{8}{B}="10,45,125,195,229,193,143,94";
	$HashColData{"BrBG"}{9}{R}="140,191,223,246,245,199,128,53,1";
	$HashColData{"BrBG"}{9}{G}="81,129,194,232,245,234,205,151,102";
	$HashColData{"BrBG"}{9}{B}="10,45,125,195,245,229,193,143,94";
	$HashColData{"BrBG"}{10}{R}="84,140,191,223,246,199,128,53,1,0";
	$HashColData{"BrBG"}{10}{G}="48,81,129,194,232,234,205,151,102,60";
	$HashColData{"BrBG"}{10}{B}="5,10,45,125,195,229,193,143,94,48";
	$HashColData{"BrBG"}{11}{R}="84,140,191,223,246,245,199,128,53,1,0";
	$HashColData{"BrBG"}{11}{G}="48,81,129,194,232,245,234,205,151,102,60";
	$HashColData{"BrBG"}{11}{B}="5,10,45,125,195,245,229,193,143,94,48";
	$HashColData{"BuGn"}{3}{R}="229,153,44";
	$HashColData{"BuGn"}{3}{G}="245,216,162";
	$HashColData{"BuGn"}{3}{B}="249,201,95";
	$HashColData{"BuGn"}{4}{R}="237,178,102,35";
	$HashColData{"BuGn"}{4}{G}="248,226,194,139";
	$HashColData{"BuGn"}{4}{B}="251,226,164,69";
	$HashColData{"BuGn"}{5}{R}="237,178,102,44,0";
	$HashColData{"BuGn"}{5}{G}="248,226,194,162,109";
	$HashColData{"BuGn"}{5}{B}="251,226,164,95,44";
	$HashColData{"BuGn"}{6}{R}="237,204,153,102,44,0";
	$HashColData{"BuGn"}{6}{G}="248,236,216,194,162,109";
	$HashColData{"BuGn"}{6}{B}="251,230,201,164,95,44";
	$HashColData{"BuGn"}{7}{R}="237,204,153,102,65,35,0";
	$HashColData{"BuGn"}{7}{G}="248,236,216,194,174,139,88";
	$HashColData{"BuGn"}{7}{B}="251,230,201,164,118,69,36";
	$HashColData{"BuGn"}{8}{R}="247,229,204,153,102,65,35,0";
	$HashColData{"BuGn"}{8}{G}="252,245,236,216,194,174,139,88";
	$HashColData{"BuGn"}{8}{B}="253,249,230,201,164,118,69,36";
	$HashColData{"BuGn"}{9}{R}="247,229,204,153,102,65,35,0,0";
	$HashColData{"BuGn"}{9}{G}="252,245,236,216,194,174,139,109,68";
	$HashColData{"BuGn"}{9}{B}="253,249,230,201,164,118,69,44,27";
	$HashColData{"BuPu"}{3}{R}="224,158,136";
	$HashColData{"BuPu"}{3}{G}="236,188,86";
	$HashColData{"BuPu"}{3}{B}="244,218,167";
	$HashColData{"BuPu"}{4}{R}="237,179,140,136";
	$HashColData{"BuPu"}{4}{G}="248,205,150,65";
	$HashColData{"BuPu"}{4}{B}="251,227,198,157";
	$HashColData{"BuPu"}{5}{R}="237,179,140,136,129";
	$HashColData{"BuPu"}{5}{G}="248,205,150,86,15";
	$HashColData{"BuPu"}{5}{B}="251,227,198,167,124";
	$HashColData{"BuPu"}{6}{R}="237,191,158,140,136,129";
	$HashColData{"BuPu"}{6}{G}="248,211,188,150,86,15";
	$HashColData{"BuPu"}{6}{B}="251,230,218,198,167,124";
	$HashColData{"BuPu"}{7}{R}="237,191,158,140,140,136,110";
	$HashColData{"BuPu"}{7}{G}="248,211,188,150,107,65,1";
	$HashColData{"BuPu"}{7}{B}="251,230,218,198,177,157,107";
	$HashColData{"BuPu"}{8}{R}="247,224,191,158,140,140,136,110";
	$HashColData{"BuPu"}{8}{G}="252,236,211,188,150,107,65,1";
	$HashColData{"BuPu"}{8}{B}="253,244,230,218,198,177,157,107";
	$HashColData{"BuPu"}{9}{R}="247,224,191,158,140,140,136,129,77";
	$HashColData{"BuPu"}{9}{G}="252,236,211,188,150,107,65,15,0";
	$HashColData{"BuPu"}{9}{B}="253,244,230,218,198,177,157,124,75";
	$HashColData{"Dark2"}{3}{R}="27,217,117";
	$HashColData{"Dark2"}{3}{G}="158,95,112";
	$HashColData{"Dark2"}{3}{B}="119,2,179";
	$HashColData{"Dark2"}{4}{R}="27,217,117,231";
	$HashColData{"Dark2"}{4}{G}="158,95,112,41";
	$HashColData{"Dark2"}{4}{B}="119,2,179,138";
	$HashColData{"Dark2"}{5}{R}="27,217,117,231,102";
	$HashColData{"Dark2"}{5}{G}="158,95,112,41,166";
	$HashColData{"Dark2"}{5}{B}="119,2,179,138,30";
	$HashColData{"Dark2"}{6}{R}="27,217,117,231,102,230";
	$HashColData{"Dark2"}{6}{G}="158,95,112,41,166,171";
	$HashColData{"Dark2"}{6}{B}="119,2,179,138,30,2";
	$HashColData{"Dark2"}{7}{R}="27,217,117,231,102,230,166";
	$HashColData{"Dark2"}{7}{G}="158,95,112,41,166,171,118";
	$HashColData{"Dark2"}{7}{B}="119,2,179,138,30,2,29";
	$HashColData{"Dark2"}{8}{R}="27,217,117,231,102,230,166,102";
	$HashColData{"Dark2"}{8}{G}="158,95,112,41,166,171,118,102";
	$HashColData{"Dark2"}{8}{B}="119,2,179,138,30,2,29,102";
	$HashColData{"GnBu"}{3}{R}="224,168,67";
	$HashColData{"GnBu"}{3}{G}="243,221,162";
	$HashColData{"GnBu"}{3}{B}="219,181,202";
	$HashColData{"GnBu"}{4}{R}="240,186,123,43";
	$HashColData{"GnBu"}{4}{G}="249,228,204,140";
	$HashColData{"GnBu"}{4}{B}="232,188,196,190";
	$HashColData{"GnBu"}{5}{R}="240,186,123,67,8";
	$HashColData{"GnBu"}{5}{G}="249,228,204,162,104";
	$HashColData{"GnBu"}{5}{B}="232,188,196,202,172";
	$HashColData{"GnBu"}{6}{R}="240,204,168,123,67,8";
	$HashColData{"GnBu"}{6}{G}="249,235,221,204,162,104";
	$HashColData{"GnBu"}{6}{B}="232,197,181,196,202,172";
	$HashColData{"GnBu"}{7}{R}="240,204,168,123,78,43,8";
	$HashColData{"GnBu"}{7}{G}="249,235,221,204,179,140,88";
	$HashColData{"GnBu"}{7}{B}="232,197,181,196,211,190,158";
	$HashColData{"GnBu"}{8}{R}="247,224,204,168,123,78,43,8";
	$HashColData{"GnBu"}{8}{G}="252,243,235,221,204,179,140,88";
	$HashColData{"GnBu"}{8}{B}="240,219,197,181,196,211,190,158";
	$HashColData{"GnBu"}{9}{R}="247,224,204,168,123,78,43,8,8";
	$HashColData{"GnBu"}{9}{G}="252,243,235,221,204,179,140,104,64";
	$HashColData{"GnBu"}{9}{B}="240,219,197,181,196,211,190,172,129";
	$HashColData{"Greens"}{3}{R}="229,161,49";
    $HashColData{"Greens"}{3}{G}="245,217,163";
    $HashColData{"Greens"}{3}{B}="224,155,84";
    $HashColData{"Greens"}{4}{R}="237,186,116,35";
    $HashColData{"Greens"}{4}{G}="248,228,196,139";
    $HashColData{"Greens"}{4}{B}="233,179,118,69";
	$HashColData{"Greens"}{5}{R}="237,186,116,49,0";
	$HashColData{"Greens"}{5}{G}="248,228,196,163,109";
	$HashColData{"Greens"}{5}{B}="233,179,118,84,44";
	$HashColData{"Greens"}{6}{R}="237,199,161,116,49,0";
	$HashColData{"Greens"}{6}{G}="248,233,217,196,163,109";
	$HashColData{"Greens"}{6}{B}="233,192,155,118,84,44";
	$HashColData{"Greens"}{7}{R}="237,199,161,116,65,35,0";
	$HashColData{"Greens"}{7}{G}="248,233,217,196,171,139,90";
	$HashColData{"Greens"}{7}{B}="233,192,155,118,93,69,50";
	$HashColData{"Greens"}{8}{R}="247,229,199,161,116,65,35,0";
	$HashColData{"Greens"}{8}{G}="252,245,233,217,196,171,139,90";
	$HashColData{"Greens"}{8}{B}="245,224,192,155,118,93,69,50";
	$HashColData{"Greens"}{9}{R}="247,229,199,161,116,65,35,0,0";
	$HashColData{"Greens"}{9}{G}="252,245,233,217,196,171,139,109,68";
	$HashColData{"Greens"}{9}{B}="245,224,192,155,118,93,69,44,27";
	$HashColData{"Greys"}{3}{R}="240,189,99";
	$HashColData{"Greys"}{3}{G}="240,189,99";
	$HashColData{"Greys"}{3}{B}="240,189,99";
	$HashColData{"Greys"}{4}{R}="247,204,150,82";
	$HashColData{"Greys"}{4}{G}="247,204,150,82";
	$HashColData{"Greys"}{4}{B}="247,204,150,82";
	$HashColData{"Greys"}{5}{R}="247,204,150,99,37";
	$HashColData{"Greys"}{5}{G}="247,204,150,99,37";
	$HashColData{"Greys"}{5}{B}="247,204,150,99,37";
	$HashColData{"Greys"}{6}{R}="247,217,189,150,99,37";
	$HashColData{"Greys"}{6}{G}="247,217,189,150,99,37";
	$HashColData{"Greys"}{6}{B}="247,217,189,150,99,37";
	$HashColData{"Greys"}{7}{R}="247,217,189,150,115,82,37";
	$HashColData{"Greys"}{7}{G}="247,217,189,150,115,82,37";
	$HashColData{"Greys"}{7}{B}="247,217,189,150,115,82,37";
	$HashColData{"Greys"}{8}{R}="255,240,217,189,150,115,82,37";
	$HashColData{"Greys"}{8}{G}="255,240,217,189,150,115,82,37";
	$HashColData{"Greys"}{8}{B}="255,240,217,189,150,115,82,37";
	$HashColData{"Greys"}{9}{R}="255,240,217,189,150,115,82,37,0";
	$HashColData{"Greys"}{9}{G}="255,240,217,189,150,115,82,37,0";
	$HashColData{"Greys"}{9}{B}="255,240,217,189,150,115,82,37,0";
	$HashColData{"Oranges"}{3}{R}="254,253,230";
	$HashColData{"Oranges"}{3}{G}="230,174,85";
	$HashColData{"Oranges"}{3}{B}="206,107,13";
	$HashColData{"Oranges"}{4}{R}="254,253,253,217";
	$HashColData{"Oranges"}{4}{G}="237,190,141,71";
	$HashColData{"Oranges"}{4}{B}="222,133,60,1";
	$HashColData{"Oranges"}{5}{R}="254,253,253,230,166";
	$HashColData{"Oranges"}{5}{G}="237,190,141,85,54";
	$HashColData{"Oranges"}{5}{B}="222,133,60,13,3";
	$HashColData{"Oranges"}{6}{R}="254,253,253,253,230,166";
	$HashColData{"Oranges"}{6}{G}="237,208,174,141,85,54";
	$HashColData{"Oranges"}{6}{B}="222,162,107,60,13,3";
	$HashColData{"Oranges"}{7}{R}="254,253,253,253,241,217,140";
	$HashColData{"Oranges"}{7}{G}="237,208,174,141,105,72,45";
	$HashColData{"Oranges"}{7}{B}="222,162,107,60,19,1,4";
	$HashColData{"Oranges"}{8}{R}="255,254,253,253,253,241,217,140";
	$HashColData{"Oranges"}{8}{G}="245,230,208,174,141,105,72,45";
	$HashColData{"Oranges"}{8}{B}="235,206,162,107,60,19,1,4";
	$HashColData{"Oranges"}{9}{R}="255,254,253,253,253,241,217,166,127";
	$HashColData{"Oranges"}{9}{G}="245,230,208,174,141,105,72,54,39";
	$HashColData{"Oranges"}{9}{B}="235,206,162,107,60,19,1,3,4";
	$HashColData{"OrRd"}{3}{R}="254,253,227";
	$HashColData{"OrRd"}{3}{G}="232,187,74";
	$HashColData{"OrRd"}{3}{B}="200,132,51";
	$HashColData{"OrRd"}{4}{R}="254,253,252,215";
	$HashColData{"OrRd"}{4}{G}="240,204,141,48";
	$HashColData{"OrRd"}{4}{B}="217,138,89,31";
	$HashColData{"OrRd"}{5}{R}="254,253,252,227,179";
	$HashColData{"OrRd"}{5}{G}="240,204,141,74,0";
	$HashColData{"OrRd"}{5}{B}="217,138,89,51,0";
	$HashColData{"OrRd"}{6}{R}="254,253,253,252,227,179";
	$HashColData{"OrRd"}{6}{G}="240,212,187,141,74,0";
	$HashColData{"OrRd"}{6}{B}="217,158,132,89,51,0";
	$HashColData{"OrRd"}{7}{R}="254,253,253,252,239,215,153";
	$HashColData{"OrRd"}{7}{G}="240,212,187,141,101,48,0";
	$HashColData{"OrRd"}{7}{B}="217,158,132,89,72,31,0";
	$HashColData{"OrRd"}{8}{R}="255,254,253,253,252,239,215,153";
	$HashColData{"OrRd"}{8}{G}="247,232,212,187,141,101,48,0";
	$HashColData{"OrRd"}{8}{B}="236,200,158,132,89,72,31,0";
	$HashColData{"OrRd"}{9}{R}="255,254,253,253,252,239,215,179,127";
	$HashColData{"OrRd"}{9}{G}="247,232,212,187,141,101,48,0,0";
	$HashColData{"OrRd"}{9}{B}="236,200,158,132,89,72,31,0,0";
	$HashColData{"Paired"}{3}{R}="166,31,178";
	$HashColData{"Paired"}{3}{G}="206,120,223";
	$HashColData{"Paired"}{3}{B}="227,180,138";
	$HashColData{"Paired"}{4}{R}="166,31,178,51";
	$HashColData{"Paired"}{4}{G}="206,120,223,160";
	$HashColData{"Paired"}{4}{B}="227,180,138,44";
	$HashColData{"Paired"}{5}{R}="166,31,178,51,251";
	$HashColData{"Paired"}{5}{G}="206,120,223,160,154";
	$HashColData{"Paired"}{5}{B}="227,180,138,44,153";
	$HashColData{"Paired"}{6}{R}="166,31,178,51,251,227";
	$HashColData{"Paired"}{6}{G}="206,120,223,160,154,26";
	$HashColData{"Paired"}{6}{B}="227,180,138,44,153,28";
	$HashColData{"Paired"}{7}{R}="166,31,178,51,251,227,253";
	$HashColData{"Paired"}{7}{G}="206,120,223,160,154,26,191";
	$HashColData{"Paired"}{7}{B}="227,180,138,44,153,28,111";
	$HashColData{"Paired"}{8}{R}="166,31,178,51,251,227,253,255";
	$HashColData{"Paired"}{8}{G}="206,120,223,160,154,26,191,127";
	$HashColData{"Paired"}{8}{B}="227,180,138,44,153,28,111,0";
	$HashColData{"Paired"}{9}{R}="166,31,178,51,251,227,253,255,202";
	$HashColData{"Paired"}{9}{G}="206,120,223,160,154,26,191,127,178";
	$HashColData{"Paired"}{9}{B}="227,180,138,44,153,28,111,0,214";
	$HashColData{"Paired"}{10}{R}="166,31,178,51,251,227,253,255,202,106";
	$HashColData{"Paired"}{10}{G}="206,120,223,160,154,26,191,127,178,61";
	$HashColData{"Paired"}{10}{B}="227,180,138,44,153,28,111,0,214,154";
	$HashColData{"Paired"}{11}{R}="166,31,178,51,251,227,253,255,202,106,255";
	$HashColData{"Paired"}{11}{G}="206,120,223,160,154,26,191,127,178,61,255";
	$HashColData{"Paired"}{11}{B}="227,180,138,44,153,28,111,0,214,154,153";
	$HashColData{"Paired"}{12}{R}="166,31,178,51,251,227,253,255,202,106,255,177";
	$HashColData{"Paired"}{12}{G}="206,120,223,160,154,26,191,127,178,61,255,89";
	$HashColData{"Paired"}{12}{B}="227,180,138,44,153,28,111,0,214,154,153,40";
	$HashColData{"Pastel1"}{3}{R}="251,179,204";
	$HashColData{"Pastel1"}{3}{G}="180,205,235";
	$HashColData{"Pastel1"}{3}{B}="174,227,197";
	$HashColData{"Pastel1"}{4}{R}="251,179,204,222";
	$HashColData{"Pastel1"}{4}{G}="180,205,235,203";
	$HashColData{"Pastel1"}{4}{B}="174,227,197,228";
	$HashColData{"Pastel1"}{5}{R}="251,179,204,222,254";
	$HashColData{"Pastel1"}{5}{G}="180,205,235,203,217";
	$HashColData{"Pastel1"}{5}{B}="174,227,197,228,166";
	$HashColData{"Pastel1"}{6}{R}="251,179,204,222,254,255";
	$HashColData{"Pastel1"}{6}{G}="180,205,235,203,217,255";
	$HashColData{"Pastel1"}{6}{B}="174,227,197,228,166,204";
	$HashColData{"Pastel1"}{7}{R}="251,179,204,222,254,255,229";
	$HashColData{"Pastel1"}{7}{G}="180,205,235,203,217,255,216";
	$HashColData{"Pastel1"}{7}{B}="174,227,197,228,166,204,189";
	$HashColData{"Pastel1"}{8}{R}="251,179,204,222,254,255,229,253";
	$HashColData{"Pastel1"}{8}{G}="180,205,235,203,217,255,216,218";
	$HashColData{"Pastel1"}{8}{B}="174,227,197,228,166,204,189,236";
	$HashColData{"Pastel1"}{9}{R}="251,179,204,222,254,255,229,253,242";
	$HashColData{"Pastel1"}{9}{G}="180,205,235,203,217,255,216,218,242";
	$HashColData{"Pastel1"}{9}{B}="174,227,197,228,166,204,189,236,242";
	$HashColData{"Pastel2"}{3}{R}="179,253,203";
	$HashColData{"Pastel2"}{3}{G}="226,205,213";
	$HashColData{"Pastel2"}{3}{B}="205,172,232";
	$HashColData{"Pastel2"}{4}{R}="179,253,203,244";
	$HashColData{"Pastel2"}{4}{G}="226,205,213,202";
	$HashColData{"Pastel2"}{4}{B}="205,172,232,228";
	$HashColData{"Pastel2"}{5}{R}="179,253,203,244,230";
	$HashColData{"Pastel2"}{5}{G}="226,205,213,202,245";
	$HashColData{"Pastel2"}{5}{B}="205,172,232,228,201";
	$HashColData{"Pastel2"}{6}{R}="179,253,203,244,230,255";
	$HashColData{"Pastel2"}{6}{G}="226,205,213,202,245,242";
	$HashColData{"Pastel2"}{6}{B}="205,172,232,228,201,174";
	$HashColData{"Pastel2"}{7}{R}="179,253,203,244,230,255,241";
	$HashColData{"Pastel2"}{7}{G}="226,205,213,202,245,242,226";
	$HashColData{"Pastel2"}{7}{B}="205,172,232,228,201,174,204";
	$HashColData{"Pastel2"}{8}{R}="179,253,203,244,230,255,241,204";
	$HashColData{"Pastel2"}{8}{G}="226,205,213,202,245,242,226,204";
	$HashColData{"Pastel2"}{8}{B}="205,172,232,228,201,174,204,204";
	$HashColData{"PiYG"}{3}{R}="233,247,161";
	$HashColData{"PiYG"}{3}{G}="163,247,215";
	$HashColData{"PiYG"}{3}{B}="201,247,106";
	$HashColData{"PiYG"}{4}{R}="208,241,184,77";
	$HashColData{"PiYG"}{4}{G}="28,182,225,172";
	$HashColData{"PiYG"}{4}{B}="139,218,134,38";
	$HashColData{"PiYG"}{5}{R}="208,241,247,184,77";
	$HashColData{"PiYG"}{5}{G}="28,182,247,225,172";
	$HashColData{"PiYG"}{5}{B}="139,218,247,134,38";
	$HashColData{"PiYG"}{6}{R}="197,233,253,230,161,77";
	$HashColData{"PiYG"}{6}{G}="27,163,224,245,215,146";
	$HashColData{"PiYG"}{6}{B}="125,201,239,208,106,33";
	$HashColData{"PiYG"}{7}{R}="197,233,253,247,230,161,77";
	$HashColData{"PiYG"}{7}{G}="27,163,224,247,245,215,146";
	$HashColData{"PiYG"}{7}{B}="125,201,239,247,208,106,33";
	$HashColData{"PiYG"}{8}{R}="197,222,241,253,230,184,127,77";
	$HashColData{"PiYG"}{8}{G}="27,119,182,224,245,225,188,146";
	$HashColData{"PiYG"}{8}{B}="125,174,218,239,208,134,65,33";
	$HashColData{"PiYG"}{9}{R}="197,222,241,253,247,230,184,127,77";
	$HashColData{"PiYG"}{9}{G}="27,119,182,224,247,245,225,188,146";
	$HashColData{"PiYG"}{9}{B}="125,174,218,239,247,208,134,65,33";
	$HashColData{"PiYG"}{10}{R}="142,197,222,241,253,230,184,127,77,39";
	$HashColData{"PiYG"}{10}{G}="1,27,119,182,224,245,225,188,146,100";
	$HashColData{"PiYG"}{10}{B}="82,125,174,218,239,208,134,65,33,25";
	$HashColData{"PiYG"}{11}{R}="142,197,222,241,253,247,230,184,127,77,39";
	$HashColData{"PiYG"}{11}{G}="1,27,119,182,224,247,245,225,188,146,100";
	$HashColData{"PiYG"}{11}{B}="82,125,174,218,239,247,208,134,65,33,25";
	$HashColData{"PRGn"}{3}{R}="175,247,127";
	$HashColData{"PRGn"}{3}{G}="141,247,191";
	$HashColData{"PRGn"}{3}{B}="195,247,123";
	$HashColData{"PRGn"}{4}{R}="123,194,166,0";
	$HashColData{"PRGn"}{4}{G}="50,165,219,136";
	$HashColData{"PRGn"}{4}{B}="148,207,160,55";
	$HashColData{"PRGn"}{5}{R}="123,194,247,166,0";
	$HashColData{"PRGn"}{5}{G}="50,165,247,219,136";
	$HashColData{"PRGn"}{5}{B}="148,207,247,160,55";
	$HashColData{"PRGn"}{6}{R}="118,175,231,217,127,27";
	$HashColData{"PRGn"}{6}{G}="42,141,212,240,191,120";
	$HashColData{"PRGn"}{6}{B}="131,195,232,211,123,55";
	$HashColData{"PRGn"}{7}{R}="118,175,231,247,217,127,27";
	$HashColData{"PRGn"}{7}{G}="42,141,212,247,240,191,120";
	$HashColData{"PRGn"}{7}{B}="131,195,232,247,211,123,55";
	$HashColData{"PRGn"}{8}{R}="118,153,194,231,217,166,90,27";
	$HashColData{"PRGn"}{8}{G}="42,112,165,212,240,219,174,120";
	$HashColData{"PRGn"}{8}{B}="131,171,207,232,211,160,97,55";
	$HashColData{"PRGn"}{9}{R}="118,153,194,231,247,217,166,90,27";
	$HashColData{"PRGn"}{9}{G}="42,112,165,212,247,240,219,174,120";
	$HashColData{"PRGn"}{9}{B}="131,171,207,232,247,211,160,97,55";
	$HashColData{"PRGn"}{10}{R}="64,118,153,194,231,217,166,90,27,0";
	$HashColData{"PRGn"}{10}{G}="0,42,112,165,212,240,219,174,120,68";
	$HashColData{"PRGn"}{10}{B}="75,131,171,207,232,211,160,97,55,27";
	$HashColData{"PRGn"}{11}{R}="64,118,153,194,231,247,217,166,90,27,0";
	$HashColData{"PRGn"}{11}{G}="0,42,112,165,212,247,240,219,174,120,68";
	$HashColData{"PRGn"}{11}{B}="75,131,171,207,232,247,211,160,97,55,27";
	$HashColData{"PuBu"}{3}{R}="236,166,43";
	$HashColData{"PuBu"}{3}{G}="231,189,140";
	$HashColData{"PuBu"}{3}{B}="242,219,190";
	$HashColData{"PuBu"}{4}{R}="241,189,116,5";
	$HashColData{"PuBu"}{4}{G}="238,201,169,112";
	$HashColData{"PuBu"}{4}{B}="246,225,207,176";
	$HashColData{"PuBu"}{5}{R}="241,189,116,43,4";
	$HashColData{"PuBu"}{5}{G}="238,201,169,140,90";
	$HashColData{"PuBu"}{5}{B}="246,225,207,190,141";
	$HashColData{"PuBu"}{6}{R}="241,208,166,116,43,4";
	$HashColData{"PuBu"}{6}{G}="238,209,189,169,140,90";
	$HashColData{"PuBu"}{6}{B}="246,230,219,207,190,141";
	$HashColData{"PuBu"}{7}{R}="241,208,166,116,54,5,3";
	$HashColData{"PuBu"}{7}{G}="238,209,189,169,144,112,78";
	$HashColData{"PuBu"}{7}{B}="246,230,219,207,192,176,123";
	$HashColData{"PuBu"}{8}{R}="255,236,208,166,116,54,5,3";
	$HashColData{"PuBu"}{8}{G}="247,231,209,189,169,144,112,78";
	$HashColData{"PuBu"}{8}{B}="251,242,230,219,207,192,176,123";
	$HashColData{"PuBu"}{9}{R}="255,236,208,166,116,54,5,4,2";
	$HashColData{"PuBu"}{9}{G}="247,231,209,189,169,144,112,90,56";
	$HashColData{"PuBu"}{9}{B}="251,242,230,219,207,192,176,141,88";
	$HashColData{"PuBuGn"}{3}{R}="236,166,28";
	$HashColData{"PuBuGn"}{3}{G}="226,189,144";
	$HashColData{"PuBuGn"}{3}{B}="240,219,153";
	$HashColData{"PuBuGn"}{4}{R}="246,189,103,2";
	$HashColData{"PuBuGn"}{4}{G}="239,201,169,129";
	$HashColData{"PuBuGn"}{4}{B}="247,225,207,138";
	$HashColData{"PuBuGn"}{5}{R}="246,189,103,28,1";
	$HashColData{"PuBuGn"}{5}{G}="239,201,169,144,108";
	$HashColData{"PuBuGn"}{5}{B}="247,225,207,153,89";
	$HashColData{"PuBuGn"}{6}{R}="246,208,166,103,28,1";
	$HashColData{"PuBuGn"}{6}{G}="239,209,189,169,144,108";
	$HashColData{"PuBuGn"}{6}{B}="247,230,219,207,153,89";
	$HashColData{"PuBuGn"}{7}{R}="246,208,166,103,54,2,1";
	$HashColData{"PuBuGn"}{7}{G}="239,209,189,169,144,129,100";
	$HashColData{"PuBuGn"}{7}{B}="247,230,219,207,192,138,80";
	$HashColData{"PuBuGn"}{8}{R}="255,236,208,166,103,54,2,1";
	$HashColData{"PuBuGn"}{8}{G}="247,226,209,189,169,144,129,100";
	$HashColData{"PuBuGn"}{8}{B}="251,240,230,219,207,192,138,80";
	$HashColData{"PuBuGn"}{9}{R}="255,236,208,166,103,54,2,1,1";
	$HashColData{"PuBuGn"}{9}{G}="247,226,209,189,169,144,129,108,70";
	$HashColData{"PuBuGn"}{9}{B}="251,240,230,219,207,192,138,89,54";
	$HashColData{"PuOr"}{3}{R}="241,247,153";
	$HashColData{"PuOr"}{3}{G}="163,247,142";
	$HashColData{"PuOr"}{3}{B}="64,247,195";
	$HashColData{"PuOr"}{4}{R}="230,253,178,94";
	$HashColData{"PuOr"}{4}{G}="97,184,171,60";
	$HashColData{"PuOr"}{4}{B}="1,99,210,153";
	$HashColData{"PuOr"}{5}{R}="230,253,247,178,94";
	$HashColData{"PuOr"}{5}{G}="97,184,247,171,60";
	$HashColData{"PuOr"}{5}{B}="1,99,247,210,153";
	$HashColData{"PuOr"}{6}{R}="179,241,254,216,153,84";
	$HashColData{"PuOr"}{6}{G}="88,163,224,218,142,39";
	$HashColData{"PuOr"}{6}{B}="6,64,182,235,195,136";
	$HashColData{"PuOr"}{7}{R}="179,241,254,247,216,153,84";
	$HashColData{"PuOr"}{7}{G}="88,163,224,247,218,142,39";
	$HashColData{"PuOr"}{7}{B}="6,64,182,247,235,195,136";
	$HashColData{"PuOr"}{8}{R}="179,224,253,254,216,178,128,84";
	$HashColData{"PuOr"}{8}{G}="88,130,184,224,218,171,115,39";
	$HashColData{"PuOr"}{8}{B}="6,20,99,182,235,210,172,136";
	$HashColData{"PuOr"}{9}{R}="179,224,253,254,247,216,178,128,84";
	$HashColData{"PuOr"}{9}{G}="88,130,184,224,247,218,171,115,39";
	$HashColData{"PuOr"}{9}{B}="6,20,99,182,247,235,210,172,136";
	$HashColData{"PuOr"}{10}{R}="127,179,224,253,254,216,178,128,84,45";
	$HashColData{"PuOr"}{10}{G}="59,88,130,184,224,218,171,115,39,0";
	$HashColData{"PuOr"}{10}{B}="8,6,20,99,182,235,210,172,136,75";
	$HashColData{"PuOr"}{11}{R}="127,179,224,253,254,247,216,178,128,84,45";
	$HashColData{"PuOr"}{11}{G}="59,88,130,184,224,247,218,171,115,39,0";
	$HashColData{"PuOr"}{11}{B}="8,6,20,99,182,247,235,210,172,136,75";
	$HashColData{"PuRd"}{3}{R}="231,201,221";
	$HashColData{"PuRd"}{3}{G}="225,148,28";
	$HashColData{"PuRd"}{3}{B}="239,199,119";
	$HashColData{"PuRd"}{4}{R}="241,215,223,206";
	$HashColData{"PuRd"}{4}{G}="238,181,101,18";
	$HashColData{"PuRd"}{4}{B}="246,216,176,86";
	$HashColData{"PuRd"}{5}{R}="241,215,223,221,152";
	$HashColData{"PuRd"}{5}{G}="238,181,101,28,0";
	$HashColData{"PuRd"}{5}{B}="246,216,176,119,67";
	$HashColData{"PuRd"}{6}{R}="241,212,201,223,221,152";
	$HashColData{"PuRd"}{6}{G}="238,185,148,101,28,0";
	$HashColData{"PuRd"}{6}{B}="246,218,199,176,119,67";
	$HashColData{"PuRd"}{7}{R}="241,212,201,223,231,206,145";
	$HashColData{"PuRd"}{7}{G}="238,185,148,101,41,18,0";
	$HashColData{"PuRd"}{7}{B}="246,218,199,176,138,86,63";
	$HashColData{"PuRd"}{8}{R}="247,231,212,201,223,231,206,145";
	$HashColData{"PuRd"}{8}{G}="244,225,185,148,101,41,18,0";
	$HashColData{"PuRd"}{8}{B}="249,239,218,199,176,138,86,63";
	$HashColData{"PuRd"}{9}{R}="247,231,212,201,223,231,206,152,103";
	$HashColData{"PuRd"}{9}{G}="244,225,185,148,101,41,18,0,0";
	$HashColData{"PuRd"}{9}{B}="249,239,218,199,176,138,86,67,31";
	$HashColData{"Purples"}{3}{R}="239,188,117";
	$HashColData{"Purples"}{3}{G}="237,189,107";
	$HashColData{"Purples"}{3}{B}="245,220,177";
	$HashColData{"Purples"}{4}{R}="242,203,158,106";
	$HashColData{"Purples"}{4}{G}="240,201,154,81";
	$HashColData{"Purples"}{4}{B}="247,226,200,163";
	$HashColData{"Purples"}{5}{R}="242,203,158,117,84";
	$HashColData{"Purples"}{5}{G}="240,201,154,107,39";
	$HashColData{"Purples"}{5}{B}="247,226,200,177,143";
	$HashColData{"Purples"}{6}{R}="242,218,188,158,117,84";
	$HashColData{"Purples"}{6}{G}="240,218,189,154,107,39";
	$HashColData{"Purples"}{6}{B}="247,235,220,200,177,143";
	$HashColData{"Purples"}{7}{R}="242,218,188,158,128,106,74";
	$HashColData{"Purples"}{7}{G}="240,218,189,154,125,81,20";
	$HashColData{"Purples"}{7}{B}="247,235,220,200,186,163,134";
	$HashColData{"Purples"}{8}{R}="252,239,218,188,158,128,106,74";
	$HashColData{"Purples"}{8}{G}="251,237,218,189,154,125,81,20";
	$HashColData{"Purples"}{8}{B}="253,245,235,220,200,186,163,134";
	$HashColData{"Purples"}{9}{R}="252,239,218,188,158,128,106,84,63";
	$HashColData{"Purples"}{9}{G}="251,237,218,189,154,125,81,39,0";
	$HashColData{"Purples"}{9}{B}="253,245,235,220,200,186,163,143,125";
	$HashColData{"RdBu"}{3}{R}="239,247,103";
	$HashColData{"RdBu"}{3}{G}="138,247,169";
	$HashColData{"RdBu"}{3}{B}="98,247,207";
	$HashColData{"RdBu"}{4}{R}="202,244,146,5";
	$HashColData{"RdBu"}{4}{G}="0,165,197,113";
	$HashColData{"RdBu"}{4}{B}="32,130,222,176";
	$HashColData{"RdBu"}{5}{R}="202,244,247,146,5";
	$HashColData{"RdBu"}{5}{G}="0,165,247,197,113";
	$HashColData{"RdBu"}{5}{B}="32,130,247,222,176";
	$HashColData{"RdBu"}{6}{R}="178,239,253,209,103,33";
	$HashColData{"RdBu"}{6}{G}="24,138,219,229,169,102";
	$HashColData{"RdBu"}{6}{B}="43,98,199,240,207,172";
	$HashColData{"RdBu"}{7}{R}="178,239,253,247,209,103,33";
	$HashColData{"RdBu"}{7}{G}="24,138,219,247,229,169,102";
	$HashColData{"RdBu"}{7}{B}="43,98,199,247,240,207,172";
	$HashColData{"RdBu"}{8}{R}="178,214,244,253,209,146,67,33";
	$HashColData{"RdBu"}{8}{G}="24,96,165,219,229,197,147,102";
	$HashColData{"RdBu"}{8}{B}="43,77,130,199,240,222,195,172";
	$HashColData{"RdBu"}{9}{R}="178,214,244,253,247,209,146,67,33";
	$HashColData{"RdBu"}{9}{G}="24,96,165,219,247,229,197,147,102";
	$HashColData{"RdBu"}{9}{B}="43,77,130,199,247,240,222,195,172";
	$HashColData{"RdBu"}{10}{R}="103,178,214,244,253,209,146,67,33,5";
	$HashColData{"RdBu"}{10}{G}="0,24,96,165,219,229,197,147,102,48";
	$HashColData{"RdBu"}{10}{B}="31,43,77,130,199,240,222,195,172,97";
	$HashColData{"RdBu"}{11}{R}="103,178,214,244,253,247,209,146,67,33,5";
	$HashColData{"RdBu"}{11}{G}="0,24,96,165,219,247,229,197,147,102,48";
	$HashColData{"RdBu"}{11}{B}="31,43,77,130,199,247,240,222,195,172,97";
	$HashColData{"RdGy"}{3}{R}="239,255,153";
	$HashColData{"RdGy"}{3}{G}="138,255,153";
	$HashColData{"RdGy"}{3}{B}="98,255,153";
	$HashColData{"RdGy"}{4}{R}="202,244,186,64";
	$HashColData{"RdGy"}{4}{G}="0,165,186,64";
	$HashColData{"RdGy"}{4}{B}="32,130,186,64";
	$HashColData{"RdGy"}{5}{R}="202,244,255,186,64";
	$HashColData{"RdGy"}{5}{G}="0,165,255,186,64";
	$HashColData{"RdGy"}{5}{B}="32,130,255,186,64";
	$HashColData{"RdGy"}{6}{R}="178,239,253,224,153,77";
	$HashColData{"RdGy"}{6}{G}="24,138,219,224,153,77";
	$HashColData{"RdGy"}{6}{B}="43,98,199,224,153,77";
	$HashColData{"RdGy"}{7}{R}="178,239,253,255,224,153,77";
	$HashColData{"RdGy"}{7}{G}="24,138,219,255,224,153,77";
	$HashColData{"RdGy"}{7}{B}="43,98,199,255,224,153,77";
	$HashColData{"RdGy"}{8}{R}="178,214,244,253,224,186,135,77";
	$HashColData{"RdGy"}{8}{G}="24,96,165,219,224,186,135,77";
	$HashColData{"RdGy"}{8}{B}="43,77,130,199,224,186,135,77";
	$HashColData{"RdGy"}{9}{R}="178,214,244,253,255,224,186,135,77";
	$HashColData{"RdGy"}{9}{G}="24,96,165,219,255,224,186,135,77";
	$HashColData{"RdGy"}{9}{B}="43,77,130,199,255,224,186,135,77";
	$HashColData{"RdGy"}{10}{R}="103,178,214,244,253,224,186,135,77,26";
	$HashColData{"RdGy"}{10}{G}="0,24,96,165,219,224,186,135,77,26";
	$HashColData{"RdGy"}{10}{B}="31,43,77,130,199,224,186,135,77,26";
	$HashColData{"RdGy"}{11}{R}="103,178,214,244,253,255,224,186,135,77,26";
	$HashColData{"RdGy"}{11}{G}="0,24,96,165,219,255,224,186,135,77,26";
	$HashColData{"RdGy"}{11}{B}="31,43,77,130,199,255,224,186,135,77,26";
	$HashColData{"RdPu"}{3}{R}="253,250,197";
	$HashColData{"RdPu"}{3}{G}="224,159,27";
	$HashColData{"RdPu"}{3}{B}="221,181,138";
	$HashColData{"RdPu"}{4}{R}="254,251,247,174";
	$HashColData{"RdPu"}{4}{G}="235,180,104,1";
	$HashColData{"RdPu"}{4}{B}="226,185,161,126";
	$HashColData{"RdPu"}{5}{R}="254,251,247,197,122";
	$HashColData{"RdPu"}{5}{G}="235,180,104,27,1";
	$HashColData{"RdPu"}{5}{B}="226,185,161,138,119";
	$HashColData{"RdPu"}{6}{R}="254,252,250,247,197,122";
	$HashColData{"RdPu"}{6}{G}="235,197,159,104,27,1";
	$HashColData{"RdPu"}{6}{B}="226,192,181,161,138,119";
	$HashColData{"RdPu"}{7}{R}="254,252,250,247,221,174,122";
	$HashColData{"RdPu"}{7}{G}="235,197,159,104,52,1,1";
	$HashColData{"RdPu"}{7}{B}="226,192,181,161,151,126,119";
	$HashColData{"RdPu"}{8}{R}="255,253,252,250,247,221,174,122";
	$HashColData{"RdPu"}{8}{G}="247,224,197,159,104,52,1,1";
	$HashColData{"RdPu"}{8}{B}="243,221,192,181,161,151,126,119";
	$HashColData{"RdPu"}{9}{R}="255,253,252,250,247,221,174,122,73";
	$HashColData{"RdPu"}{9}{G}="247,224,197,159,104,52,1,1,0";
	$HashColData{"RdPu"}{9}{B}="243,221,192,181,161,151,126,119,106";
	$HashColData{"Reds"}{3}{R}="254,252,222";
	$HashColData{"Reds"}{3}{G}="224,146,45";
	$HashColData{"Reds"}{3}{B}="210,114,38";
	$HashColData{"Reds"}{4}{R}="254,252,251,203";
	$HashColData{"Reds"}{4}{G}="229,174,106,24";
	$HashColData{"Reds"}{4}{B}="217,145,74,29";
	$HashColData{"Reds"}{5}{R}="254,252,251,222,165";
	$HashColData{"Reds"}{5}{G}="229,174,106,45,15";
	$HashColData{"Reds"}{5}{B}="217,145,74,38,21";
	$HashColData{"Reds"}{6}{R}="254,252,252,251,222,165";
	$HashColData{"Reds"}{6}{G}="229,187,146,106,45,15";
	$HashColData{"Reds"}{6}{B}="217,161,114,74,38,21";
	$HashColData{"Reds"}{7}{R}="254,252,252,251,239,203,153";
	$HashColData{"Reds"}{7}{G}="229,187,146,106,59,24,0";
	$HashColData{"Reds"}{7}{B}="217,161,114,74,44,29,13";
	$HashColData{"Reds"}{8}{R}="255,254,252,252,251,239,203,153";
	$HashColData{"Reds"}{8}{G}="245,224,187,146,106,59,24,0";
	$HashColData{"Reds"}{8}{B}="240,210,161,114,74,44,29,13";
	$HashColData{"Reds"}{9}{R}="255,254,252,252,251,239,203,165,103";
	$HashColData{"Reds"}{9}{G}="245,224,187,146,106,59,24,15,0";
	$HashColData{"Reds"}{9}{B}="240,210,161,114,74,44,29,21,13";
	$HashColData{"RdYlBu"}{3}{R}="252,255,145";
	$HashColData{"RdYlBu"}{3}{G}="141,255,191";
	$HashColData{"RdYlBu"}{3}{B}="89,191,219";
	$HashColData{"RdYlBu"}{4}{R}="215,253,171,44";
	$HashColData{"RdYlBu"}{4}{G}="25,174,217,123";
	$HashColData{"RdYlBu"}{4}{B}="28,97,233,182";
	$HashColData{"RdYlBu"}{5}{R}="215,253,255,171,44";
	$HashColData{"RdYlBu"}{5}{G}="25,174,255,217,123";
	$HashColData{"RdYlBu"}{5}{B}="28,97,191,233,182";
	$HashColData{"RdYlBu"}{6}{R}="215,252,254,224,145,69";
	$HashColData{"RdYlBu"}{6}{G}="48,141,224,243,191,117";
	$HashColData{"RdYlBu"}{6}{B}="39,89,144,248,219,180";
	$HashColData{"RdYlBu"}{7}{R}="215,252,254,255,224,145,69";
	$HashColData{"RdYlBu"}{7}{G}="48,141,224,255,243,191,117";
	$HashColData{"RdYlBu"}{7}{B}="39,89,144,191,248,219,180";
	$HashColData{"RdYlBu"}{8}{R}="215,244,253,254,224,171,116,69";
	$HashColData{"RdYlBu"}{8}{G}="48,109,174,224,243,217,173,117";
	$HashColData{"RdYlBu"}{8}{B}="39,67,97,144,248,233,209,180";
	$HashColData{"RdYlBu"}{9}{R}="215,244,253,254,255,224,171,116,69";
	$HashColData{"RdYlBu"}{9}{G}="48,109,174,224,255,243,217,173,117";
	$HashColData{"RdYlBu"}{9}{B}="39,67,97,144,191,248,233,209,180";
	$HashColData{"RdYlBu"}{10}{R}="165,215,244,253,254,224,171,116,69,49";
	$HashColData{"RdYlBu"}{10}{G}="0,48,109,174,224,243,217,173,117,54";
	$HashColData{"RdYlBu"}{10}{B}="38,39,67,97,144,248,233,209,180,149";
	$HashColData{"RdYlBu"}{11}{R}="165,215,244,253,254,255,224,171,116,69,49";
	$HashColData{"RdYlBu"}{11}{G}="0,48,109,174,224,255,243,217,173,117,54";
	$HashColData{"RdYlBu"}{11}{B}="38,39,67,97,144,191,248,233,209,180,149";




	$HashColData{"RdYlGn"}{3}{R}="252,255,145";
	$HashColData{"RdYlGn"}{3}{G}="141,255,207";
	$HashColData{"RdYlGn"}{3}{B}="89,191,96";
	$HashColData{"RdYlGn"}{4}{R}="215,253,166,26";
	$HashColData{"RdYlGn"}{4}{G}="25,174,217,150";
	$HashColData{"RdYlGn"}{4}{B}="28,97,106,65";
	$HashColData{"RdYlGn"}{5}{R}="215,253,255,166,26";
	$HashColData{"RdYlGn"}{5}{G}="25,174,255,217,150";
	$HashColData{"RdYlGn"}{5}{B}="28,97,191,106,65";
	$HashColData{"RdYlGn"}{6}{R}="215,252,254,217,145,26";
	$HashColData{"RdYlGn"}{6}{G}="48,141,224,239,207,152";
	$HashColData{"RdYlGn"}{6}{B}="39,89,139,139,96,80";
	$HashColData{"RdYlGn"}{7}{R}="215,252,254,255,217,145,26";
	$HashColData{"RdYlGn"}{7}{G}="48,141,224,255,239,207,152";
	$HashColData{"RdYlGn"}{7}{B}="39,89,139,191,139,96,80";
	$HashColData{"RdYlGn"}{8}{R}="215,244,253,254,217,166,102,26";
	$HashColData{"RdYlGn"}{8}{G}="48,109,174,224,239,217,189,152";
	$HashColData{"RdYlGn"}{8}{B}="39,67,97,139,139,106,99,80";
	$HashColData{"RdYlGn"}{9}{R}="215,244,253,254,255,217,166,102,26";
	$HashColData{"RdYlGn"}{9}{G}="48,109,174,224,255,239,217,189,152";
	$HashColData{"RdYlGn"}{9}{B}="39,67,97,139,191,139,106,99,80";
	$HashColData{"RdYlGn"}{10}{R}="165,215,244,253,254,217,166,102,26,0";
	$HashColData{"RdYlGn"}{10}{G}="0,48,109,174,224,239,217,189,152,104";
	$HashColData{"RdYlGn"}{10}{B}="38,39,67,97,139,139,106,99,80,55";
	$HashColData{"RdYlGn"}{11}{R}="165,215,244,253,254,255,217,166,102,26,0";
	$HashColData{"RdYlGn"}{11}{G}="0,48,109,174,224,255,239,217,189,152,104";
	$HashColData{"RdYlGn"}{11}{B}="38,39,67,97,139,191,139,106,99,80,55";

	$HashColData{"GnYlRd"}{3}{R}="145,255,252";
	$HashColData{"GnYlRd"}{3}{G}="207,255,141";
	$HashColData{"GnYlRd"}{3}{B}="96,191,89";
	$HashColData{"GnYlRd"}{4}{R}="26,166,253,215";
	$HashColData{"GnYlRd"}{4}{G}="150,217,174,25";
	$HashColData{"GnYlRd"}{4}{B}="65,106,97,28";
	$HashColData{"GnYlRd"}{5}{R}="26,166,255,253,215";
	$HashColData{"GnYlRd"}{5}{G}="150,217,255,174,25";
	$HashColData{"GnYlRd"}{5}{B}="65,106,191,97,28";
	$HashColData{"GnYlRd"}{6}{R}="26,145,217,254,252,215";
	$HashColData{"GnYlRd"}{6}{G}="152,207,239,224,141,48";
	$HashColData{"GnYlRd"}{6}{B}="80,96,139,139,89,39";
	$HashColData{"GnYlRd"}{7}{R}="26,145,217,255,254,252,215";
	$HashColData{"GnYlRd"}{7}{G}="152,207,239,255,224,141,48";
	$HashColData{"GnYlRd"}{7}{B}="80,96,139,191,139,89,39";
	$HashColData{"GnYlRd"}{8}{R}="26,102,166,217,254,253,244,215";
	$HashColData{"GnYlRd"}{8}{G}="152,189,217,239,224,174,109,48";
	$HashColData{"GnYlRd"}{8}{B}="80,99,106,139,139,97,67,39";
	$HashColData{"GnYlRd"}{9}{R}="26,102,166,217,255,254,253,244,215";
	$HashColData{"GnYlRd"}{9}{G}="152,189,217,239,255,224,174,109,48";
	$HashColData{"GnYlRd"}{9}{B}="80,99,106,139,191,139,97,67,39";
	$HashColData{"GnYlRd"}{10}{R}="0,26,102,166,217,254,253,244,215,165";
	$HashColData{"GnYlRd"}{10}{G}="104,152,189,217,239,224,174,109,48,0";
	$HashColData{"GnYlRd"}{10}{B}="55,80,99,106,139,139,97,67,39,38";
	$HashColData{"GnYlRd"}{11}{R}="0,26,102,166,217,255,254,253,244,215,165";
	$HashColData{"GnYlRd"}{11}{G}="104,152,189,217,239,255,224,174,109,48,0";
	$HashColData{"GnYlRd"}{11}{B}="55,80,99,106,139,191,139,97,67,39,38";


	$HashColData{"Set1"}{3}{R}="228,55,77";
	$HashColData{"Set1"}{3}{G}="26,126,175";
	$HashColData{"Set1"}{3}{B}="28,184,74";
	$HashColData{"Set1"}{4}{R}="228,55,77,152";
	$HashColData{"Set1"}{4}{G}="26,126,175,78";
	$HashColData{"Set1"}{4}{B}="28,184,74,163";
	$HashColData{"Set1"}{5}{R}="228,55,77,152,255";
	$HashColData{"Set1"}{5}{G}="26,126,175,78,127";
	$HashColData{"Set1"}{5}{B}="28,184,74,163,0";
	$HashColData{"Set1"}{6}{R}="228,55,77,152,255,255";
	$HashColData{"Set1"}{6}{G}="26,126,175,78,127,255";
	$HashColData{"Set1"}{6}{B}="28,184,74,163,0,51";
	$HashColData{"Set1"}{7}{R}="228,55,77,152,255,255,166";
	$HashColData{"Set1"}{7}{G}="26,126,175,78,127,255,86";
	$HashColData{"Set1"}{7}{B}="28,184,74,163,0,51,40";
	$HashColData{"Set1"}{8}{R}="228,55,77,152,255,255,166,247";
	$HashColData{"Set1"}{8}{G}="26,126,175,78,127,255,86,129";
	$HashColData{"Set1"}{8}{B}="28,184,74,163,0,51,40,191";
	$HashColData{"Set1"}{9}{R}="228,55,77,152,255,255,166,247,153";
	$HashColData{"Set1"}{9}{G}="26,126,175,78,127,255,86,129,153";
	$HashColData{"Set1"}{9}{B}="28,184,74,163,0,51,40,191,153";
	$HashColData{"Set2"}{3}{R}="102,252,141";
	$HashColData{"Set2"}{3}{G}="194,141,160";
	$HashColData{"Set2"}{3}{B}="165,98,203";
	$HashColData{"Set2"}{4}{R}="102,252,141,231";
	$HashColData{"Set2"}{4}{G}="194,141,160,138";
	$HashColData{"Set2"}{4}{B}="165,98,203,195";
	$HashColData{"Set2"}{5}{R}="102,252,141,231,166";
	$HashColData{"Set2"}{5}{G}="194,141,160,138,216";
	$HashColData{"Set2"}{5}{B}="165,98,203,195,84";
	$HashColData{"Set2"}{6}{R}="102,252,141,231,166,255";
	$HashColData{"Set2"}{6}{G}="194,141,160,138,216,217";
	$HashColData{"Set2"}{6}{B}="165,98,203,195,84,47";
	$HashColData{"Set2"}{7}{R}="102,252,141,231,166,255,229";
	$HashColData{"Set2"}{7}{G}="194,141,160,138,216,217,196";
	$HashColData{"Set2"}{7}{B}="165,98,203,195,84,47,148";
	$HashColData{"Set2"}{8}{R}="102,252,141,231,166,255,229,179";
	$HashColData{"Set2"}{8}{G}="194,141,160,138,216,217,196,179";
	$HashColData{"Set2"}{8}{B}="165,98,203,195,84,47,148,179";
	$HashColData{"Set3"}{3}{R}="141,255,190";
	$HashColData{"Set3"}{3}{G}="211,255,186";
	$HashColData{"Set3"}{3}{B}="199,179,218";
	$HashColData{"Set3"}{4}{R}="141,255,190,251";
	$HashColData{"Set3"}{4}{G}="211,255,186,128";
	$HashColData{"Set3"}{4}{B}="199,179,218,114";
	$HashColData{"Set3"}{5}{R}="141,255,190,251,128";
	$HashColData{"Set3"}{5}{G}="211,255,186,128,177";
	$HashColData{"Set3"}{5}{B}="199,179,218,114,211";
	$HashColData{"Set3"}{6}{R}="141,255,190,251,128,253";
	$HashColData{"Set3"}{6}{G}="211,255,186,128,177,180";
	$HashColData{"Set3"}{6}{B}="199,179,218,114,211,98";
	$HashColData{"Set3"}{7}{R}="141,255,190,251,128,253,179";
	$HashColData{"Set3"}{7}{G}="211,255,186,128,177,180,222";
	$HashColData{"Set3"}{7}{B}="199,179,218,114,211,98,105";
	$HashColData{"Set3"}{8}{R}="141,255,190,251,128,253,179,252";
	$HashColData{"Set3"}{8}{G}="211,255,186,128,177,180,222,205";
	$HashColData{"Set3"}{8}{B}="199,179,218,114,211,98,105,229";
	$HashColData{"Set3"}{9}{R}="141,255,190,251,128,253,179,252,217";
	$HashColData{"Set3"}{9}{G}="211,255,186,128,177,180,222,205,217";
	$HashColData{"Set3"}{9}{B}="199,179,218,114,211,98,105,229,217";
	$HashColData{"Set3"}{10}{R}="141,255,190,251,128,253,179,252,217,188";
	$HashColData{"Set3"}{10}{G}="211,255,186,128,177,180,222,205,217,128";
	$HashColData{"Set3"}{10}{B}="199,179,218,114,211,98,105,229,217,189";
	$HashColData{"Set3"}{11}{R}="141,255,190,251,128,253,179,252,217,188,204";
	$HashColData{"Set3"}{11}{G}="211,255,186,128,177,180,222,205,217,128,235";
	$HashColData{"Set3"}{11}{B}="199,179,218,114,211,98,105,229,217,189,197";
	$HashColData{"Set3"}{12}{R}="141,255,190,251,128,253,179,252,217,188,204,255";
	$HashColData{"Set3"}{12}{G}="211,255,186,128,177,180,222,205,217,128,235,237";
	$HashColData{"Set3"}{12}{B}="199,179,218,114,211,98,105,229,217,189,197,111";
	$HashColData{"Spectral"}{3}{R}="252,255,153";
	$HashColData{"Spectral"}{3}{G}="141,255,213";
	$HashColData{"Spectral"}{3}{B}="89,191,148";
	$HashColData{"Spectral"}{4}{R}="215,253,171,43";
	$HashColData{"Spectral"}{4}{G}="25,174,221,131";
	$HashColData{"Spectral"}{4}{B}="28,97,164,186";
	$HashColData{"Spectral"}{5}{R}="215,253,255,171,43";
	$HashColData{"Spectral"}{5}{G}="25,174,255,221,131";
	$HashColData{"Spectral"}{5}{B}="28,97,191,164,186";
	$HashColData{"Spectral"}{6}{R}="213,252,254,230,153,50";
	$HashColData{"Spectral"}{6}{G}="62,141,224,245,213,136";
	$HashColData{"Spectral"}{6}{B}="79,89,139,152,148,189";
	$HashColData{"Spectral"}{7}{R}="213,252,254,255,230,153,50";
	$HashColData{"Spectral"}{7}{G}="62,141,224,255,245,213,136";
	$HashColData{"Spectral"}{7}{B}="79,89,139,191,152,148,189";
	$HashColData{"Spectral"}{8}{R}="213,244,253,254,230,171,102,50";
	$HashColData{"Spectral"}{8}{G}="62,109,174,224,245,221,194,136";
	$HashColData{"Spectral"}{8}{B}="79,67,97,139,152,164,165,189";
	$HashColData{"Spectral"}{9}{R}="213,244,253,254,255,230,171,102,50";
	$HashColData{"Spectral"}{9}{G}="62,109,174,224,255,245,221,194,136";
	$HashColData{"Spectral"}{9}{B}="79,67,97,139,191,152,164,165,189";
	$HashColData{"Spectral"}{10}{R}="158,213,244,253,254,230,171,102,50,94";
	$HashColData{"Spectral"}{10}{G}="1,62,109,174,224,245,221,194,136,79";
	$HashColData{"Spectral"}{10}{B}="66,79,67,97,139,152,164,165,189,162";
	$HashColData{"Spectral"}{11}{R}="158,213,244,253,254,255,230,171,102,50,94";
	$HashColData{"Spectral"}{11}{G}="1,62,109,174,224,255,245,221,194,136,79";
	$HashColData{"Spectral"}{11}{B}="66,79,67,97,139,191,152,164,165,189,162";
	$HashColData{"YlGn"}{3}{R}="247,173,49";
	$HashColData{"YlGn"}{3}{G}="252,221,163";
	$HashColData{"YlGn"}{3}{B}="185,142,84";
	$HashColData{"YlGn"}{4}{R}="255,194,120,35";
	$HashColData{"YlGn"}{4}{G}="255,230,198,132";
	$HashColData{"YlGn"}{4}{B}="204,153,121,67";
	$HashColData{"YlGn"}{5}{R}="255,194,120,49,0";
	$HashColData{"YlGn"}{5}{G}="255,230,198,163,104";
	$HashColData{"YlGn"}{5}{B}="204,153,121,84,55";
	$HashColData{"YlGn"}{6}{R}="255,217,173,120,49,0";
	$HashColData{"YlGn"}{6}{G}="255,240,221,198,163,104";
	$HashColData{"YlGn"}{6}{B}="204,163,142,121,84,55";
	$HashColData{"YlGn"}{7}{R}="255,217,173,120,65,35,0";
	$HashColData{"YlGn"}{7}{G}="255,240,221,198,171,132,90";
	$HashColData{"YlGn"}{7}{B}="204,163,142,121,93,67,50";
	$HashColData{"YlGn"}{8}{R}="255,247,217,173,120,65,35,0";
	$HashColData{"YlGn"}{8}{G}="255,252,240,221,198,171,132,90";
	$HashColData{"YlGn"}{8}{B}="229,185,163,142,121,93,67,50";
	$HashColData{"YlGn"}{9}{R}="255,247,217,173,120,65,35,0,0";
	$HashColData{"YlGn"}{9}{G}="255,252,240,221,198,171,132,104,69";
	$HashColData{"YlGn"}{9}{B}="229,185,163,142,121,93,67,55,41";
	$HashColData{"YlGnBu"}{3}{R}="237,127,44";
	$HashColData{"YlGnBu"}{3}{G}="248,205,127";
	$HashColData{"YlGnBu"}{3}{B}="177,187,184";
	$HashColData{"YlGnBu"}{4}{R}="255,161,65,34";
	$HashColData{"YlGnBu"}{4}{G}="255,218,182,94";
	$HashColData{"YlGnBu"}{4}{B}="204,180,196,168";
	$HashColData{"YlGnBu"}{5}{R}="255,161,65,44,37";
	$HashColData{"YlGnBu"}{5}{G}="255,218,182,127,52";
	$HashColData{"YlGnBu"}{5}{B}="204,180,196,184,148";
	$HashColData{"YlGnBu"}{6}{R}="255,199,127,65,44,37";
	$HashColData{"YlGnBu"}{6}{G}="255,233,205,182,127,52";
	$HashColData{"YlGnBu"}{6}{B}="204,180,187,196,184,148";
	$HashColData{"YlGnBu"}{7}{R}="255,199,127,65,29,34,12";
	$HashColData{"YlGnBu"}{7}{G}="255,233,205,182,145,94,44";
	$HashColData{"YlGnBu"}{7}{B}="204,180,187,196,192,168,132";
	$HashColData{"YlGnBu"}{8}{R}="255,237,199,127,65,29,34,12";
	$HashColData{"YlGnBu"}{8}{G}="255,248,233,205,182,145,94,44";
	$HashColData{"YlGnBu"}{8}{B}="217,177,180,187,196,192,168,132";
	$HashColData{"YlGnBu"}{9}{R}="255,237,199,127,65,29,34,37,8";
	$HashColData{"YlGnBu"}{9}{G}="255,248,233,205,182,145,94,52,29";
	$HashColData{"YlGnBu"}{9}{B}="217,177,180,187,196,192,168,148,88";
	$HashColData{"YlOrBr"}{3}{R}="255,254,217";
	$HashColData{"YlOrBr"}{3}{G}="247,196,95";
	$HashColData{"YlOrBr"}{3}{B}="188,79,14";
	$HashColData{"YlOrBr"}{4}{R}="255,254,254,204";
	$HashColData{"YlOrBr"}{4}{G}="255,217,153,76";
	$HashColData{"YlOrBr"}{4}{B}="212,142,41,2";
	$HashColData{"YlOrBr"}{5}{R}="255,254,254,217,153";
	$HashColData{"YlOrBr"}{5}{G}="255,217,153,95,52";
	$HashColData{"YlOrBr"}{5}{B}="212,142,41,14,4";
	$HashColData{"YlOrBr"}{6}{R}="255,254,254,254,217,153";
	$HashColData{"YlOrBr"}{6}{G}="255,227,196,153,95,52";
	$HashColData{"YlOrBr"}{6}{B}="212,145,79,41,14,4";
	$HashColData{"YlOrBr"}{7}{R}="255,254,254,254,236,204,140";
	$HashColData{"YlOrBr"}{7}{G}="255,227,196,153,112,76,45";
	$HashColData{"YlOrBr"}{7}{B}="212,145,79,41,20,2,4";
	$HashColData{"YlOrBr"}{8}{R}="255,255,254,254,254,236,204,140";
	$HashColData{"YlOrBr"}{8}{G}="255,247,227,196,153,112,76,45";
	$HashColData{"YlOrBr"}{8}{B}="229,188,145,79,41,20,2,4";
	$HashColData{"YlOrBr"}{9}{R}="255,255,254,254,254,236,204,153,102";
	$HashColData{"YlOrBr"}{9}{G}="255,247,227,196,153,112,76,52,37";
	$HashColData{"YlOrBr"}{9}{B}="229,188,145,79,41,20,2,4,6";
	$HashColData{"YlOrRd"}{3}{R}="255,254,240";
	$HashColData{"YlOrRd"}{3}{G}="237,178,59";
	$HashColData{"YlOrRd"}{3}{B}="160,76,32";
	$HashColData{"YlOrRd"}{4}{R}="255,254,253,227";
	$HashColData{"YlOrRd"}{4}{G}="255,204,141,26";
	$HashColData{"YlOrRd"}{4}{B}="178,92,60,28";
	$HashColData{"YlOrRd"}{5}{R}="255,254,253,240,189";
	$HashColData{"YlOrRd"}{5}{G}="255,204,141,59,0";
	$HashColData{"YlOrRd"}{5}{B}="178,92,60,32,38";
	$HashColData{"YlOrRd"}{6}{R}="255,254,254,253,240,189";
	$HashColData{"YlOrRd"}{6}{G}="255,217,178,141,59,0";
	$HashColData{"YlOrRd"}{6}{B}="178,118,76,60,32,38";
	$HashColData{"YlOrRd"}{7}{R}="255,254,254,253,252,227,177";
	$HashColData{"YlOrRd"}{7}{G}="255,217,178,141,78,26,0";
	$HashColData{"YlOrRd"}{7}{B}="178,118,76,60,42,28,38";
	$HashColData{"YlOrRd"}{8}{R}="255,255,254,254,253,252,227,177";
	$HashColData{"YlOrRd"}{8}{G}="255,237,217,178,141,78,26,0";
	$HashColData{"YlOrRd"}{8}{B}="204,160,118,76,60,42,28,38";
	$HashColData{"YlOrRd"}{9}{R}="255,255,254,254,253,252,227,189,128";
	$HashColData{"YlOrRd"}{9}{G}="255,237,217,178,141,78,26,0,0";
	$HashColData{"YlOrRd"}{9}{B}="204,160,118,76,60,42,28,38,38";


	if  (exists  $HashColData{$Flag}{$Num}{R})
	{
		my @RR=split /\,/,$HashColData{$Flag}{$Num}{R};
		my @GG=split /\,/,$HashColData{$Flag}{$Num}{G};
		my @BB=split /\,/,$HashColData{$Flag}{$Num}{B};
		my $Count=$Num-1;
		foreach my $k (0..$Count)
		{
			@$CorArry[$k]="rgb($RR[$k],$GG[$k],$BB[$k])";
		}
		return $Count ;
	}
	elsif ($Num<$MaxColNum{$Flag})
	{
		my @GG=split /\,/,$HashColData{$Flag}{3}{G};
		my @BB=split /\,/,$HashColData{$Flag}{3}{B};
		my @RR=split /\,/,$HashColData{$Flag}{3}{R};
		foreach my $k (0..2)
		{
			@$CorArry[$k]="rgb($RR[$k],$GG[$k],$BB[$k])";
		}
		return $Num;
	}
	else
	{

		my $CorNumDefaut=$MaxColNum{$Flag};
		for (my $Count=$CorNumDefaut ; $Count>=3 ; $Count--)
		{
			my $BBEE=$Count-1;
			my $ccc=($Num-$Count) % $BBEE;
			if ($ccc==0)
			{
				my @RR=split /\,/,$HashColData{$Flag}{$Count}{R};
				my @GG=split /\,/,$HashColData{$Flag}{$Count}{G};
				my @BB=split /\,/,$HashColData{$Flag}{$Count}{B};
				my $bin=int (($Num-$Count) / $BBEE)+1;
				my $NowArry;

				foreach  my $kk  (1..$#RR)
				{
					my $binRR=($RR[$kk]-$RR[$kk-1])*1.0/$bin;
					my $binGG=($GG[$kk]-$GG[$kk-1])*1.0/$bin;
					my $binBB=($BB[$kk]-$BB[$kk-1])*1.0/$bin;

					foreach my $this (0..$bin)
					{
						$NowArry=($kk-1)*$bin+$this;
						my $NewRR=int($RR[$kk-1]+$binRR*$this);
						my $NewGG=int($GG[$kk-1]+$binGG*$this);
						my $NewBB=int($BB[$kk-1]+$binBB*$this);
						@$CorArry[$NowArry]="rgb($NewRR,$NewGG,$NewBB)";
					}
				}
				$NowArry++;
				@$CorArry[$NowArry]="rgb($RR[-1],$GG[-1],$BB[-1])";
				return $NowArry;
			}
		}

		$Num--;

		for (my $Count=$CorNumDefaut ; $Count>=3 ; $Count--)
		{
			my $BBEE=$Count-1;
			my $ccc=($Num-$Count) % $BBEE;
			if  ($ccc==0)
			{
				my @RR=split /\,/,$HashColData{$Flag}{$Count}{R};
				my @GG=split /\,/,$HashColData{$Flag}{$Count}{G};
				my @BB=split /\,/,$HashColData{$Flag}{$Count}{B};
				my $bin=int (($Num-$Count) / $BBEE)+1;
				my $NowArry;
				foreach  my $kk  (1..$#RR)
				{
					my $binRR=($RR[$kk]-$RR[$kk-1])*1.0/$bin;
					my $binGG=($GG[$kk]-$GG[$kk-1])*1.0/$bin;
					my $binBB=($BB[$kk]-$BB[$kk-1])*1.0/$bin;

					foreach my $this (0..$bin)
					{
						$NowArry=($kk-1)*$bin+$this;
						my $NewRR=int($RR[$kk-1]+$binRR*$this);
						my $NewGG=int($GG[$kk-1]+$binGG*$this);
						my $NewBB=int($BB[$kk-1]+$binBB*$this);
						@$CorArry[$NowArry]="rgb($NewRR,$NewGG,$NewBB)";
					}
				}

				$NowArry++;
				@$CorArry[$NowArry]="rgb($RR[-1],$GG[-1],$BB[-1])";
				@$CorArry[$NowArry+1]="rgb($RR[-1],$GG[-1],$BB[-1])";
				return $NowArry;
			}
		}

	}

}




#########

sub SVGgetShape
{
	my  $XX = shift ;
	my  $YY = shift ;
	my  $size = shift ;
	my  $shape = shift ;
	my  $Col =  shift;
	my  $svg = shift ;
	my  $HH=$size/6;  if ($HH<1) {$HH=1;}
	switch($shape)
	{
		case 0 {$svg->circle(cx=>$XX, cy=>$YY, r=>$size, fill => $Col);}
		case 1 {my $XX1=$XX-$size;my $YY1=$YY-$size;$svg->rect('x',$XX1,'y',$YY1,'width',$size*2,'height',$size*2,'fill',$Col,'stroke',$Col,'stroke-width',$HH);}
		case 2 {
			my $XX1=$XX-$size;my $YY1=$YY-$size;
			my $XX2=$XX+$size;my $YY2=$YY+$size;
			my $path = $svg->get_path(
				x => [$XX, $XX2, $XX,$XX1],
				y => [$YY1, $YY, $YY2,$YY],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => $Col,
					'stroke'         => $Col,
					'stroke-width'   =>  0,
				},
			);
		}
		case 3 {
			my $AA=$size/2; my $BB=$AA*1.732;
			my $XX1=$XX-$BB;my $XX2=$XX+$BB;
			my $YY1=$YY-$BB;my $YY2=$YY+$AA;
			my $path = $svg->get_path(
				x => [$XX, $XX2, $XX1],
				y => [$YY1, $YY2, $YY2],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => $Col,
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}
		case 4 {
			my $AA=$size/2; my $BB=$AA*1.732;
			my $XX1=$XX-$BB;my $XX2=$XX+$BB;
			my $YY1=$YY-$BB;my $YY2=$YY+$AA;
			my $path = $svg->get_path(
				x => [$XX1, $XX2, $XX],
				y => [$YY1, $YY1, $YY2],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => $Col,
					'stroke'         => $Col,
					'stroke-width'   =>  $HH,
				},
			);
		}
		case 5 {
			my $XXA=$XX ; my $YYA=$YY-$size;				
			my $AA=$size*0.951; my $BB=$size*0.309;
			my $XXE=$XX+$AA ; my $YYE=$YY-$BB;
			my $XXB=$XX-$AA ; my $YYB=$YYE;				
			my $DD=$BB*0.7265;  my $EE=$BB*1.701;
			my $XXH=$XX+$DD ; my $YYH=$YYE;
			my $XXI=$XX-$DD ; my $YYI=$YYE;
			my $FF=$size*0.5878; my $HHH=$size*0.809;
			my $XXC=$XX-$FF; my  $YYC=$YY+$HHH;
			my $XXD=$XX+$FF; my $YYD=$YY+$HHH;
			my $XXF=$XX;   my $YYF=$YY+$EE;
			my $AAA=$EE*0.951; my $BBB=$EE*0.309;
			my $XXG=$XX+$AAA ; my $YYG=$YY+$BBB;
			my $XXJ=$XX-$AAA ; my $YYJ=$YYG;				
			my $path = $svg->get_path(
				x => [$XXA,$XXH,$XXE,$XXG,$XXD,$XXF,$XXC,$XXJ,$XXB,$XXI],
				y => [$YYA,$YYH,$YYE,$YYG,$YYD,$YYF,$YYC,$YYJ,$YYB,$YYI],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => $Col,
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}
		case 6 {$svg->circle(cx=>$XX, cy=>$YY, r=>$size, fill => "none",'stroke',$Col,'stroke-width',$HH );}
		case 7 {my $XX1=$XX-$size;my $YY1=$YY-$size;$svg->rect('x',$XX1,'y',$YY1,'width',$size*2,'height',$size*2,'fill',"none",'stroke',$Col,'stroke-width',$HH);}
		case 8 {
			my $XX1=$XX-$size;my $YY1=$YY-$size;
			my $XX2=$XX+$size;my $YY2=$YY+$size;
			my $path = $svg->get_path(
				x => [$XX, $XX2, $XX,$XX1],
				y => [$YY1, $YY, $YY2,$YY],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => "none",
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}
		case 9 {
			my $AA=$size/2; my $BB=$AA*1.732;
			my $XX1=$XX-$BB;my $XX2=$XX+$BB;
			my $YY1=$YY-$BB;my $YY2=$YY+$AA;
			my $path = $svg->get_path(
				x => [$XX, $XX2, $XX1],
				y => [$YY1, $YY2, $YY2],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => "none",
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}
		case 10 {
			my $AA=$size/2; my $BB=$AA*1.732;
			my $XX1=$XX-$BB;my $XX2=$XX+$BB;
			my $YY1=$YY-$BB;my $YY2=$YY+$AA;
			my $path = $svg->get_path(
				x => [$XX1, $XX2, $XX],
				y => [$YY1, $YY1, $YY2],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => "none",
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}
		case 11 {
			my $XXA=$XX ; my $YYA=$YY-$size;				
			my $AA=$size*0.951; my $BB=$size*0.309;
			my $XXE=$XX+$AA ; my $YYE=$YY-$BB;
			my $XXB=$XX-$AA ; my $YYB=$YYE;				
			my $DD=$BB*0.7265;  my $EE=$BB*1.701;
			my $XXH=$XX+$DD ; my $YYH=$YYE;
			my $XXI=$XX-$DD ; my $YYI=$YYE;
			my $FF=$size*0.5878; my $HHH=$size*0.809;
			my $XXC=$XX-$FF; my  $YYC=$YY+$HHH;
			my $XXD=$XX+$FF; my $YYD=$YY+$HHH;
			my $XXF=$XX;   my $YYF=$YY+$EE;
			my $AAA=$EE*0.951; my $BBB=$EE*0.309;
			my $XXG=$XX+$AAA ; my $YYG=$YY+$BBB;
			my $XXJ=$XX-$AAA ; my $YYJ=$YYG;				
			my $path = $svg->get_path(
				x => [$XXA,$XXH,$XXE,$XXG,$XXD,$XXF,$XXC,$XXJ,$XXB,$XXI],
				y => [$YYA,$YYH,$YYE,$YYG,$YYD,$YYF,$YYC,$YYJ,$YYB,$YYI],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => 'none',
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);

		}
		case 12 {
			my $AA=$size/2; my $BB=$AA*1.732;
			$YY=$YY-$AA;  $XX=$XX-$size*0.067;				
			my $XX1=$XX-$BB;my $YY1=$YY+$AA;
			my $XX2=$XX;    my $YY2=$YY;
			my $XX3=$XX+$size;my $YY3=$YY;
			my $XX4=$XX3 ;my $YY4=$YY+$size;
			my $XX5=$XX ; my $YY5=$YY4;

			my $path = $svg->get_path(
				x => [$XX1, $XX2, $XX3,$XX4,$XX5],
				y => [$YY1, $YY2, $YY3,$YY4,$YY5],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => $Col,
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}
		case 13 {
			my $AA=$size/2; my $BB=$AA*1.732;
			$YY=$YY-$AA;	$XX=$XX-$size*0.933;
			my $XX1=$XX;    my $YY1=$YY;
			my $XX2=$XX+$size;    my $YY2=$YY;
			my $XX3=$XX2+$BB ;   my $YY3=$YY+$AA;
			my $XX4=$XX2 ;my $YY4=$YY+$size;
			my $XX5=$XX ; my $YY5=$YY4;

			my $path = $svg->get_path(
				x => [$XX1, $XX2, $XX3,$XX4,$XX5],
				y => [$YY1, $YY2, $YY3,$YY4,$YY5],
				-type => 'polygon');
			$svg->polygon(
				%$path,
				style => {
					'fill'           => $Col,
					'stroke'         => $Col,
					'stroke-width'   => $HH,
				},
			);
		}


	}
}
######################swimming in the sky and flying in the sea ########################






###########   Deal the  Para ##########

my %HashConfi;
#my @FirstArryhead ;

$HashConfi{"global"}{"body"}=1200;
$HashConfi{"global"}{"up"}=55;
$HashConfi{"global"}{"down"}=25;
$HashConfi{"global"}{"left"}=100;
$HashConfi{"global"}{"strokewidth"}=1;
$HashConfi{"global"}{"right"}=120;
$HashConfi{"global"}{"RotatePng"}=0;
$HashConfi{"global"}{"RotateChrName"}=0;
$HashConfi{"global"}{"font-family"}="Arial";
$HashConfi{"global"}{"fill"}="green";
$HashConfi{"global"}{"ShiftXaxisY"}=0;
$HashConfi{"global"}{"ChrSpacingRatio"}=0.2;
$HashConfi{"global"}{"ScaleNum"}=10;
$HashConfi{"global"}{"ChrArrayDirection"}="vertical";
$HashConfi{"ALL"}{"PType"}="heatmap";
$HashConfi{"ALL"}{"crBG"}="#B8B8B8";
$HashConfi{"ALL"}{"TopVHigh"}=0.95;
$HashConfi{"ALL"}{"TopVLow"}=0;
$HashConfi{"ALL"}{"Gradien"}=8;
$HashConfi{"ALL"}{"ChrWidth"}=20;
$HashConfi{"ALL"}{"strokeWidthBG"}=0;
$HashConfi{"ALL"}{"BGWidthRatio"}=1;
$HashConfi{"ALL"}{"LogP"}=0;
$HashConfi{"ALL"}{"Rotate"}=0;
$HashConfi{"ALL"}{"font-family"}="Arial";
$HashConfi{"ALL"}{"ValueSpacingRatio"}=0;
$HashConfi{"ALL"}{"SizeGradienRatio"}=1.0;
$HashConfi{"ALL"}{"strokewidth"}=1;
$HashConfi{"ALL"}{"ShowYaxis"}=0;
$HashConfi{"ALL"}{"ShiftGradienX"}=0;
$HashConfi{"ALL"}{"ShiftGradienY"}=0;
$HashConfi{"ALL"}{"fill-opacity"}=1;
$HashConfi{"ALL"}{"stroke-opacity"}=1;
$HashConfi{"ALL"}{"ShiftChrNameX"}=0;$HashConfi{"ALL"}{"ShiftChrNameY"}=0;
$HashConfi{"1"}{"ShiftChrNameX"}=0;$HashConfi{"1"}{"ShiftChrNameY"}=0;
$HashConfi{"2"}{"ShiftChrNameX"}=0;$HashConfi{"2"}{"ShiftChrNameY"}=0;
$HashConfi{"ALL"}{"BGChrEndCurve"}=1;
$HashConfi{"ALL"}{"NoShowGradien"}=0;


my @ParaFlagA=(); my $NumParaFlagA=0;
$ParaFlagA[$NumParaFlagA]="PType"; $NumParaFlagA++;
$NumParaFlagA--;



my @ParaFlag=(); my $NumParaFlag=0;
$ParaFlag[$NumParaFlag]="crBegin"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="crMid"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="crBG"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="crEnd"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="TopVLow"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="Gradien"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="ChrWidth"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="BGWidthRatio"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="LogP"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="ValueSpacingRatio"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="SizeGradienRatio"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="font-size"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="font-family"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="Rotate"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="strokewidth"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="ShowYaxis"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="crStrokeBG"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="ShiftGradienX"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="ShiftGradienY"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="strokeWidthBG"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="stroke-opacity"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="fill-opacity"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="NoShowGradien"; $NumParaFlag++;
$ParaFlag[$NumParaFlag]="BGChrEndCurve"; $NumParaFlag++;

$NumParaFlag--;
##Rotate/fill/Cutline/stroke/strokewidth/font-size/font-family/  =   ### 等等

my @FileData=();
my @FileRow=();
my @FileColumn=();
my $SetParaFor=-1;
my %hashChr ;
my %hashChr2File ;


if  ($InConfi =~s/\.gz$/\.gz/)
{
	open INC,"gzip -cd $InConfi | "  || die "input $InConfi file can't open $!" ;
}
else
{
	open INC,"$InConfi" or  die "input Confi file $InConfi can't open $!";
}


my $MaxLevel=0;
while (<INC>)
{
	chomp;
	$_=~s/^ +//;  $_=~s/\r$//g;
	$_=~s/ +$//;	next if(/^#/);	next if(/^$/);
	next if (!($_ =~ /=/));
	my @bbb=split /\#\#/,$_;	$_=$bbb[0];
	$_=~s/^ +//;	$_=~s/ +$//;	next if(/^#/);	next if(/^$/);
	$_=~s/\"#/UUUU/g;
	@bbb=();	@bbb=split /\#/,$_;	$_=$bbb[0];
	$_=~s/UUUU/\"#/g;
	$_=~s/\"//g;
	$_=~s/^ +//;    $_=~s/ +$//;
	next if (!($_=~s/=/=/))  ;
	my ($Para,$InfoPara) = split(/\s*=\s*/,$_);
	$Para=~s/^ +//  ; $Para=~s/ +$//;
	$Para=~s/^\t+//  ; $Para=~s/\t+$//;
	$Para=~s/^ +//  ; $Para=~s/ +$//;
	next if  ( $Para eq "");
	$InfoPara=~s/^ +// ;  $InfoPara=~s/ +$//;
	$InfoPara=~s/^\t+// ;  $InfoPara=~s/\t+$//;
	$InfoPara=~s/^ +// ;  $InfoPara=~s/ +$//;
	if  ($Para eq "SetParaFor")
	{
		$InfoPara=~s/Level//g;
		$SetParaFor=$InfoPara;
		if ( $InfoPara =~ /^\d+$/ )
		{
			if ($MaxLevel<$InfoPara)
			{
				$MaxLevel=$InfoPara;
			}
		}
	}
	elsif ( $Para=~s/File//g)
	{
		$Para--;
		if ($Para<0) { print "\tError: Para FileN ; The N number should start from 1 \n";exit;}
		if (!(-e $InfoPara )) { print "\tError: InPut File $InfoPara file can't open,please chect this file\n";exit; }
		if  ($InfoPara =~s/\.gz$/\.gz/)
		{
			open INTmp,"gzip -cd  $InfoPara | "  || die "input $InfoPara file can't open $!" ;
		}
		else
		{
			open INTmp,"$InfoPara" or  die "input $InfoPara file can't open $!";
		}	

		$_=<INTmp>;chomp ; my @Arryhead=split /\s+/,$_;

		close INTmp;

		my $ColumnNum=$#Arryhead;
		$FileColumn[$Para]=$ColumnNum;

		if  ($InfoPara =~s/\.gz$/\.gz/)
		{
			open INData,"gzip -cd  $InfoPara | "  || die "input $InfoPara file can't open $!" ;
		}
		else
		{
			open INData,"$InfoPara" or  die "input $InfoPara file can't open $!";
		}

		my $Row=0;
		while(<INData>)
		{
			chomp;
			my @inf=split ;
			next if ($#inf<2);
			foreach my $ThisCoumn (0..$ColumnNum)
			{
				$FileData[$Para][$Row][$ThisCoumn]=$inf[$ThisCoumn];
			}
			$Row++;

			next if  ($_=~/#/);
			if (!exists $hashChr{$inf[0]})
			{
				$hashChr{$inf[0]}=$inf[2];
				$hashChr2File{$inf[0]}=$Para;
			}
			else
			{
				if  ( $hashChr{$inf[0]}  <  $inf[2] )
				{
					$hashChr{$inf[0]}=$inf[2];
				}
			}
		}
		$FileRow[$Para]=$Row;
		close INData;
	}
	else
	{
		$HashConfi{$SetParaFor}{$Para}=$InfoPara;
	}


}
close INC;


if ( exists $HashConfi{"global"}{"ZoomRegion"})
{
	my @Region=split /\:/,$HashConfi{"global"}{"ZoomRegion"};
	if ($#Region!=2)
	{
		print "\tError:\t global Para ZoomRegion Format wrong: should be like as [chr1:1000:5000]\n";
		print "\tPlease check it\n";
		exit ;
	}
	if  (!exists  $hashChr{$Region[0]} )
	{
		print "\tError:\t global Para ZoomRegion Chr Name wrong: Can't find the $Region[0] chr Name at the  FileX file \n ";
		print "\tPlease check it\n";
		exit ;
	}
	if ($Region[1]>$Region[2])
	{
		print "Warning:\t global Para ZoomRegion : $Region[1] and $Region[2] maybe wrong,we change them\n";
		my $aa=$Region[2]; $Region[2]=$Region[1]; $Region[1]=$aa;
	}
	$HashConfi{global}{"ZoomRegion"}=\@Region;

	my $FileNum=$#FileData ;

	my @FileDataRegion=();
	my @FileRowRegion=();
	my %hashChrRegion ;
	my %hashChr2FileRegion ;



	foreach my $FileCount (0..$FileNum)
	{

		my $ColumnNum=$FileColumn[$FileCount] ;
		my $Row=$FileRow[$FileCount];
		my $newRowRegion=0;
		for( my $thisRow=0 ; $thisRow< $Row ;$thisRow++)
		{			
			if ($FileData[$FileCount][$thisRow][0]  =~s/#/#/ )
			{

				foreach my $ThisCoumn (0..$ColumnNum)
				{
					$FileDataRegion[$FileCount][$newRowRegion][$ThisCoumn] =$FileData[$FileCount][$thisRow][$ThisCoumn] ;
				}
				$newRowRegion++;
				next ;
			}

			next if  ( $FileData[$FileCount][$thisRow][0]  ne $Region[0] );
			next if ($FileData[$FileCount][$thisRow][1] < $Region[1])  && ($FileData[$FileCount][$thisRow][2] < $Region[1] );
			next if ($FileData[$FileCount][$thisRow][1] > $Region[2])  && ($FileData[$FileCount][$thisRow][2] > $Region[2] );



			if ( ($FileData[$FileCount][$thisRow][1]>=$Region[1])  &&     ($FileData[$FileCount][$thisRow][1]<=$Region[2]))
			{
				$FileData[$FileCount][$thisRow][1]=$FileData[$FileCount][$thisRow][1]-$Region[1]+1;
			}
			elsif ($FileData[$FileCount][$thisRow][1]<$Region[1])
			{
				$FileData[$FileCount][$thisRow][1]=1;
			}
			else
			{
				$FileData[$FileCount][$thisRow][1]=$Region[2]-$Region[1]+1;
			}


			if ( ($FileData[$FileCount][$thisRow][2]>=$Region[1])  &&     ($FileData[$FileCount][$thisRow][2]<=$Region[2]))
			{
				$FileData[$FileCount][$thisRow][2]=$FileData[$FileCount][$thisRow][2]-$Region[1]+1;
			}
			elsif ($FileData[$FileCount][$thisRow][2]<$Region[1])
			{
				$FileData[$FileCount][$thisRow][2]=1;
			}
			else
			{
				$FileData[$FileCount][$thisRow][2]=$Region[2]-$Region[1]+1;
			}

			foreach my $ThisCoumn (0..$ColumnNum)
			{
				$FileDataRegion[$FileCount][$newRowRegion][$ThisCoumn] =$FileData[$FileCount][$thisRow][$ThisCoumn] ;
			}

			if (!exists $hashChr2FileRegion{$FileData[$FileCount][$thisRow][0]})
			{
				$hashChr2FileRegion{$FileData[$FileCount][$newRowRegion][0]}=$FileCount;
			}
			$newRowRegion++;
		}
		$FileRowRegion[$FileCount]=$newRowRegion;
	}


	foreach my $chrname (keys  %hashChr)
	{
		next if  ( $chrname  ne $Region[0]);
		$hashChrRegion{$chrname}=$Region[2]-$Region[1]+1;
	}
	%hashChr=(); %hashChr=%hashChrRegion;
	%hashChr2File=();  %hashChr2File=%hashChr2FileRegion;
	@FileData=();   @FileData=@FileDataRegion;
	@FileRow=();	@FileRow=@FileRowRegion;
}




if ( !exists $HashConfi{"global"}{"ValueX"})
{
	my $VV=$FileColumn[0]; $VV||=0;
	if ($VV<3)
	{
		print "Error:\tCan't found InPut File1 or Format wrong\n";
		exit ;
	}
	$HashConfi{"global"}{"ValueX"}=$VV-2;
}

if (!exists $HashConfi{"ALL"}{"crStrokeBG"})
{
	$HashConfi{"ALL"}{"crStrokeBG"}=$HashConfi{"ALL"}{"crBG"};
}

if ( (exists $HashConfi{"ALL"}{"crBegin"})  || (exists $HashConfi{"ALL"}{"crMid"})   &&   (exists $HashConfi{"ALL"}{"crEnd"}) || (exists $HashConfi{"ALL"}{"ColorBrewer"})  )
{
	print "Warning:\tSetParaFor= [ALL], Para (crBegin/crMid/crEnd/ColorBrewer) should be seted in each Level,move it to  SetParaFor=LevelX\n";
}
$HashConfi{"ALL"}{"crBegin"}||="#006400";
$HashConfi{"ALL"}{"crMid"}||="#FFFF00";
$HashConfi{"ALL"}{"crEnd"}||="#FF0000";


my $NumberLevel=$HashConfi{"global"}{"ValueX"};
if ($MaxLevel>$NumberLevel) 
{

	my $TF=0;
	if  ( ($HashConfi{"ALL"}{"PType"} eq  "link")   ||  ($HashConfi{"ALL"}{"PType"} eq  "Link") )  {$TF=1;}
	if  ( (exists $HashConfi{"1"}{"PType"}  ) &&   ( ($HashConfi{"1"}{"PType"} eq  "link")   ||  ($HashConfi{"1"}{"PType"} eq  "Link") ))  {$TF=1;}
	if  ( (exists $HashConfi{"2"}{"PType"}  ) &&   ( ($HashConfi{"2"}{"PType"} eq  "link")   ||  ($HashConfi{"2"}{"PType"} eq  "Link") ))  {$TF=1;}
	if  ($TF==0)
	{
		print "\t\tthe Para [ValueX] you set/defaut is $NumberLevel , but we found the larger Level in SetParaFor=Level$MaxLevel, got the Max level is $MaxLevel\n";
		print "\t\tSo the ValueX para will change to be $MaxLevel\t,if not like this,you can check it again in.cofi\n";
		$HashConfi{"global"}{"ValueX"}=$MaxLevel;
		$NumberLevel=$MaxLevel;
	}
}


my @ShowColumn=();
my $WidthForOneChr=0;
my $MaxGradien=$HashConfi{"ALL"}{"Gradien"};
my $chrNameShiftRitao=0.3;
my $PTypeLink=0;
foreach my $Level (1..$NumberLevel)
{
	my $AA=$Level-1;
	if (!exists $HashConfi{$Level}{"ShowColumn"})
	{
		my $VV=$FileColumn[$AA]; $VV||=-1;
		if ($VV>2)
		{
			push @{$ShowColumn[$AA]},[$AA,3];
		}
		else
		{
			my $VVV=$FileColumn[0]; $VVV||=-1;
			if (($VVV<3  || ($AA+3)>$VVV))
			{
				print "Error:\t\tCan't find the File$AA or File1 for seting the default parameter [ShowColumn] for Level $Level: details as follows \n";
				print "Error:\t\tFile$AA Column only $VV+1 (>2) and File1 Column only $VVV+1 (>2)\n ";
				print "Error:\t\tPlease set the parameter [ShowColumn] for Level:$Level manually\n";
				exit ;
			}
			else
			{
				push @{$ShowColumn[$AA]},[0,$AA+3];
			}
		}
	}
	else
	{
		my @temAA=split /\s+/,$HashConfi{$Level}{"ShowColumn"};
		foreach my $tmpA (0..$#temAA)
		{
			my @temBB=split /\:/,$temAA[$tmpA];
			if ($temBB[0]=~s/File//g)
			{
				$temBB[0]--;
				my $VV=$FileColumn[$temBB[0]]; $VV||=-1;
				if ($VV<0) { print "Error:\tCan't find the File $temBB[0]+1 \n"; exit ;}
				my @temCC=split /\,/,$temBB[-1];
				foreach my $coumn (@temCC)
				{
					$coumn--;
					if  ($coumn <3 || $coumn>$VV)
					{
						print "Error:\tFile $temBB[0]+1 Column only $VV+1, but you give the ShowColumn is $coumn\n";
						exit ;
					}
					else
					{
						push @{$ShowColumn[$AA]},[$temBB[0],$coumn];
					}
				}
			}
			else
			{
				print "Error:\tPara [ShowColumn]  For $Level Format wrong \n";
				exit;
			}
		}
	}



	if (exists  $HashConfi{$Level}{"ColorBrewer"} )
	{
		my $FlagCol=$HashConfi{$Level}{"ColorBrewer"};
		if (!exists $MaxColNum{$FlagCol} )
		{
			print "RColor Brewer must be in Specified name,like BrBG,PiYG,PRGn...  but $FlagCol is no\n";
			print "see more in the website at ： https://www.r-graph-gallery.com/38-rcolorbrewers-palettes.html\n";
			print "we change  your  $FlagCol  --->  GnYlRd \n";
			$FlagCol="GnYlRd";
			$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
		}
		if (!exists   $HashConfi{$Level}{"Gradien"} )
		{
			$HashConfi{$Level}{"Gradien"}=$MaxColNum{$FlagCol};
		}
		if  (exists $QualColNum{$FlagCol})
		{
			my $MaxCol=$QualColNum{$FlagCol};
			if  ($HashConfi{$Level}{"Gradien"}>$MaxCol)
			{
				my $aattt=$HashConfi{$Level}{"Gradien"};
				print "For RColor qualitative Brewer Diverging palettes $FlagCol  Max Col only is $MaxCol, so we change  $aattt ----> $MaxCol\n";
				$HashConfi{$Level}{"Gradien"}=$MaxCol;
			}
		}
	}
	elsif ( (!exists $HashConfi{$Level}{"crBegin"})  && (!exists $HashConfi{$Level}{"crMid"})   &&   (!exists $HashConfi{$Level}{"crEnd"})  )
	{
		$HashConfi{$Level}{"ColorBrewer"}="NA";
		if (!exists   $HashConfi{$Level}{"Gradien"}){$HashConfi{$Level}{"ColorBrewer"}="NANA";}
	}

	foreach my $kk (0..$NumParaFlagA)
	{
		my $thisPara=$ParaFlagA[$kk];
		if ((exists $HashConfi{"ALL"}{$thisPara}) && (!exists $HashConfi{$Level}{$thisPara}))
		{
			$HashConfi{$Level}{$thisPara}=$HashConfi{"ALL"}{$thisPara};
		}
	}


	if (!exists   $HashConfi{$Level}{"TopVHigh"} )
	{
		if (($HashConfi{$Level}{"PType"} ne  "heatmap" )  &&  ( $HashConfi{$Level}{"PType"} ne  "highlights")  &&  ($HashConfi{"ALL"}{"TopVHigh"} ==0.95)  )
		{
			$HashConfi{$Level}{"TopVHigh"}=1.01;
		}
		else
		{
			$HashConfi{$Level}{"TopVHigh"}=$HashConfi{"ALL"}{"TopVHigh"};
		}
	}



	if ( (!exists  $HashConfi{$Level}{"crStrokeBG"})  &&  (exists $HashConfi{$Level}{"crBG"}) )
	{
		$HashConfi{$Level}{"crStrokeBG"}=$HashConfi{$Level}{"crBG"};
	}
	if ( (!exists $HashConfi{$Level}{"stroke-opacity"}) && (exists $HashConfi{$Level}{"fill-opacity"}))
	{
		$HashConfi{$Level}{"stroke-opacity"}=$HashConfi{$Level}{"fill-opacity"};
	}
	foreach my $kk (0..$NumParaFlag)
	{
		my $thisPara=$ParaFlag[$kk];
		if ((exists $HashConfi{"ALL"}{$thisPara}) && (!exists $HashConfi{$Level}{$thisPara}))
		{
			$HashConfi{$Level}{$thisPara}=$HashConfi{"ALL"}{$thisPara};
		}
	}	
	$WidthForOneChr+=$HashConfi{$Level}{"ChrWidth"};
	if  ($Level!=$NumberLevel)
	{
		$WidthForOneChr+=$HashConfi{$Level}{"ChrWidth"}*$HashConfi{$Level}{"ValueSpacingRatio"};
	}

	if  ($HashConfi{$Level}{"Gradien"}>255)
	{
		my $aattt=$HashConfi{$Level}{"Gradien"};
		print "\tWarning:\tLevel:$Level Para [-Gradien] is Max Gradien must < 255;\twe modify $aattt ---> 255\n";
		$HashConfi{$Level}{"Gradien"}=255;
	}
	elsif ($HashConfi{$Level}{"Gradien"}<3)
	{
		my $aattt=$HashConfi{$Level}{"Gradien"};
		print "\tWarning:\tLevel:$Level Para [-Gradien] is seted to be $aattt,but too small, we modify it to be 3\n";
		$HashConfi{$Level}{"Gradien"}=3;
	}

	if  (exists  $HashConfi{$Level}{"ReverseColor"})
	{
		my $cccctm= $HashConfi{$Level}{"crBegin"};
		$HashConfi{$Level}{"crBegin"}=$HashConfi{$Level}{"crEnd"};
		$HashConfi{$Level}{"crEnd"}=$HashConfi{$Level}{"crBegin"};
	}

	if ( $MaxGradien>$HashConfi{$Level}{"Gradien"})
	{
		$MaxGradien=$HashConfi{$Level}{"Gradien"};
	}

	if  ( $HashConfi{$Level}{"ShowYaxis"} >0 ) 
	{
		$chrNameShiftRitao=0.5;
	}

	if (($HashConfi{$Level}{"PType"}  eq  "link")   ||  ($HashConfi{$Level}{"PType"}  eq  "Link"))
	{
		$PTypeLink=1;
	}
	elsif ($HashConfi{$Level}{"PType"}=~s/Animated/Animated/)
	{
		my $PlotInfo=$ShowColumn[$Level-1];
		my $PlotArryNum=$#$PlotInfo+1;
		if ($PlotArryNum<2)
		{
			print "Error:\tIn Level $Level [-PType] is seted as [Animated svg],and the Animated svg Need [-ShowColumn] to be set as muti Column\n";
			print "Error:\tHowever we detected $Level [-ShowColumn] had only $PlotArryNum Column\n";
			exit(1);
		}
		my %tmpFile=();
		for (my $i=0; $i<$PlotArryNum; $i++)
		{
			my $NowPlot=$PlotInfo->[$i];
			my $FileNow=$NowPlot->[0];
			$tmpFile{$FileNow}++;
		}
		my @bbb=keys %tmpFile;
		if ($#bbb>0)
		{
			print "Error:\tIn Level $Level [-PType] is seted as [Animated svg],and the Animated svg Need [-ShowColumn] to be set on the same file\n";
			print "Error:\tHowever we detected $Level [-ShowColumn] had only $#bbb+1 files\n";
			exit(1);
		}
		else
		{
			print "\tThe svg file will be an animated svg, please open it with a newer browser to see the animation.\n";
			print "\tThe png file will be Final state, you can covernt  svg to gif by other tools\n";
		}
	}
}



my @ChrArry=();
if (exists $HashConfi{"global"}{"Chromosomes_order"})
{
	@ChrArry=split /\,/,$HashConfi{"global"}{"Chromosomes_order"};
}
else
{	
	@ChrArry=sort  keys  %hashChr;
	my $sedSort=1;
	my %tmpChrSort;
	foreach my $k (@ChrArry)
	{
		my $chr=$k;
		$chr=~s/^chromosome//;
		$chr=~s/^Chromosome//;
		$chr=~s/^Chr//;
		$chr=~s/^CHR//;
		$chr=~s/^chr//;
		$chr=~s/^LG//;
		$chr=~s/^lg//;
		if ($chr eq  'X' )  {$chr=23;}
		elsif ($chr eq  'Y' )  {$chr=24;}
		if ( $chr =~ /^\d+$/ )
		{
			$tmpChrSort{$k}=$chr;
		}
		else
		{
			$sedSort=0;
			last;
		}
	}

	if ($sedSort==1)
	{
		@ChrArry=sort {$tmpChrSort{$a} <=>$tmpChrSort{$b} } keys  %tmpChrSort;
	}
}


my $ChrMax=0;
my $TotalChrLength=0;
foreach my $thisChr (@ChrArry)
{
	if (!exists $hashChr{$thisChr} )
	{
		print "Error:\t\tsome Chr on Para  Chromosomes_order can't found the Data : $thisChr,please check it\n";
		exit ;
	}
	else
	{
		$TotalChrLength+=$hashChr{$thisChr};
		if ($ChrMax< $hashChr{$thisChr})
		{
			$ChrMax= $hashChr{$thisChr} ;
		}
	}
}

my $ShiftChrLenth=$ChrMax;
my $RegionStart=0;
if (exists $HashConfi{"global"}{"ZoomRegion"})
{
	my $regionArry=$HashConfi{"global"}{"ZoomRegion"};
	$RegionStart=$$regionArry[1];
	$ShiftChrLenth+=$$regionArry[1];
}

my $bin=1000000; my $label="Mb";
if (( $ShiftChrLenth/$bin)<10 )
{
	$bin=1000; $label="kb";
	if  (( $ShiftChrLenth/$bin)<10 )
	{
		$bin=1;$label="bp";
	}
}
if (exists  $HashConfi{"global"}{"LabelUnit"}) { $label= $HashConfi{"global"}{"LabelUnit"};}


my $ChrCount=$#ChrArry+1;
my $widthBetweenChr=$HashConfi{"global"}{"ChrSpacingRatio"}*$HashConfi{"ALL"}{"ChrWidth"} ;

if  ($WidthForOneChr=~s/\././) { $WidthForOneChr=sprintf ("%.1f",$WidthForOneChr+0) ;}
my $Bodyheight=$ChrCount*($WidthForOneChr+$widthBetweenChr);

if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
{
	$Bodyheight=1.5*($WidthForOneChr+$widthBetweenChr); 
}


my $CorGra=$Bodyheight*0.5/$MaxGradien;
my $Midl=20+($HashConfi{"ALL"}{"ChrWidth"}-20)*0.125;

if ($CorGra<$Midl*0.85)   {$CorGra=$Midl*0.85;}
elsif ($CorGra>$Midl*1.2) {$CorGra=$Midl*1.2;}

my $fontsize=$CorGra;

if ( $fontsize >  ($HashConfi{"global"}{"body"}*0.029))
{
	$fontsize=int($HashConfi{"global"}{"body"}*0.029);
}

if  (!exists $HashConfi{"global"}{"font-size"})
{
	$HashConfi{"global"}{"font-size"}=$fontsize;
}
else
{
	$fontsize=$HashConfi{"global"}{"font-size"};
}

if ($HashConfi{"global"}{"up"} <$fontsize*1.1)
{
	$HashConfi{"global"}{"up"}=$fontsize*1.1;
}

if (exists $HashConfi{"global"}{"Main"})
{
	$HashConfi{"global"}{"up"}+=$HashConfi{"global"}{"font-size"}*1.6;
}
my $height=$HashConfi{"global"}{"up"}+$HashConfi{"global"}{"down"}+$Bodyheight;
if ($HashConfi{"ALL"}{"NoShowGradien"}!=0   ||   $HashConfi{"ALL"}{"SizeGradienRatio"}<=0 )
{

}
else
{
	$HashConfi{"global"}{"right"}+=($NumberLevel)*$CorGra*2.4;
}

my $width=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"right"}+$HashConfi{"global"}{"body"};


my %Value2SelfCol=();
if (exists $HashConfi{"global"}{"ColorsConf"})
{
	my $ColInPut=$HashConfi{"global"}{"ColorsConf"};
	if  ( !(-e $ColInPut) )
	{
		print "\tInput Col Confi file($ColInPut) can't open,please check it\n";
		exit ;
	}
	open INT,"$ColInPut" or  die "input Col Confi file can't open $!";
	while (<INT>)
	{
		chomp;
		$_=~s/^ +//;	$_=~s/ +$//;	next if(/^#/);	next if(/^$/);
		my @bbb=split /\#\#/,$_;	$_=$bbb[0];
		$_=~s/^ +//;	$_=~s/ +$//;	next if(/^#/);	next if(/^$/);
		$_=~s/\"#/UUUU/g;
		@bbb=();	@bbb=split /\#/,$_;	$_=$bbb[0];
		$_=~s/UUUU/\"#/g;
		$_=~s/\"//g;
		$_=~s/^ +//;    $_=~s/ +$//;
		my ($Para,$InfoPara) = split(/\s*=\s*/,$_);
		$Value2SelfCol{$Para}=$InfoPara;
	}
	close INT;
}

my $Accu="%.0f";
my $log10=log(10);




if  ($PTypeLink==1)
{	

	if ( exists $HashConfi{"global"}{"ZoomRegion"})
	{
		print "Error:\tFor Type [Link] no not  accept global Para : [ZoomRegion];  please remove it  or use the new soft [https://github.com/hewm2008/NGenomeSyn] to re-plot the fig\n";
		exit ;
	}

	if (($NumberLevel>2))
	{
		print "Error:\tFor Type [Link] only accept Level:1 / 2;  please set [ ValueX = 1 ]  or [ ValueX = 2 ]\n";
		print "Error:\t[ValueX = 1] is for two Genomes; [ ValueX = 2 ] is for Three Genomes ;\n";
		print "Error:\tBut you also can use the [SetParaFor=Level3] : ShowColumn  to additional information for Background bar infomation\n";
		exit;
	}


	if ( $FileColumn[0] != 6 )
	{
		print "Error:\tFor Type [Link] InPut File1 Format must be [chr1 start1 end1 Flag chr2 start2 end2]\n";
		exit;
	}
	if ($#FileColumn>3 )
	{
		print "Error:\tFor Type [link] InPut only File1 or File2  can be accept and File1/File2 format must be [chr1 start1 end1 Flag chr2 start2 end2]\n";
		print "Error:\twe found the max File$#FileColumn+1 here, But Only Max File4 can be accept  For Type [Link] here\n ";
		exit;
	}
	elsif ($#FileColumn==1)
	{
		if ( ( $FileColumn[1] != 6 )  &&  ($NumberLevel==2) )
		{
			print "Error:\tFor Type [Link] InPut File2 ( ValueX = 2 ) Format must be [chr1 start1 end1 Flag chr2 start2 end2]\n";
			exit ;
		}
	}


	if  ( (  $HashConfi{1}{"ValueSpacingRatio"}  < 2  )  &&  ($NumberLevel==1))
	{
		print "Error:\tFor Type [link] InPut Para [ValueSpacingRatio]  for Level:1  must be >= 2 \n";
		exit;
	}
	elsif ( ($NumberLevel==2) &&  ( $HashConfi{2}{"ValueSpacingRatio"}  < 2  )  )
	{
		print "Error:\tFor Type [link] InPut Para [ValueSpacingRatio]  for Level:2  must be >= 2 \n";
		exit;
	}
	else
	{

	}

	$WidthForOneChr+=$HashConfi{$NumberLevel}{"ChrWidth"}*$HashConfi{$NumberLevel}{"ValueSpacingRatio"};	



	if (!exists $HashConfi{"global"}{"Chromosomes_order"})
	{
		my $bbb=0;if ( $NumberLevel==2 ) {$bbb=1;}
		my %temphcc=();
		foreach my $chrname( keys  %hashChr)
		{
			next if ($hashChr2File{$chrname} >$bbb);
			$temphcc{$chrname}=1;
		}
		@ChrArry=sort  keys  %temphcc;
		$ChrCount=$#ChrArry+1;
		%temphcc=();
	}



	my %ChrGenomeA=();
	my %ChrGenomeB=();
	my %ChrGenomeC=();
	my %ReverseChr=();
	foreach my $thisChr (0..$#ChrArry)
	{
		my $ThisChrName=$ChrArry[$thisChr];
		$ChrGenomeA{$ThisChrName}=$hashChr{$ThisChrName};
	}

	my $CoumnNow=3;
	my $StartCount=0;
	$HashConfi{1}{"IsNumber"}=1;
	$HashConfi{2}{"IsNumber"}=1;

	my %ChrA2ChrB=();
	my %ChrA2ChrC=();
	my %FlagValue=();

	if ($FileData[0][0][0] =~s/#/#/)
	{
		$StartCount=1;
	}


	my $FileNow=0;
	my $Level=1;
	for ( ; $StartCount<$FileRow[0]; $StartCount++)
	{
		my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
		my $ThisChrName=$FileData[$FileNow][$StartCount][0];
		next if (!exists $ChrGenomeA{$ThisChrName});

		my $StartA=$FileData[$FileNow][$StartCount][1];
		my $EndA  =$FileData[$FileNow][$StartCount][2];
		my $chrB=$FileData[$FileNow][$StartCount][4];
		my $StartB=$FileData[$FileNow][$StartCount][5];
		my $EndB=$FileData[$FileNow][$StartCount][6];
		if (!exists $ChrGenomeB{$chrB})
		{
			$ChrGenomeB{$chrB}=$EndB;
		}
		elsif ( $ChrGenomeB{$chrB} < $EndB)
		{
			$ChrGenomeB{$chrB}=$EndB;
		}
		if ( $ChrGenomeB{$chrB} < $StartB)
		{
			$ChrGenomeB{$chrB}=$StartB;
		}



		next if  ($Value eq "NA" );

		$ChrA2ChrB{$ThisChrName}{$chrB}+=($EndA-$StartA+1) ;

		if ($HashConfi{$Level}{"LogP"}!=0)
		{
			$FileData[$FileNow][$StartCount][$CoumnNow]=0-log($FileData[$FileNow][$StartCount][$CoumnNow])/$log10;
			$Value=$FileData[$FileNow][$StartCount][$CoumnNow];
		}
		$FlagValue{$Level}{$Value}++;
		$HashConfi{$Level}{"TotalValue"}++;
		if ($Value=~s/\./\./)
		{
			$Accu="%.2f";
		}
		if ( $Value =~ /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([eE][-+]?[0-9]+)?$/)
		{
		}
		elsif (!( $Value  =~ /^[+-]?\d+(\.\d+)?$/ ))
		{
			$HashConfi{1}{"IsNumber"}=0;
		}
	}

	if (exists $HashConfi{1}{"asFlag"} ) { $HashConfi{1}{"IsNumber"}=0;}

	my $One2OneAB=1;
	my $One2OneAC=1;
	my @ChrArryBB=();
	my @ChrArryCC=();
	my %BB2AA=();
	my %CC2AA=();

	foreach my $thisChr (0..$#ChrArry)
	{
		my $ThisChrName=$ChrArry[$thisChr];
		my $TemBB=$ChrA2ChrB{$ThisChrName};
		my @bbbbbb = keys %$TemBB;
		my $TYU="NA";
		for (my $uu=0 ; $uu<=$#bbbbbb ; $uu++)
		{
			if (!exists $BB2AA{$bbbbbb[$uu]} )
			{
				$BB2AA{$bbbbbb[$uu]}=$thisChr;
				if ($TYU eq "NA")
				{
					$TYU=$bbbbbb[$uu];
				}
				else
				{
					$TYU=$TYU.",$bbbbbb[$uu]";
				}
			}
			else
			{
				$One2OneAB=0;
				my $FirstNum=$BB2AA{$bbbbbb[$uu]};
				my $lengthSed=$ChrA2ChrB{$ThisChrName}{$bbbbbb[$uu]};
				my $ChrAAtmp=$ChrArry[$FirstNum];
				my $LengthFirst=$ChrA2ChrB{$ChrAAtmp}{$bbbbbb[$uu]};
				if ( ($LengthFirst*1.1) < $lengthSed )
				{
					$BB2AA{$bbbbbb[$uu]}=$thisChr;
					if ($TYU eq "NA")
					{
						$TYU=$bbbbbb[$uu];
					}
					else
					{
						$TYU=$TYU.",$bbbbbb[$uu]";
					}

					my @ccT=split(/\,/,$ChrArryBB[$FirstNum]);
					my $TYU_First="NA";
					foreach my $tmpww (0..$#ccT)
					{
						next if ( $ccT[$tmpww] eq  $bbbbbb[$uu]);
						if ($TYU_First eq "NA")
						{
							$TYU_First=$ccT[$tmpww];
						}
						else
						{
							$TYU_First=$TYU_First.",$ccT[$tmpww]";
						}
					}
					$ChrArryBB[$FirstNum]=$TYU_First;
				}
			}
		}
		$ChrArryBB[$thisChr]=$TYU;
		$ChrArryCC[$thisChr]="NA";
	}


	if ( ($#FileColumn>0)  &&  ($NumberLevel==2)  )
	{
		$StartCount=0;
		$FileNow=1;
		$Level=2;
		if  ($FileData[1][0][0] =~s/#/#/)
		{
			$StartCount=1;
		}


		for ( ; $StartCount<$FileRow[1]; $StartCount++)
		{
			my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
			next if  ($Value eq "NA");
			my $ThisChrName=$FileData[$FileNow][$StartCount][0];
			next if (!exists $ChrGenomeA{$ThisChrName});

			my $StartA=$FileData[$FileNow][$StartCount][1];
			my $EndA  =$FileData[$FileNow][$StartCount][2];
			my $chrB=$FileData[$FileNow][$StartCount][4];
			my $StartB=$FileData[$FileNow][$StartCount][5];
			my $EndB=$FileData[$FileNow][$StartCount][6];
			if (!exists $ChrGenomeC{$chrB})
			{
				$ChrGenomeC{$chrB}=$EndB;
			}
			elsif ( $ChrGenomeC{$chrB} < $EndB)
			{
				$ChrGenomeC{$chrB}=$EndB;
			}
			if ( $ChrGenomeC{$chrB} < $StartB)
			{
				$ChrGenomeC{$chrB}=$StartB;
			}


			if ($HashConfi{$Level}{"LogP"}!=0)
			{
				$FileData[$FileNow][$StartCount][$CoumnNow]=0-log($FileData[$FileNow][$StartCount][$CoumnNow])/$log10;
				$Value=$FileData[$FileNow][$StartCount][$CoumnNow];
			}
			$FlagValue{$Level}{$Value}++;
			$HashConfi{$Level}{"TotalValue"}++;
			if ($Value=~s/\./\./)
			{
				$Accu="%.2f";
			}

			$ChrA2ChrC{$ThisChrName}{$chrB}+=($EndA-$StartA+1) ;

			if ( $Value =~ /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([eE][-+]?[0-9]+)?$/)
			{

			}
			elsif (!( $Value  =~ /^[+-]?\d+(\.\d+)?$/ ))
			{
				$HashConfi{2}{"IsNumber"}=0;
			}
		}

		if (exists $HashConfi{2}{"asFlag"} ) { $HashConfi{2}{"IsNumber"}=0;}

		foreach my $thisChr (0..$#ChrArry)
		{
			my $ThisChrName=$ChrArry[$thisChr];
			my $TemCC=$ChrA2ChrC{$ThisChrName};
			my @bbbbbb = keys %$TemCC;
			my $TYU="NA";
			for (my $uu=0 ; $uu<=$#bbbbbb ; $uu++)
			{
				if (!exists $CC2AA{$bbbbbb[$uu]} )
				{
					$CC2AA{$bbbbbb[$uu]}=$thisChr;
					if ($TYU eq "NA")
					{
						$TYU=$bbbbbb[$uu];
					}
					else
					{
						$TYU=$TYU.",$bbbbbb[$uu]";
					}
				}
				else
				{
					$One2OneAC=0;
					my $FirstNumCC=$CC2AA{$bbbbbb[$uu]};
					my $lengthSed=$ChrA2ChrC{$ThisChrName}{$bbbbbb[$uu]};
					my $ChrAAtmp=$ChrArry[$FirstNumCC];
					my $LengthFirst=$ChrA2ChrC{$ChrAAtmp}{$bbbbbb[$uu]};
					if ($LengthFirst*1.1 < $lengthSed )
					{
						$BB2AA{$bbbbbb[$uu]}=$thisChr;
						if ($TYU eq "NA")
						{
							$TYU=$bbbbbb[$uu];
						}
						else
						{
							$TYU=$TYU.",$bbbbbb[$uu]";
						}
						my @ccT=split /\,/ , $ChrArryCC[$FirstNumCC];
						my $TYU_FirstCC="NA";
						foreach my $tmpww (0..$#ccT)
						{
							next if ($ccT[$tmpww] eq  $bbbbbb[$uu]);
							if ($TYU_FirstCC eq "NA")
							{
								$TYU_FirstCC=$ccT[$tmpww];
							}
							else
							{
								$TYU_FirstCC=$TYU_FirstCC.",$ccT[$tmpww]";
							}
						}
						$ChrArryCC[$FirstNumCC]=$TYU_FirstCC;
					}
				}
			}
			$ChrArryCC[$thisChr]=$TYU;
		}


	}


	my $One2One=$ChrCount;

	my $ChrMaxUnit=$ChrMax/$HashConfi{"global"}{"body"};
	my $ChrMaxUnitV2=$ChrMaxUnit;
	my $ChrMaxUnitV3=$ChrMaxUnit;
	my $XBetweenChr=$HashConfi{"global"}{"left"}*$HashConfi{"global"}{"ChrSpacingRatio"};
	my $ALLBetweenChrHH=0;
	if ( ( $One2OneAB== 1 )  &&  ( $One2OneAC==1)  &&  (  $HashConfi{"global"}{"ChrArrayDirection"} eq  "vertical")    &&  ($One2One!=1)  )
	{
		my $MaxCunt=0;
		foreach my $thisChr (0..$#ChrArry)
		{
			next if  ($ChrArryCC[$thisChr] eq "NA");
			my @ccT=split /\,/ , $ChrArryCC[$thisChr];
			my $Cunt=$#ccT;
			my $length=0;
			foreach my $tmpww (0..$Cunt)
			{
				$length+=$ChrGenomeC{$ccT[$tmpww]};
			}
			my $UnitC=$length/$HashConfi{"global"}{"body"};
			if ($MaxCunt> $Cunt) {$MaxCunt=$Cunt ;}
			if ($UnitC > $ChrMaxUnit) {$ChrMaxUnit=$UnitC;}
		}

		foreach my $thisChr (0..$#ChrArry)
		{
			next if ($ChrArryBB[$thisChr] eq "NA");
			my @ccT=split /\,/ , $ChrArryBB[$thisChr];
			my $Cunt=$#ccT;
			my $length=0;
			foreach my $tmpww (0..$Cunt)
			{
				$length+=$ChrGenomeB{$ccT[$tmpww]};
			}
			my $UnitC=$length/$HashConfi{"global"}{"body"};
			if ($MaxCunt> $Cunt) {$MaxCunt=$Cunt ;}
			if ($UnitC > $ChrMaxUnit) {$ChrMaxUnit=$UnitC;}
		}
		$ALLBetweenChrHH=($MaxCunt*$XBetweenChr);
		$width+=$ALLBetweenChrHH;
		$HashConfi{"global"}{"body"}+=$ALLBetweenChrHH;
	}
	else
	{
		$One2One=1;

		my $length=0;
		my $CuntAA=-1;

		my $ALLONE_CC="NA";
		my %FlagTmpAA=();
		foreach my $thisChr (0..$#ChrArry)
		{
			next if  ($ChrArryCC[$thisChr] eq "NA");
			my @ccT=split /\,/ , $ChrArryCC[$thisChr];
			foreach my $tmpww (0..$#ccT)
			{
				next if (exists $FlagTmpAA{$ccT[$tmpww]});
				$FlagTmpAA{$ccT[$tmpww]}=1;
				$length+=$ChrGenomeC{$ccT[$tmpww]};
				$CuntAA++;
				if ($ALLONE_CC eq "NA")
				{
					$ALLONE_CC =$ccT[$tmpww];
				}
				else
				{
					$ALLONE_CC =$ALLONE_CC.",$ccT[$tmpww]";
				}
			}
		}
		my $UnitC=$length/($HashConfi{"global"}{"body"});
		if ($UnitC > $ChrMaxUnit) {$ChrMaxUnit=$UnitC;}
		if (exists $HashConfi{"2"}{"Chromosomes_order"}){$ALLONE_CC=$HashConfi{"2"}{"Chromosomes_order"};}

		$length=0;
		my $CuntBB=-1;
		my $ALLONE_BB="NA";

		%FlagTmpAA=();
		foreach my $thisChr (0..$#ChrArry)
		{
			next if ($ChrArryBB[$thisChr] eq "NA");
			my @ccT=split /\,/ , $ChrArryBB[$thisChr];
			foreach my $tmpww (0..$#ccT)			
			{
				next if (exists $FlagTmpAA{$ccT[$tmpww]});
				$FlagTmpAA{$ccT[$tmpww]}=1;
				$length+=$ChrGenomeB{$ccT[$tmpww]};
				$CuntBB++;
				if ($ALLONE_BB eq "NA")
				{
					$ALLONE_BB =$ccT[$tmpww];
				}
				else
				{
					$ALLONE_BB =$ALLONE_BB.",$ccT[$tmpww]";
				}

			}
		}

		$UnitC=$length/($HashConfi{"global"}{"body"});
		if ($UnitC > $ChrMaxUnit) {$ChrMaxUnit=$UnitC;}
		if (exists $HashConfi{"1"}{"Chromosomes_order"}){$ALLONE_BB=$HashConfi{"1"}{"Chromosomes_order"};}

		$length=0;
		my $CuntCC=-1;
		my $ALLONE_AA="NA";
		%FlagTmpAA=();
		foreach my $thisChr (0..$#ChrArry)
		{
			my $ThisChrName=$ChrArry[$thisChr];
			next if (exists $FlagTmpAA{$ThisChrName});
			$FlagTmpAA{$ThisChrName}=1;
			$length+=$ChrGenomeA{$ThisChrName};
			$CuntCC++;
			if ($ALLONE_AA eq "NA")
			{
				$ALLONE_AA = $ThisChrName;
			}
			else
			{
				$ALLONE_AA =$ALLONE_AA.",$ThisChrName";
			}
		}
		$UnitC=$length/($HashConfi{"global"}{"body"});
		if ($UnitC > $ChrMaxUnit) {$ChrMaxUnit=$UnitC;}

		$ChrArry[0]=$ALLONE_AA;
		$ChrArryBB[0]=$ALLONE_BB;
		$ChrArryCC[0]=$ALLONE_CC;
		my $Cunt=0; 
		if ($CuntAA>$Cunt){$Cunt=$CuntAA;}
		if ($CuntBB>$Cunt){$Cunt=$CuntBB;}
		if ($CuntCC>$Cunt){$Cunt=$CuntCC;}
		$ALLBetweenChrHH=(($Cunt+1)*$XBetweenChr);
		$width+=$ALLBetweenChrHH;
		$HashConfi{"global"}{"body"}+=$ALLBetweenChrHH;
	}


	$ChrMaxUnitV2=$ChrMaxUnit;
	$ChrMaxUnitV3=$ChrMaxUnit;


	$WidthForOneChr+=$HashConfi{ALL}{"ChrWidth"};
	if ($WidthForOneChr=~s/\././) { $WidthForOneChr=sprintf ("%.1f",$WidthForOneChr+0);}
	$Bodyheight=($One2One+0.5)*($WidthForOneChr+$widthBetweenChr);
	$height=$HashConfi{"global"}{"up"}+$HashConfi{"global"}{"down"}+$Bodyheight;

	print STDERR "Start draw... SVG info: ChrNumber :$ChrCount Level Number is $NumberLevel, SVG (width,height) = ($width,$height)\n";

	$ChrCount--;
	my  $StarGradienRatio=0.5;
	my  $Y2=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{"ALL"}{"SizeGradienRatio"}*$CorGra*($MaxGradien+1);
	if ($Y2 > $height )
	{
		$height=$Y2*1.10;
		$StarGradienRatio=0.3;
	}

	my $CanvasHeight=$height;
	my $CanvasWidth=$width;
	if ((exists $HashConfi{"global"}{"CanvasHeightRitao"})  &&  ($HashConfi{"global"}{"CanvasHeightRitao"}>0.1))
	{
		$CanvasHeight=$CanvasHeight*$HashConfi{"global"}{"CanvasHeightRitao"};
	}

	if ((exists $HashConfi{"global"}{"CanvasWidthRitao"})  &&  ($HashConfi{"global"}{"CanvasWidthRitao"}>0.1))
	{
		$CanvasWidth=$CanvasWidth*$HashConfi{"global"}{"CanvasWidthRitao"};
	}

	my $svg = SVG->new('width',$CanvasWidth,'height',$CanvasHeight);

	my $ChrMax=$HashConfi{"global"}{"body"}*$ChrMaxUnit;
	my $XX2=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+$HashConfi{"global"}{"strokewidth"};
	my $YY3=$HashConfi{"global"}{"up"}+$HashConfi{"global"}{"ShiftXaxisY"};
	my $YY1=$YY3-$fontsize*0.75;
	my $YY2=$YY1+$fontsize*0.25;
	my $XX1;
	my $ScaleNum=$HashConfi{"global"}{"ScaleNum"};
	my $ScaleNumChrMax=$ScaleNum;
	my $BinXX=$HashConfi{"global"}{"body"}/$ScaleNum;

	if  (exists $HashConfi{"global"}{"ScaleUnit"} )
	{
		$ScaleNumChrMax=$ChrMax*1.0/$HashConfi{"global"}{"ScaleUnit"};
		if ($ScaleNumChrMax  < 2   ||  $ScaleNumChrMax >100 )
		{
			print "Pare [ScaleUnit] set is too small or too big, we use ScaleNum= $ScaleNum \n";
			$ScaleNumChrMax=$ScaleNum;
		}
		$BinXX=($HashConfi{"global"}{"body"}+$ALLBetweenChrHH)/$ScaleNumChrMax;
		$ScaleNum=int($ScaleNumChrMax);
	}

	foreach my $k (0..$ScaleNum)
	{
		$XX1=$HashConfi{"global"}{"left"}+$k*$BinXX;

		my $VV=int($RegionStart/$bin+$ChrMax*$k/($bin*$ScaleNumChrMax));
		if ($label eq "kb")		{			$VV= sprintf ("%.1f",($RegionStart/$bin+$ChrMax*$k/($bin*$ScaleNumChrMax))*1.0);}
		if ( !exists $HashConfi{"global"}{"RotateAxisText"})
		{
			$svg->text('text-anchor','middle','x',$XX1,'y',$YY1-0.60*$fontsize,'-cdata',"$VV $label",'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize);
		}
		else
		{
			my $XXRR= $XX1;
			my $YYRR= $YY1;
			my $rotate=$HashConfi{"global"}{"RotateAxisText"};
			$svg->text('text-anchor','start','x',$XX1,'y',$YYRR,'-cdata',"$VV $label",'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize,'transform',"rotate($rotate,$XXRR,$YYRR)");
		}
		$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX1,'y2',$YY3,'stroke','black','stroke-width',$HashConfi{"global"}{"strokewidth"},'fill',$HashConfi{"global"}{"fill"}); #X
	}

	if (exists $HashConfi{"global"}{"Main"})
	{
		my $colr="blue";
		my $MainRatioFontSize=1;
		my $ShiftMainX=0;
		my $ShiftMainY=0;

		if (exists $HashConfi{"global"}{"MainCol"})	{	$colr=$HashConfi{"global"}{"MainCol"};	}
		if (exists $HashConfi{"global"}{"MainRatioFontSize"})	{	$MainRatioFontSize=$HashConfi{"global"}{"MainRatioFontSize"};	}
		if (exists $HashConfi{"global"}{"ShiftMainX"})	{	$ShiftMainX=$HashConfi{"global"}{"ShiftMainX"};	}
		if (exists $HashConfi{"global"}{"ShiftMainY"})	{	$ShiftMainY=$HashConfi{"global"}{"ShiftMainY"};	}

		my $MainXX1=($HashConfi{"global"}{"left"}+$XX1)/2+$ShiftMainX;
		my $MainYY1=($YY1-2*$fontsize)+$ShiftMainY;
		my $Mainfortsize=$fontsize*1.2*$MainRatioFontSize;
		$svg->text('text-anchor','middle','x',$MainXX1,'y',$MainYY1,'-cdata',$HashConfi{"global"}{"Main"},'font-family',$HashConfi{"global"}{"font-family"},'font-size',$Mainfortsize,'stroke',$colr,'fill',$colr);

	}

	$XX1=$HashConfi{"global"}{"left"}-$HashConfi{"global"}{"strokewidth"};
	my $path = $svg->get_path(
		x => [$XX1, $XX1, $XX2,$XX2],
		y => [$YY1, $YY2, $YY2,$YY1],
		-type => 'polygon');

	if  ( $ScaleNum   > 0)
	{
		$svg->polygon(
			%$path,
			style => {
				'fill'           => $HashConfi{"global"}{"fill"},
				'stroke'         => 'black',
				'stroke-width'   =>  0,
				'stroke-opacity' =>  $HashConfi{"ALL"}{"stroke-opacity"},
				'fill-opacity'   =>  $HashConfi{"ALL"}{"fill-opacity"},
			},
		);
	}

	my $TwoChrHH=$HashConfi{1}{"ChrWidth"}*$HashConfi{1}{"ValueSpacingRatio"};
	my $TwoChrHHV2=$TwoChrHH;
	my %hashYY1=();	my %hashYY2=();	my %hashXX1=();

	if ($NumberLevel==1)
	{
		for ( my $thisChr=0 ; $thisChr < $One2One ; $thisChr++ )
		{
			my $ThisChrName=$ChrArry[$thisChr];
			my $Level=1;
			next  if ($ThisChrName eq "NA");
			my $Y1=$HashConfi{"global"}{"up"}+$thisChr*($WidthForOneChr+$widthBetweenChr)+$widthBetweenChr;
			$YY1=$Y1;
			$YY2=$YY1+$HashConfi{ALL}{"ChrWidth"};
			my $Mid=($YY1+$YY2)/2;
			my $AA=$HashConfi{ALL}{"BGWidthRatio"}*$HashConfi{ALL}{"ChrWidth"}/2;
			$YY1=$Mid-$AA;
			$YY2=$Mid+$AA;
			my $YY3=$YY2+$TwoChrHH;
			my $YY4=$YY3+$HashConfi{$Level}{"ChrWidth"};
			$Mid=($YY3+$YY4)/2;
			$AA=$HashConfi{$Level}{"BGWidthRatio"}*$HashConfi{$Level}{"ChrWidth"}/2;
			$YY3=$Mid-$AA;
			$YY4=$Mid+$AA;
			my @ChrNameAA=split /\,/,$ThisChrName;
			$XX1=$HashConfi{"global"}{"left"};
			for (my $YYUU=0 ; $YYUU<=$#ChrNameAA  ; $YYUU++)
			{
				my $AAAChrName=$ChrNameAA[$YYUU];
				$XX2= ($ChrGenomeA{$AAAChrName})/($ChrMaxUnit)+$XX1;
				$hashYY1{$AAAChrName}{0}=$YY1;
				$hashYY2{$AAAChrName}{0}=$YY2;
				$hashXX1{$AAAChrName}{0}=$XX1;
				my $BGCorThisChr=$HashConfi{ALL}{"crBG"} ;
				if (exists 	$Value2SelfCol{$AAAChrName}) {$BGCorThisChr=$Value2SelfCol{$AAAChrName};}
				if ($HashConfi{ALL}{"BGChrEndCurve"}==0)
				{
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => $BGCorThisChr,
							'stroke'         => $HashConfi{ALL}{"crStrokeBG"},
							'stroke-width'   => $HashConfi{ALL}{"strokeWidthBG"},
							'stroke-opacity' => $HashConfi{ALL}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{ALL}{"fill-opacity"},
						},
					);
				}
				else
				{
					my $EndCurveRadian=3;
					if (exists $HashConfi{ALL}{"EndCurveRadian"})
					{
						if ($HashConfi{ALL}{"EndCurveRadian"}>=2)
						{
							$EndCurveRadian=$HashConfi{ALL}{"EndCurveRadian"};
						}
						else
						{
							print "Leve ALL Para EndCurveRadian must >=2 ,so we chang it to be 2\n";
							$EndCurveRadian=2;$HashConfi{ALL}{"EndCurveRadian"}=2;
						}
					}

					my $HH=($YY2-$YY1)/$EndCurveRadian;
					if (($HH*2)>abs($XX2-$XX1)) {$HH=abs($XX2-$XX1)*0.5;}
					my $HM=($YY2-$YY1)-$HH-$HH;
					my $P1_X=$XX1+$HH;  my $P1_Y=$YY1;
					my $P1Q_X=$XX1;  my $P1Q_Y=$YY1;
					my $P2_X=$XX1;  my $P2_Y=$YY1+$HH;
					my $P3_X=$XX1;  my $P3_Y=$P2_Y+$HM;
					my $P2Q_X=$XX1;  my $P2Q_Y=$YY2;
					my $P4_X=$XX1+$HH;  my $P4_Y=$YY2;
					my $P3Q_X=$XX2;  my $P3Q_Y=$YY2;
					my $P6_X=$XX2-$HH;  my $P6_Y=$YY2;
					my $P7_X=$XX2;  my $P7_Y=$YY2-$HH;
					my $P8_X=$XX2;  my $P8_Y=$P7_Y-$HM;
					my $P4Q_X=$XX2;  my $P4Q_Y=$YY1;
					my $P9_X=$XX2-$HH;  my $P9_Y=$YY1;
					$svg->path(
						'd'=>"M$P1_X $P1_Y Q $P1Q_X $P1Q_Y , $P2_X $P2_Y L  $P3_X $P3_Y  Q $P2Q_X $P2Q_Y , $P4_X $P4_Y   L $P6_X $P6_Y  Q $P3Q_X $P3Q_Y , $P7_X $P7_Y  L $P8_X $P8_Y Q $P4Q_X $P4Q_Y ,$P9_X $P9_Y  Z",
						style => {
							'fill'           =>  $BGCorThisChr,
							'stroke'         =>  $HashConfi{ALL}{"crStrokeBG"},
							'stroke-width'   =>  $HashConfi{ALL}{"strokeWidthBG"},
							'stroke-opacity' =>  $HashConfi{ALL}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{ALL}{"fill-opacity"},
						},
					);
				}
				my $ChrNameRatio=$HashConfi{"ALL"}{"ChrNameRatio"}; $ChrNameRatio||=1;
				my $AAAfontsize=$fontsize*$ChrNameRatio;
				my $XX3=$XX1-length($AAAChrName)*$AAAfontsize*$chrNameShiftRitao+$HashConfi{"ALL"}{"ShiftChrNameX"};
				my $TextYY=($YY1+$YY2)*0.5+$HashConfi{"ALL"}{"ShiftChrNameY"}+($AAAfontsize*0.5);
				if ($XX3<0) {$XX3=0;}
				if ($HashConfi{"global"}{"RotateChrName"}==0)
				{
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$AAAChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$AAAfontsize);
				}
				else
				{
					my $XX3=$XX1-$AAAfontsize*1.1+$HashConfi{"ALL"}{"ShiftChrNameX"};
					my $rotate=$HashConfi{"global"}{"RotateChrName"};					
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$AAAChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$AAAfontsize,'transform',"rotate($rotate,$XX3,$TextYY)");
				}
				$XX1=$XX2+$XBetweenChr;
			}


			my @ChrNameBB=split /\,/,$ChrArryBB[$thisChr];
			$XX1=$HashConfi{"global"}{"left"};
			if  (exists $HashConfi{$Level}{"ChrLenUnitRatio"}) {$ChrMaxUnitV2=$ChrMaxUnit/$HashConfi{$Level}{"ChrLenUnitRatio"};}
			for (my $YYUU=0 ; $YYUU<=$#ChrNameBB  ; $YYUU++)
			{
				my $BBBChrName=$ChrNameBB[$YYUU];
				next if ($BBBChrName eq "NA");
				$XX2=($ChrGenomeB{$BBBChrName})/($ChrMaxUnitV2)+$XX1;
				$hashYY1{$BBBChrName}{$Level}=$YY3;
				$hashYY2{$BBBChrName}{$Level}=$YY4;
				$hashXX1{$BBBChrName}{$Level}=$XX1;
				my $BGCorThisChr=$HashConfi{$Level}{"crBG"} ;
				if (exists 	$Value2SelfCol{$BBBChrName}) {$BGCorThisChr=$Value2SelfCol{$BBBChrName};}


				if ($HashConfi{$Level}{"BGChrEndCurve"}==0)
				{

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY3, $YY4, $YY4,$YY3],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => $BGCorThisChr,
							'stroke'         => $HashConfi{$Level}{"crStrokeBG"},
							'stroke-width'   => $HashConfi{$Level}{"strokeWidthBG"},
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}
				else
				{
					my $EndCurveRadian=3;
					if (exists $HashConfi{$Level}{"EndCurveRadian"})
					{
						if ($HashConfi{$Level}{"EndCurveRadian"}>=2)
						{
							$EndCurveRadian=$HashConfi{$Level}{"EndCurveRadian"};
						}
						else
						{
							print "Leve $Level Para EndCurveRadian must >=2 ,so we chang it to be 2\n";
							$EndCurveRadian=2;$HashConfi{$Level}{"EndCurveRadian"}=2;
						}

					}
					my $HH=($YY4-$YY3)/$EndCurveRadian;
					if (($HH*2)>abs($XX2-$XX1)) {$HH=abs($XX2-$XX1)*0.5;}
					my $HM=($YY4-$YY3)-$HH-$HH;
					my $P1_X=$XX1+$HH;  my $P1_Y=$YY3;
					my $P1Q_X=$XX1;  my $P1Q_Y=$YY3;
					my $P2_X=$XX1;  my $P2_Y=$YY3+$HH;
					my $P3_X=$XX1;  my $P3_Y=$P2_Y+$HM;
					my $P2Q_X=$XX1;  my $P2Q_Y=$YY4;
					my $P4_X=$XX1+$HH;  my $P4_Y=$YY4;
					my $P3Q_X=$XX2;  my $P3Q_Y=$YY4;
					my $P6_X=$XX2-$HH;  my $P6_Y=$YY4;
					my $P7_X=$XX2;  my $P7_Y=$YY4-$HH;
					my $P8_X=$XX2;  my $P8_Y=$P7_Y-$HM;
					my $P4Q_X=$XX2;  my $P4Q_Y=$YY3;
					my $P9_X=$XX2-$HH;  my $P9_Y=$YY3;
					$svg->path(
						'd'=>"M$P1_X $P1_Y Q $P1Q_X $P1Q_Y , $P2_X $P2_Y L  $P3_X $P3_Y  Q $P2Q_X $P2Q_Y , $P4_X $P4_Y   L $P6_X $P6_Y  Q $P3Q_X $P3Q_Y , $P7_X $P7_Y  L $P8_X $P8_Y Q $P4Q_X $P4Q_Y ,$P9_X $P9_Y  Z",
						style => {
							'fill'           =>  $BGCorThisChr,
							'stroke'         =>  $HashConfi{$Level}{"crStrokeBG"},
							'stroke-width'   =>  $HashConfi{$Level}{"strokeWidthBG"},
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);


				}

				my $ChrNameRatio=$HashConfi{$Level}{"ChrNameRatio"}; $ChrNameRatio||=1;
				my $BBBfontsize=$fontsize*$ChrNameRatio;

				my $XX3=$XX1-length($BBBChrName)*$BBBfontsize*$chrNameShiftRitao+$HashConfi{$Level}{"ShiftChrNameX"};
				my $TextYY=($YY3+$YY4)*0.5+$HashConfi{$Level}{"ShiftChrNameY"}+($BBBfontsize*0.5);
				if ($XX3<0) {$XX3=0;}
				if ($HashConfi{"global"}{"RotateChrName"}==0)
				{
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$BBBChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$BBBfontsize);
				}
				else
				{
					my $XX3=$XX1-$BBBfontsize*1.1+$HashConfi{$Level}{"ShiftChrNameX"};
					my $rotate=$HashConfi{"global"}{"RotateChrName"};
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$BBBChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$BBBfontsize,'transform',"rotate($rotate,$XX3,$TextYY)");
				}
				$XX1=$XX2+$XBetweenChr;
			}
		}
	}
	else
	{
		$TwoChrHHV2=$HashConfi{2}{"ChrWidth"}*$HashConfi{2}{"ValueSpacingRatio"};
		for ( my $thisChr=0 ;  $thisChr < $One2One ; $thisChr++ )
		{
			my $ThisChrName=$ChrArry[$thisChr];
			my $Level=1;
			my $LevelV2=2;
			next  if ($ThisChrName eq "NA");
			my $Y1=$HashConfi{"global"}{"up"}+$thisChr*($WidthForOneChr+$widthBetweenChr)+$widthBetweenChr;
			$YY1=$Y1;			
			$YY2=$YY1+$HashConfi{$Level}{"ChrWidth"};

			my $Mid=($YY1+$YY2)/2;
			my $AA=$HashConfi{$Level}{"BGWidthRatio"}*$HashConfi{$Level}{"ChrWidth"}/2;
			$YY1=$Mid-$AA;
			$YY2=$Mid+$AA;
			my $YY3=$YY2+$TwoChrHH;
			my $YY4=$YY3+$HashConfi{ALL}{"ChrWidth"};
			$Mid=($YY3+$YY4)/2;
			$AA=$HashConfi{ALL}{"BGWidthRatio"}*$HashConfi{ALL}{"ChrWidth"}/2;
			$YY3=$Mid-$AA;
			$YY4=$Mid+$AA;

			my $YY5=$YY4+$TwoChrHHV2;
			my $YY6=$YY5+$HashConfi{$LevelV2}{"ChrWidth"};
			$AA=$HashConfi{$LevelV2}{"BGWidthRatio"}*$HashConfi{$LevelV2}{"ChrWidth"}/2;
			$Mid=($YY5+$YY6)/2;
			$YY5=$Mid-$AA;
			$YY6=$Mid+$AA;


			my @ChrNameAA=split /\,/,$ThisChrName ;
			$XX1=$HashConfi{"global"}{"left"};
			for (my $YYUU=0 ; $YYUU<=$#ChrNameAA  ; $YYUU++)
			{
				my $AAAChrName=$ChrNameAA[$YYUU];
				$XX2= ($ChrGenomeA{$AAAChrName})/($ChrMaxUnit)+$XX1;
				$hashYY1{$AAAChrName}{0}=$YY3;
				$hashYY2{$AAAChrName}{0}=$YY4;
				$hashXX1{$AAAChrName}{0}=$XX1;
				my $BGCorThisChr=$HashConfi{ALL}{"crBG"} ;
				if (exists 	$Value2SelfCol{$AAAChrName}) {$BGCorThisChr=$Value2SelfCol{$AAAChrName};}
				if ($HashConfi{"ALL"}{"BGChrEndCurve"}==0)
				{
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY3, $YY4, $YY4,$YY3],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => $BGCorThisChr,
							'stroke'         => $HashConfi{ALL}{"crStrokeBG"},
							'stroke-width'   => $HashConfi{ALL}{"strokeWidthBG"},
							'stroke-opacity' => $HashConfi{ALL}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{ALL}{"fill-opacity"},
						},
					);
				}
				else				
				{
					my $EndCurveRadian=3;
					if (exists $HashConfi{ALL}{"EndCurveRadian"})
					{
						if ($HashConfi{ALL}{"EndCurveRadian"}>=2)
						{
							$EndCurveRadian=$HashConfi{ALL}{"EndCurveRadian"};
						}
						else
						{
							print "Leve ALL Para EndCurveRadian must >=2 ,so we chang it to be 2\n";
							$EndCurveRadian=2;$HashConfi{ALL}{"EndCurveRadian"}=2;
						}

					}
					my $HH=($YY4-$YY3)/$EndCurveRadian;
					if (($HH*2)>abs($XX2-$XX1)) {$HH=abs($XX2-$XX1)*0.5;}
					my $HM=($YY4-$YY3)-$HH-$HH;
					my $P1_X=$XX1+$HH;  my $P1_Y=$YY3;
					my $P1Q_X=$XX1;  my $P1Q_Y=$YY3;
					my $P2_X=$XX1;  my $P2_Y=$YY3+$HH;
					my $P3_X=$XX1;  my $P3_Y=$P2_Y+$HM;
					my $P2Q_X=$XX1;  my $P2Q_Y=$YY4;
					my $P4_X=$XX1+$HH;  my $P4_Y=$YY4;
					my $P3Q_X=$XX2;  my $P3Q_Y=$YY4;
					my $P6_X=$XX2-$HH;  my $P6_Y=$YY4;
					my $P7_X=$XX2;  my $P7_Y=$YY4-$HH;
					my $P8_X=$XX2;  my $P8_Y=$P7_Y-$HM;
					my $P4Q_X=$XX2;  my $P4Q_Y=$YY3;
					my $P9_X=$XX2-$HH;  my $P9_Y=$YY3;
					$svg->path(
						'd'=>"M$P1_X $P1_Y Q $P1Q_X $P1Q_Y , $P2_X $P2_Y L  $P3_X $P3_Y  Q $P2Q_X $P2Q_Y , $P4_X $P4_Y   L $P6_X $P6_Y  Q $P3Q_X $P3Q_Y , $P7_X $P7_Y  L $P8_X $P8_Y Q $P4Q_X $P4Q_Y ,$P9_X $P9_Y  Z",
						style => {
							'fill'           =>  $BGCorThisChr,
							'stroke'         =>  $HashConfi{ALL}{"crStrokeBG"},
							'stroke-width'   =>  $HashConfi{ALL}{"strokeWidthBG"},
							'stroke-opacity' =>  $HashConfi{ALL}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{ALL}{"fill-opacity"},
						},
					);



				}

				my $ChrNameRatio=$HashConfi{"ALL"}{"ChrNameRatio"}; $ChrNameRatio||=1;
				my $AAAfontsize=$fontsize*$ChrNameRatio;
				my $XX3=$XX1-length($AAAChrName)*$AAAfontsize*$chrNameShiftRitao+$HashConfi{"ALL"}{"ShiftChrNameX"};
				if ($XX3<0) {$XX3=0;}
				my $TextYY=($YY3+$YY4)*0.5+$HashConfi{"ALL"}{"ShiftChrNameY"}+($AAAfontsize*0.5);
				if ($HashConfi{"global"}{"RotateChrName"}==0)
				{
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$AAAChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$AAAfontsize);
				}
				else
				{
					my $XX3=$XX1-$AAAfontsize*1.1+$HashConfi{"ALL"}{"ShiftChrNameX"};
					my $rotate=$HashConfi{"global"}{"RotateChrName"};
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$AAAChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$AAAfontsize,'transform',"rotate($rotate,$XX3,$TextYY)");
				}

				$XX1=$XX2+$XBetweenChr;
			}


			my @ChrNameBB=split /\,/,$ChrArryBB[$thisChr];
			$XX1=$HashConfi{"global"}{"left"};
			if  (exists $HashConfi{$Level}{"ChrLenUnitRatio"}) {$ChrMaxUnitV2=$ChrMaxUnitV2/$HashConfi{$Level}{"ChrLenUnitRatio"};}
			for (my $YYUU=0 ; $YYUU<=$#ChrNameBB  ; $YYUU++)
			{
				my $BBBChrName=$ChrNameBB[$YYUU];
				next if ($BBBChrName eq "NA");
				$XX2= ($ChrGenomeB{$BBBChrName})/($ChrMaxUnitV2)+$XX1;
				$hashYY1{$BBBChrName}{$Level}=$YY1;
				$hashYY2{$BBBChrName}{$Level}=$YY2;
				$hashXX1{$BBBChrName}{$Level}=$XX1;
				my $BGCorThisChr=$HashConfi{$Level}{"crBG"} ;
				if (exists 	$Value2SelfCol{$BBBChrName}) {$BGCorThisChr=$Value2SelfCol{$BBBChrName};}
				if ($HashConfi{$Level}{"BGChrEndCurve"}==0)
				{
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => $BGCorThisChr,
							'stroke'         => $HashConfi{$Level}{"crStrokeBG"},
							'stroke-width'   => $HashConfi{$Level}{"strokeWidthBG"},
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}
				else
				{
					my $EndCurveRadian=3;
					if (exists $HashConfi{$Level}{"EndCurveRadian"})
					{
						if ($HashConfi{$Level}{"EndCurveRadian"}>=2)
						{
							$EndCurveRadian=$HashConfi{$Level}{"EndCurveRadian"};
						}
						else
						{
							print "Leve $Level Para EndCurveRadian must >=2 ,so we chang it to be 2\n";
							$EndCurveRadian=2;$HashConfi{$Level}{"EndCurveRadian"}=2;
						}

					}
					my $HH=($YY2-$YY1)/$EndCurveRadian;
					if (($HH*2)>abs($XX2-$XX1)) {$HH=abs($XX2-$XX1)*0.5;}
					my $HM=($YY2-$YY1)-$HH-$HH;
					my $P1_X=$XX1+$HH;  my $P1_Y=$YY1;
					my $P1Q_X=$XX1;  my $P1Q_Y=$YY1;
					my $P2_X=$XX1;  my $P2_Y=$YY1+$HH;
					my $P3_X=$XX1;  my $P3_Y=$P2_Y+$HM;
					my $P2Q_X=$XX1;  my $P2Q_Y=$YY2;
					my $P4_X=$XX1+$HH;  my $P4_Y=$YY2;
					my $P3Q_X=$XX2;  my $P3Q_Y=$YY2;
					my $P6_X=$XX2-$HH;  my $P6_Y=$YY2;
					my $P7_X=$XX2;  my $P7_Y=$YY2-$HH;
					my $P8_X=$XX2;  my $P8_Y=$P7_Y-$HM;
					my $P4Q_X=$XX2;  my $P4Q_Y=$YY1;
					my $P9_X=$XX2-$HH;  my $P9_Y=$YY1;
					$svg->path(
						'd'=>"M$P1_X $P1_Y Q $P1Q_X $P1Q_Y , $P2_X $P2_Y L  $P3_X $P3_Y  Q $P2Q_X $P2Q_Y , $P4_X $P4_Y   L $P6_X $P6_Y  Q $P3Q_X $P3Q_Y , $P7_X $P7_Y  L $P8_X $P8_Y Q $P4Q_X $P4Q_Y ,$P9_X $P9_Y  Z",
						style => {
							'fill'           =>  $BGCorThisChr,
							'stroke'         =>  $HashConfi{$Level}{"crStrokeBG"},
							'stroke-width'   =>  $HashConfi{$Level}{"strokeWidthBG"},
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);


				}

				my $ChrNameRatio=$HashConfi{$Level}{"ChrNameRatio"}; $ChrNameRatio||=1;
				my $BBBfontsize=$fontsize*$ChrNameRatio;

				my $XX3=$XX1-length($BBBChrName)*$BBBfontsize*$chrNameShiftRitao+$HashConfi{$Level}{"ShiftChrNameX"};
				if ($XX3<0) {$XX3=0;}
				my $TextYY=($YY1+$YY2)*0.5+$HashConfi{$Level}{"ShiftChrNameY"}+($BBBfontsize*0.5);
				if ($HashConfi{"global"}{"RotateChrName"}==0)
				{
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$BBBChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$BBBfontsize);
				}
				else
				{
					my $XX3=$XX1-$BBBfontsize*1.1+$HashConfi{$Level}{"ShiftChrNameX"};
					my $rotate=$HashConfi{"global"}{"RotateChrName"};
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$BBBChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$BBBfontsize,'transform',"rotate($rotate,$XX3,$TextYY)");
				}
				$XX1=$XX2+$XBetweenChr;

			}




			my @ChrNameCC=split /\,/,$ChrArryCC[$thisChr];
			$XX1=$HashConfi{"global"}{"left"};
			if  (exists $HashConfi{$Level}{"ChrLenUnitRatio"}) {$ChrMaxUnitV3=$ChrMaxUnit/$HashConfi{$Level}{"ChrLenUnitRatio"};}

			for (my $YYUU=0 ; $YYUU<=$#ChrNameCC  ; $YYUU++)
			{
				my $CCCChrName=$ChrNameCC[$YYUU];
				next if ($CCCChrName eq "NA");
				$XX2= ($ChrGenomeC{$CCCChrName})/($ChrMaxUnitV3)+$XX1;
				$hashYY1{$CCCChrName}{$LevelV2}=$YY5;
				$hashYY2{$CCCChrName}{$LevelV2}=$YY6;
				$hashXX1{$CCCChrName}{$LevelV2}=$XX1;
				my $BGCorThisChr=$HashConfi{$LevelV2}{"crBG"} ;
				if (exists 	$Value2SelfCol{$CCCChrName}) {$BGCorThisChr=$Value2SelfCol{$CCCChrName};}
				if ($HashConfi{$LevelV2}{"BGChrEndCurve"}==0)
				{

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY5, $YY6, $YY6,$YY5],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => $BGCorThisChr,
							'stroke'         => $HashConfi{$LevelV2}{"crStrokeBG"},
							'stroke-width'   => $HashConfi{$LevelV2}{"strokeWidthBG"},
							'stroke-opacity' => $HashConfi{$LevelV2}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{$LevelV2}{"fill-opacity"},
						},
					);
				}
				else
				{
					my $EndCurveRadian=3;
					if (exists $HashConfi{$LevelV2}{"EndCurveRadian"})
					{
						if ($HashConfi{$LevelV2}{"EndCurveRadian"}>=2)
						{
							$EndCurveRadian=$HashConfi{$LevelV2}{"EndCurveRadian"};
						}
						else
						{
							print "Leve $LevelV2 Para EndCurveRadian must >=2 ,so we chang it to be 2\n";
							$EndCurveRadian=2;$HashConfi{$LevelV2}{"EndCurveRadian"}=2;
						}

					}
					my $HH=($YY6-$YY5)/$EndCurveRadian;
					if (($HH*2)>abs($XX2-$XX1)) {$HH=abs($XX2-$XX1)*0.5;}
					my $HM=($YY6-$YY5)-$HH-$HH;
					my $P1_X=$XX1+$HH;  my $P1_Y=$YY5;
					my $P1Q_X=$XX1;  my $P1Q_Y=$YY5;
					my $P2_X=$XX1;  my $P2_Y=$YY5+$HH;
					my $P3_X=$XX1;  my $P3_Y=$P2_Y+$HM;
					my $P2Q_X=$XX1;  my $P2Q_Y=$YY6;
					my $P4_X=$XX1+$HH;  my $P4_Y=$YY6;
					my $P3Q_X=$XX2;  my $P3Q_Y=$YY6;
					my $P6_X=$XX2-$HH;  my $P6_Y=$YY6;
					my $P7_X=$XX2;  my $P7_Y=$YY6-$HH;
					my $P8_X=$XX2;  my $P8_Y=$P7_Y-$HM;
					my $P4Q_X=$XX2;  my $P4Q_Y=$YY5;
					my $P9_X=$XX2-$HH;  my $P9_Y=$YY5;
					$svg->path(
						'd'=>"M$P1_X $P1_Y Q $P1Q_X $P1Q_Y , $P2_X $P2_Y L  $P3_X $P3_Y  Q $P2Q_X $P2Q_Y , $P4_X $P4_Y   L $P6_X $P6_Y  Q $P3Q_X $P3Q_Y , $P7_X $P7_Y  L $P8_X $P8_Y Q $P4Q_X $P4Q_Y ,$P9_X $P9_Y  Z",
						style => {
							'fill'           =>  $BGCorThisChr,
							'stroke'         =>  $HashConfi{$LevelV2}{"crStrokeBG"},
							'stroke-width'   =>  $HashConfi{$LevelV2}{"strokeWidthBG"},
							'stroke-opacity' =>  $HashConfi{$LevelV2}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$LevelV2}{"fill-opacity"},
						},
					);





				}


				my $ChrNameRatio=$HashConfi{$LevelV2}{"ChrNameRatio"}; $ChrNameRatio||=1;
				my $CCCfontsize=$fontsize*$ChrNameRatio;
				my $XX3=$XX1-length($CCCChrName)*$CCCfontsize*$chrNameShiftRitao+$HashConfi{$LevelV2}{"ShiftChrNameX"};
				if ($XX3<0) {$XX3=0;}
				my $TextYY=($YY5+$YY6)/2.0+$HashConfi{$LevelV2}{"ShiftChrNameY"}+($CCCfontsize*0.5);
				if ($HashConfi{"global"}{"RotateChrName"}==0)
				{
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$CCCChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$CCCfontsize);
				}
				else
				{
					my $XX3=$XX1-$CCCfontsize*1.1+$HashConfi{$LevelV2}{"ShiftChrNameX"};
					my $rotate=$HashConfi{"global"}{"RotateChrName"};
					$svg->text('text-anchor','middle','x',$XX3,'y',$TextYY,'-cdata',$CCCChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$CCCfontsize,'transform',"rotate($rotate,$XX3,$TextYY)");
				}
				$XX1=$XX2+$XBetweenChr;

			}





		}
	}






	######################swimming in the sky and flying in the sea ###########################


	for (my $Level=1; $Level<=$NumberLevel;  $Level++)
	{
		my $FlagValueThis=$FlagValue{$Level};
		my @ValueArry= sort  keys  %$FlagValueThis;
		if ($HashConfi{$Level}{"IsNumber"}==1)
		{
			@ValueArry= sort {$a<=>$b}   @ValueArry ;
		}

		my $ValueMin=$ValueArry[0];
		my $ValueCount=$#ValueArry;
		my $ValueMax=$ValueArry[$ValueCount];

		my $MinCutNum=$HashConfi{$Level}{"TopVLow"} * $HashConfi{$Level}{"TotalValue"};
		my $MaxCutNum=$HashConfi{$Level}{"TopVHigh"} * $HashConfi{$Level}{"TotalValue"};
		my $MinCutCount=0;		my $MaxCutCount=0;
		my $EndCountBin=$#ValueArry;	my $StartCountBin=0;

		foreach my $key (0..$ValueCount)
		{
			my $VCount=$ValueArry[$key];
			$MinCutCount+=$FlagValue{$Level}{$VCount};
			$MaxCutCount+=$FlagValue{$Level}{$VCount};
			if ($MinCutCount<=$MinCutNum)
			{
				$StartCountBin=$key;
			}
			if ($MaxCutCount<=$MaxCutNum)
			{
				$EndCountBin=$key;
			}
		}

		my $MinCutValue=$ValueArry[$StartCountBin];	
		my $MaxCutValue=$ValueArry[$EndCountBin];


		if(exists $HashConfi{$Level}{"YMax"})
		{
			if ($HashConfi{$Level}{"YMax"}>$MaxCutValue)
			{
				$MaxCutValue=$HashConfi{$Level}{"YMax"};
			}
			else
			{
				my $eeetmp=$HashConfi{$Level}{"YMax"};
				print "InPut Para For [Level $Level] YMax  $eeetmp  must > $MaxCutValue \t since the data max Value is $MaxCutValue\n";
			}
		}
		else
		{
			$HashConfi{$Level}{"YMax"}=$MaxCutValue;
		}


		if (exists $HashConfi{$Level}{"YMin"})
		{
			if  ($HashConfi{$Level}{"YMin"}> $MinCutValue )
			{
				my $eeetmp=$HashConfi{$Level}{"YMin"};
				print "InPut -YMin For [Level $Level] $eeetmp must < $ValueMin \t since the data min Value is $MinCutValue\n";
			}
			else
			{
				$MinCutValue=$HashConfi{$Level}{"YMin"};
			}
		}
		else
		{
			$HashConfi{$Level}{"YMin"}= $MinCutValue;
		}

		if ($HashConfi{$Level}{"IsNumber"}==1)
		{
			foreach my $key (0..$ValueCount)
			{
				my $VCount=$ValueArry[$key];
				if ( $VCount  <= $MinCutValue )
				{
					$StartCountBin=$key;
				}
				if ( $VCount <= $MaxCutValue )
				{
					$EndCountBin=$key;
				}
			}
		}
		else
		{
			foreach my $key (0..$ValueCount)
			{
				my $VCount=$ValueArry[$key];
				if ( $VCount le  $MinCutValue)
				{
					$StartCountBin=$key;
				}
				if ($VCount le  $MaxCutValue)
				{
					$EndCountBin=$key;
				}
			}
		}



		my %hashValue2Col=();
		my @ArryCol=();
		my @ArryValue=();
		my $MaxCol=1;

		my $Precision=$Accu;
		if (exists $HashConfi{$Level}{"Precision"} )
		{
			my $Num=int($HashConfi{$Level}{"Precision"});
			$Precision="%.$Num"."f";
		}


		if ( ( $HashConfi{$Level}{"IsNumber"}==1 )   &&  ( abs($ValueMax)<0.01 )  &&  ( abs($ValueMin)<0.01 ) )
		{
			my $e='e';	my $f='f';
			$Precision =~ s/$f/$e/g;
		}

		my $NumGradien= $HashConfi{$Level}{"Gradien"};
		if ($ValueCount<$NumGradien)
		{
			$HashConfi{$Level}{"Gradien"}=$ValueCount+1;
			$NumGradien=  $ValueCount+1;
			$EndCountBin=$ValueCount;$StartCountBin=0;
			$MaxCutValue=$ValueMax  ; $MinCutValue=$ValueMin;
		}

		if ($EndCountBin<($NumGradien-2))
		{
			$EndCountBin=$NumGradien-2;
		}
		if ($EndCountBin==$ValueCount)
		{
			if  (($EndCountBin-$StartCountBin)<($NumGradien-2))
			{
				$StartCountBin=$EndCountBin+2-$NumGradien;				 
			}
		}
		else
		{
			if  (($EndCountBin-$StartCountBin)<($NumGradien-3))
			{
				$StartCountBin=$EndCountBin+3-$NumGradien;
			}
		}
		if ($StartCountBin<0) {$StartCountBin=0;}


		if ( exists $HashConfi{$Level}{"ColorBrewer"}  )
		{
			if ( $HashConfi{$Level}{"ColorBrewer"}  eq  "NANA" )
			{
				if ($HashConfi{$Level}{"IsNumber"}==1 )
				{
					$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
					$HashConfi{$Level}{"Gradien"}=10;
					$NumGradien=10;
				}
				else
				{
					$HashConfi{$Level}{"ColorBrewer"}="Paired";
					$HashConfi{$Level}{"Gradien"}=8;
					$NumGradien=8;
				}
			}
			elsif ( $HashConfi{$Level}{"ColorBrewer"}  eq  "NA" )
			{
				if ($HashConfi{$Level}{"IsNumber"}==1 )
				{
					$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
				}
				else
				{
					$HashConfi{$Level}{"ColorBrewer"}="Paired";
				}
			}

			if ($ValueCount<$NumGradien)
			{
				$HashConfi{$Level}{"Gradien"}=$ValueCount+1;
				$NumGradien=  $ValueCount+1;
				$EndCountBin=$ValueCount;$StartCountBin=0;
				$MaxCutValue=$ValueMax  ; $MinCutValue=$ValueMin;
			}
			if ($EndCountBin<($NumGradien-2))
			{
				$EndCountBin=$NumGradien-2;
			}			
			if ($EndCountBin==$ValueCount)
			{
				if  (($EndCountBin-$StartCountBin)<($NumGradien-2))
				{
					$StartCountBin=$EndCountBin+2-$NumGradien;				 
				}
			}
			else
			{
				if  (($EndCountBin-$StartCountBin)<($NumGradien-3))
				{
					$StartCountBin=$EndCountBin+3-$NumGradien;
				}
			}
			if ($StartCountBin<0) {$StartCountBin=0;}

			my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
			GetColGradien($ColFlag,$NumGradien,\@ArryCol);
			if  (exists  $HashConfi{$Level}{"ReverseColor"})
			{
				my @cccTmpCor=();
				foreach my $k (0..$#ArryCol)
				{
					my $Tho=$#ArryCol-$k;
					$cccTmpCor[$Tho]=$ArryCol[$k];
				}
				foreach my $k (0..$#ArryCol)
				{
					$ArryCol[$k]=$cccTmpCor[$k];
				}
			}
			$MaxCol=$NumGradien-1;


			if ($HashConfi{$Level}{"IsNumber"}==1 )
			{
				my $ShiftTmpEnd=$NumGradien-1;

				if ($EndCountBin< $ValueCount)
				{
					my $tttEnd=$EndCountBin+1;
					my $VV=$ValueArry[$tttEnd];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[$ShiftTmpEnd]=">$VV";
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpEnd];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}
				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpStart];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}

				my $Diff=1;
				if ($NumGradien>1)
				{
					$Diff=($MaxCutValue-$MinCutValue)/($NumGradien-1);
					if ($Diff==0) {$Diff=1;}
				}

				foreach my $k ($StartCountBin..$EndCountBin)
				{
					my $VV=$ValueArry[$k];
					my $KKey=int(($VV-$MinCutValue)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}

				my $Shift=$ShiftTmpStart;
				foreach my $k ($ShiftTmpStart..$ShiftTmpEnd)
				{
					my $MinAA=$ValueArry[$StartCountBin]+($k-$Shift)*$Diff;
					$MinAA=sprintf ($Precision,$MinAA*1.0);
					$ArryValue[$k]="$MinAA";
				}
			}
			else
			{
				my $ShiftTmpEnd=$NumGradien-1;
				if ($EndCountBin< $ValueCount)
				{
					my $tttEnd=$EndCountBin+1;
					my $VV=$ValueArry[$tttEnd];
					$ArryValue[$ShiftTmpEnd]="$VV";
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpEnd];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}
				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpStart];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}

				my $Diff=1;
				if ($NumGradien>1)
				{
					$Diff=($EndCountBin-$StartCountBin)/($NumGradien-1);
					if ($Diff==0) {$Diff=1;}
				}
				foreach my $k ($StartCountBin..$EndCountBin)
				{			
					my $VV=$ValueArry[$k];
					my $KKey=int(($k-$StartCountBin)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					$ArryValue[$KKey]||="$VV";
				}
			}
		}
		elsif  ($ValueCount==2)
		{
			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
			$VV=$ValueArry[1];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crMid"};$ArryCol[1]=$HashConfi{$Level}{"crMid"}; $ArryValue[1]=$VV;
			$VV=$ValueArry[2];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[2]=$HashConfi{$Level}{"crEnd"}; $ArryValue[2]=$VV;
			$MaxCol=2;
		}
		elsif ($ValueCount < 2)
		{
			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
			if ($ValueCount==0) {$ValueArry[1]=$ValueArry[0];}
			$VV=$ValueArry[1]; 
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[1]=$HashConfi{$Level}{"crEnd"}; $ArryValue[1]=$VV;
			$MaxCol=1;
		}
		elsif ($ValueCount< $HashConfi{$Level}{"Gradien"})
		{

			my $Atmp=int($ValueCount/2);
			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
			$VV=$ValueArry[$Atmp];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crMid"};$ArryCol[$Atmp]=$HashConfi{$Level}{"crMid"}; $ArryValue[$Atmp]=$VV;
			$VV=$ValueArry[$ValueCount];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[$ValueCount]=$HashConfi{$Level}{"crEnd"}; $ArryValue[$ValueCount]=$VV;

			my @StartRGB;
			($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
			my @EndRGB;
			($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
			my @MidRGB;
			($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});


			my $MidNumGradien=$Atmp; my $Btmp=$Atmp-1;
			foreach my $k (1..$Btmp)
			{
				my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
				my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
				my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
				$VV=$ValueArry[$k];   $hashValue2Col{$VV}="rgb($RR,$GG,$BB)";
				$ArryCol[$k]="rgb($RR,$GG,$BB)";  $ArryValue[$k]=$VV;
				if (exists $Value2SelfCol{$VV} )
				{
					$hashValue2Col{$VV}=$Value2SelfCol{$VV};
					$ArryCol[$k]=$Value2SelfCol{$VV};				
				}
			}
			$Btmp=$Atmp+1;  my $Ctmp=$ValueCount-1;

			foreach my $k ($Btmp..$Ctmp)
			{
				my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$Atmp)*1.0/$MidNumGradien);
				my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$Atmp)*1.0/$MidNumGradien);
				my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$Atmp)*1.0/$MidNumGradien);
				$VV=$ValueArry[$k];   $hashValue2Col{$VV}="rgb($RR,$GG,$BB)";
				$ArryCol[$k]="rgb($RR,$GG,$BB)";  $ArryValue[$k]=$VV;
				if (exists $Value2SelfCol{$VV} )
				{
					$hashValue2Col{$VV}=$Value2SelfCol{$VV};
					$ArryCol[$k]=$Value2SelfCol{$VV};				
				}
			}
			$MaxCol=$ValueCount;
		}
		else
		{

			my $NumGradien=$HashConfi{$Level}{"Gradien"};
			$MaxCol=$NumGradien-1;
			my $MidNumGradien=int($MaxCol/2);


			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$VV=$ValueArry[$MidNumGradien];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
			$VV=$ValueArry[$MaxCol];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}



			my @StartRGB;
			($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
			my @EndRGB;
			($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
			my @MidRGB;
			($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

			foreach my $k (0..$MidNumGradien)
			{
				my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
				my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
				my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
				$ArryCol[$k]="rgb($RR,$GG,$BB)";
			}
			my $MidNumGradienBB=$MidNumGradien+1;
			$NumGradien--;
			foreach my $k ($MidNumGradienBB..$NumGradien)
			{
				my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
				my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
				my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
				$ArryCol[$k]="rgb($RR,$GG,$BB)";
			}

			if ($HashConfi{$Level}{"IsNumber"}==1 )
			{
				my $ShiftTmpEnd=$NumGradien;
				if ($EndCountBin< $ValueCount)
				{
					my $VV=$ValueArry[$EndCountBin];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[$NumGradien]=">$VV";
					my $tttEnd=$EndCountBin+1;
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}

				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}


				my $Diff=($MaxCutValue-$MinCutValue)/($NumGradien+1);
				if ($Diff==0) {$Diff=1;}
				foreach my $k ($StartCountBin..$EndCountBin)
				{
					my $VV=$ValueArry[$k];
					my $KKey=int(($VV-$MinCutValue)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				my $Shift=$ShiftTmpStart;	
				foreach my $k ($ShiftTmpStart..$ShiftTmpEnd)
				{
					my $MinAA=$ValueArry[$StartCountBin]+($k-$Shift)*$Diff;
					$MinAA=sprintf ($Precision,$MinAA*1.0);
					$ArryValue[$k]="$MinAA";
				}
			}
			else
			{
				my $ShiftTmpEnd=$NumGradien;
				if ($EndCountBin< $ValueCount)
				{
					my $VV=$ValueArry[$EndCountBin];
					$ArryValue[$NumGradien]=">$VV";
					my $tttEnd=$EndCountBin+1;
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}

				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}

				my $Diff=($EndCountBin-$StartCountBin)/($NumGradien);
				if ($Diff==0) {$Diff=1;}
				foreach my $k ($StartCountBin..$EndCountBin)
				{
					my $VV=$ValueArry[$k];
					my $KKey=int(($k-$StartCountBin)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					$ArryValue[$KKey]||="$VV";
				}
			}
		}




		if (%Value2SelfCol)
		{
			my @TmpCol=keys %Value2SelfCol;
			if ($#TmpCol >=$ValueCount)
			{
				foreach my $yy (0..$MaxCol)
				{
					my $cc=$ArryValue[$yy];
					if  (exists $Value2SelfCol{$cc}) { $ArryCol[$yy]=$Value2SelfCol{$cc};}
				}
			}
		}



		if ($HashConfi{$Level}{"fill-opacity"}==1   &&  $HashConfi{$Level}{"stroke-opacity"} ==1 )
		{
			$HashConfi{$Level}{"fill-opacity"}=0.95;
			$HashConfi{$Level}{"stroke-opacity"}=0.95;
		}

		if($HashConfi{$Level}{"fill-opacity"}<0.3)
		{
			$HashConfi{$Level}{"fill-opacity"}=0.3;
		}
		elsif ($HashConfi{$Level}{"fill-opacity"}>0.98)
		{
			$HashConfi{$Level}{"fill-opacity"}=1;
		}

		if($HashConfi{$Level}{"stroke-opacity"}<0.3)
		{
			$HashConfi{$Level}{"stroke-opacity"}=0.3;
		}
		elsif ($HashConfi{$Level}{"stroke-opacity"}>0.98)
		{
			$HashConfi{$Level}{"stroke-opacity"}=1;
		}

		my $LevelCorGra=$HashConfi{$Level}{"SizeGradienRatio"}*$CorGra;
		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
		$XX2=$XX1+$LevelCorGra;

		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{
		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);  
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}













		my $MidHH=$TwoChrHH/2.5;
		my $MidHHV2=$TwoChrHHV2/2.5;


		my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
		my $LineType=1;
		if ((exists $HashConfi{$Level}{"lineType"})   && ($HashConfi{$Level}{"lineType"} eq "line")  )
		{
			$LineType=0;
		}


		$FileNow=$Level-1;
		$StartCount=0;
		$CoumnNow=3;
		if  ($FileData[$FileNow][0][0] =~s/#/#/) 
		{
			$StartCount=1;
		}
		if  (exists $HashConfi{$Level}{"ReverseChr"} )
		{
			my @SplitChr=split/\,/,$HashConfi{$Level}{"ReverseChr"};
			my $ReStartCount=$StartCount;
			if   ($Level==1)
			{
				foreach my $k (0..$#SplitChr)
				{
					my $TmpChrBName=$SplitChr[$k];
					print "Reverse Link GenomeB Chr:\t$TmpChrBName\n";
					$ReverseChr{$TmpChrBName}=$ChrGenomeB{$TmpChrBName};
				}
			}
			else
			{
				foreach my $k (0..$#SplitChr)
				{
					my $TmpChrCName=$SplitChr[$k];
					print "Reverse Link GenomeC Chr:\t$TmpChrCName\n";
					$ReverseChr{$TmpChrCName}=$ChrGenomeC{$TmpChrCName};
				}
			}

			for ( ; $ReStartCount<$FileRow[$FileNow]; $ReStartCount++)
			{
				my $chrB=$FileData[$FileNow][$ReStartCount][4];
				next if (!exists $ReverseChr{$chrB});
				my $StartB=$ReverseChr{$chrB}-$FileData[$FileNow][$ReStartCount][6];
				my $EndB=$ReverseChr{$chrB}-$FileData[$FileNow][$ReStartCount][5];
				$FileData[$FileNow][$ReStartCount][5]=$StartB;
				$FileData[$FileNow][$ReStartCount][6]=$EndB;
			}
		}
		if ($LineType == 0 )
		{
			if ($NumberLevel==1)
			{
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");	
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $ChrGenomeA{$ThisChrName} ) ;
					my $StartA=$FileData[$FileNow][$StartCount][1];
					my $EndA  =$FileData[$FileNow][$StartCount][2];
					my $chrB=$FileData[$FileNow][$StartCount][4];
					my $StartB=$FileData[$FileNow][$StartCount][5];
					my $EndB=$FileData[$FileNow][$StartCount][6];

					my $YY1_AA=$hashYY1{$ThisChrName}{0};
					my $YY2_AA=$hashYY2{$ThisChrName}{0};
					my $XStart_AA=$hashXX1{$ThisChrName}{0}+($StartA)/($ChrMaxUnit);
					my $XEnd_AA=$hashXX1{$ThisChrName}{0}+($EndA)/($ChrMaxUnit);
					next if (!exists $hashYY1{$chrB}{$Level});
					my $YY1_BB=$hashYY1{$chrB}{$Level};
					my $YY2_BB=$hashYY2{$chrB}{$Level};
					my $XStart_BB=$hashXX1{$chrB}{$Level}+($StartB)/($ChrMaxUnitV2);
					my $XEnd_BB=$hashXX1{$chrB}{$Level}+($EndB)/($ChrMaxUnitV2);

					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$path = $svg->get_path(
						x => [$XStart_AA, $XEnd_AA, $XEnd_BB,$XStart_BB],
						y => [$YY2_AA, $YY2_AA, $YY1_BB,$YY1_BB],
						-type => 'polygon');
					$svg->polygon(
						%$path,
						style => {
							'opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill'           => $hashValue2Col{$Value},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
							'stroke'         => $hashValue2Col{$Value},
							'stroke-width'   => $HHstrokewidth,
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						},
					);
				}
			}
			else
			{
				if ($Level==1)
				{
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");	
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $ChrGenomeA{$ThisChrName} ) ;
						my $StartA=$FileData[$FileNow][$StartCount][1];
						my $EndA  =$FileData[$FileNow][$StartCount][2];
						my $chrB=$FileData[$FileNow][$StartCount][4];
						my $StartB=$FileData[$FileNow][$StartCount][5];
						my $EndB=$FileData[$FileNow][$StartCount][6];

						my $YY1_AA=$hashYY1{$ThisChrName}{0};
						my $YY2_AA=$hashYY2{$ThisChrName}{0};
						my $XStart_AA=$hashXX1{$ThisChrName}{0}+($StartA)/($ChrMaxUnit);
						my $XEnd_AA=$hashXX1{$ThisChrName}{0}+($EndA)/($ChrMaxUnit);
						next if (!exists $hashYY1{$chrB}{$Level});
						my $YY1_BB=$hashYY1{$chrB}{$Level};
						my $YY2_BB=$hashYY2{$chrB}{$Level};
						my $XStart_BB=$hashXX1{$chrB}{$Level}+($StartB)/($ChrMaxUnitV2);
						my $XEnd_BB=$hashXX1{$chrB}{$Level}+($EndB)/($ChrMaxUnitV2);

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
						$path = $svg->get_path(
							x => [$XStart_BB,$XEnd_BB,$XEnd_AA,$XStart_AA],
							y => [$YY2_BB,$YY2_BB,$YY1_AA,$YY1_AA],
							-type => 'polygon');
						$svg->polygon(
							%$path,
							style => {
								'opacity' => $HashConfi{$Level}{"stroke-opacity"},
								'fill'           => $hashValue2Col{$Value},
								'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
								'stroke'         => $hashValue2Col{$Value},
								'stroke-width'   => $HHstrokewidth,
								'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							},
						);
					}


				}
				else
				{


					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");	
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $ChrGenomeA{$ThisChrName} ) ;
						my $StartA=$FileData[$FileNow][$StartCount][1];
						my $EndA  =$FileData[$FileNow][$StartCount][2];
						my $chrB=$FileData[$FileNow][$StartCount][4];
						my $StartB=$FileData[$FileNow][$StartCount][5];
						my $EndB=$FileData[$FileNow][$StartCount][6];

						my $YY1_AA=$hashYY1{$ThisChrName}{0};
						my $YY2_AA=$hashYY2{$ThisChrName}{0};
						my $XStart_AA=$hashXX1{$ThisChrName}{0}+($StartA)/($ChrMaxUnit);
						my $XEnd_AA=$hashXX1{$ThisChrName}{0}+($EndA)/($ChrMaxUnit);
						next if (!exists $hashYY1{$chrB}{$Level});
						my $YY1_BB=$hashYY1{$chrB}{$Level};
						my $YY2_BB=$hashYY2{$chrB}{$Level};
						my $XStart_BB=$hashXX1{$chrB}{$Level}+($StartB)/($ChrMaxUnitV3);
						my $XEnd_BB=$hashXX1{$chrB}{$Level}+($EndB)/($ChrMaxUnitV3);

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
						$path = $svg->get_path(
							x => [$XStart_AA,$XEnd_AA,$XEnd_BB,$XStart_BB],
							y => [$YY2_AA,$YY2_AA,$YY1_BB,$YY1_BB],
							-type => 'polygon');
						$svg->polygon(
							%$path,
							style => {
								'opacity' => $HashConfi{$Level}{"stroke-opacity"},
								'fill'           => $hashValue2Col{$Value},
								'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
								'stroke'         => $hashValue2Col{$Value},
								'stroke-width'   => $HHstrokewidth,
								'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							},
						);
					}







				}
			}

		}


		else ## 二次贝塞尔曲线  贝塞尔曲线
		{

			if ($NumberLevel==1)
			{
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");	
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $ChrGenomeA{$ThisChrName} ) ;
					my $StartA=$FileData[$FileNow][$StartCount][1];
					my $EndA  =$FileData[$FileNow][$StartCount][2];
					my $chrB=$FileData[$FileNow][$StartCount][4];
					my $StartB=$FileData[$FileNow][$StartCount][5];
					my $EndB=$FileData[$FileNow][$StartCount][6];

					my $YY1_AA=$hashYY1{$ThisChrName}{0};
					my $YY2_AA=$hashYY2{$ThisChrName}{0};
					my $XStart_AA=$hashXX1{$ThisChrName}{0}+($StartA)/($ChrMaxUnit);
					my $XEnd_AA=$hashXX1{$ThisChrName}{0}+($EndA)/($ChrMaxUnit);
					next if (!exists $hashYY1{$chrB}{$Level});
					my $YY1_BB=$hashYY1{$chrB}{$Level};
					my $YY2_BB=$hashYY2{$chrB}{$Level};
					my $XStart_BB=$hashXX1{$chrB}{$Level}+($StartB)/($ChrMaxUnitV2);
					my $XEnd_BB=$hashXX1{$chrB}{$Level}+($EndB)/($ChrMaxUnitV2);

					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					my $MidXX_Start=($XStart_AA+$XStart_BB)*0.5;
					my $MidYY=($YY2_AA+$YY1_BB)*0.5;
					my $MidXX_End=($XEnd_AA+$XEnd_BB)*0.5;

					my $kk=($XEnd_AA-$MidXX_End)*0.4/$MidHH;
					my $QQBB_XX=($XEnd_AA + $MidXX_End)*0.5+$MidHH*$kk;
					my $QQBB_YY=($YY2_AA+ $MidYY)*0.5;

					$kk=($XStart_BB-$MidXX_Start)*0.4/$MidHH;
					my $QQAA_XX=($XStart_BB+$MidXX_Start)*0.5+$MidHH*$kk;
					my $QQAA_YY=($MidYY+$YY1_BB)*0.5;

					$svg->path(
						'd'=>"M$XStart_AA $YY2_AA L $XEnd_AA $YY2_AA  Q $QQBB_XX $QQBB_YY , $MidXX_End $MidYY T $XEnd_BB $YY1_BB  L $XStart_BB $YY1_BB Q $QQAA_XX $QQAA_YY , $MidXX_Start $MidYY T $XStart_AA $YY2_AA  Z",
						style => {
							'opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill'           => $hashValue2Col{$Value},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
							'stroke'         => $hashValue2Col{$Value},
							'stroke-width'   => $HHstrokewidth,
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						},
					);
				}
			}
			else 
			{

				if ($Level==1)
				{
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");	
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $ChrGenomeA{$ThisChrName} ) ;
						my $StartA=$FileData[$FileNow][$StartCount][1];
						my $EndA  =$FileData[$FileNow][$StartCount][2];
						my $chrB=$FileData[$FileNow][$StartCount][4];
						my $StartB=$FileData[$FileNow][$StartCount][5];
						my $EndB=$FileData[$FileNow][$StartCount][6];

						my $YY1_AA=$hashYY1{$ThisChrName}{0};
						my $YY2_AA=$hashYY2{$ThisChrName}{0};
						my $XStart_AA=$hashXX1{$ThisChrName}{0}+($StartA)/($ChrMaxUnit);
						my $XEnd_AA=$hashXX1{$ThisChrName}{0}+($EndA)/($ChrMaxUnit);
						next if (!exists $hashYY1{$chrB}{$Level} ) ;
						my $YY1_BB=$hashYY1{$chrB}{$Level};
						my $YY2_BB=$hashYY2{$chrB}{$Level};
						my $XStart_BB=$hashXX1{$chrB}{$Level}+($StartB)/($ChrMaxUnitV2);
						my $XEnd_BB=$hashXX1{$chrB}{$Level}+($EndB)/($ChrMaxUnitV2);

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

						my $MidXX_End=($XEnd_BB+$XEnd_AA)*0.5;
						my $MidYY=($YY2_BB+$YY1_AA)*0.5;
						my $MidXX_Start=($XStart_AA+$XStart_BB)*0.5;

						my $kk=($XEnd_BB-$MidXX_End)*0.4/$MidHH;
						my $QQBB_XX=($XEnd_BB+$MidXX_End)*0.5+$MidHH*$kk;
						my $QQBB_YY=($YY2_BB+ $MidYY)*0.5;

						$kk=($XStart_AA-$MidXX_Start)*0.4/$MidHH;
						my $QQAA_XX=($XStart_AA+$MidXX_Start)*0.5+$MidHH*$kk;
						my $QQAA_YY=($MidYY+$YY1_AA)*0.5;

						$svg->path(
							'd'=>"M$XStart_BB $YY2_BB L $XEnd_BB $YY2_BB  Q $QQBB_XX $QQBB_YY , $MidXX_End $MidYY T $XEnd_AA $YY1_AA  L $XStart_AA $YY1_AA Q $QQAA_XX $QQAA_YY , $MidXX_Start $MidYY T $XStart_BB $YY2_BB  Z",
							style => {
								'opacity' => $HashConfi{$Level}{"stroke-opacity"},
								'fill'           => $hashValue2Col{$Value},
								'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
								'stroke'         => $hashValue2Col{$Value},
								'stroke-width'   => $HHstrokewidth,
								'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							},
						);


					}


				}
				else
				{



					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");	
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $ChrGenomeA{$ThisChrName} ) ;
						my $StartA=$FileData[$FileNow][$StartCount][1];
						my $EndA  =$FileData[$FileNow][$StartCount][2];
						my $chrB=$FileData[$FileNow][$StartCount][4];
						my $StartB=$FileData[$FileNow][$StartCount][5];
						my $EndB=$FileData[$FileNow][$StartCount][6];

						my $YY1_AA=$hashYY1{$ThisChrName}{0};
						my $YY2_AA=$hashYY2{$ThisChrName}{0};
						my $XStart_AA=$hashXX1{$ThisChrName}{0}+($StartA)/($ChrMaxUnit);
						my $XEnd_AA=$hashXX1{$ThisChrName}{0}+($EndA)/($ChrMaxUnit);
						next if (!exists $hashYY1{$chrB}{$Level});
						my $YY1_BB=$hashYY1{$chrB}{$Level};
						my $YY2_BB=$hashYY2{$chrB}{$Level};
						my $XStart_BB=$hashXX1{$chrB}{$Level}+($StartB)/($ChrMaxUnitV3);
						my $XEnd_BB=$hashXX1{$chrB}{$Level}+($EndB)/($ChrMaxUnitV3);

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}


						my $MidXX_End=($XEnd_BB+$XEnd_AA)*0.5;
						my $MidYY=($YY2_AA+$YY1_BB)*0.5;
						my $MidXX_Start=($XStart_AA+$XStart_BB)*0.5;

						my $kk=($XEnd_AA-$MidXX_End)*0.4/$MidHH;
						my $QQBB_XX=($XEnd_AA+$MidXX_End)*0.5+$MidHH*$kk;
						my $QQBB_YY=($YY2_AA+ $MidYY)*0.5;

						$kk=($XStart_BB - $MidXX_Start)*0.4/$MidHH;
						my $QQAA_XX=($XStart_BB+$MidXX_Start)*0.5+$MidHH*$kk;
						my $QQAA_YY=($MidYY+$YY1_BB)*0.5;
						$svg->path(
							'd'=>"M$XStart_AA $YY2_AA L $XEnd_AA $YY2_AA  Q $QQBB_XX $QQBB_YY , $MidXX_End $MidYY T $XEnd_BB $YY1_BB  L $XStart_BB $YY1_BB Q $QQAA_XX $QQAA_YY , $MidXX_Start $MidYY T $XStart_AA $YY2_AA  Z",
							style => {
								'opacity' => $HashConfi{$Level}{"stroke-opacity"},
								'fill'           => $hashValue2Col{$Value},
								'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
								'stroke'         => $hashValue2Col{$Value},
								'stroke-width'   => $HHstrokewidth,
								'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							},
						);




					}
				}

			}


		}




	}



	################  Link 层  背景条额外信息 #######

	for (my $Level=$NumberLevel+1; $Level<4 ; $Level++)
	{
		if ( !( (exists $HashConfi{$Level}{"ShowColumn"} )    &&  ( $HashConfi{$Level}{"PType"}  ne  "link" )   &&  ( $HashConfi{$Level}{"PType"} ne "Link" ) ))
		{
			next ;
		}
		my @temAA=split /\s+/,$HashConfi{$Level}{"ShowColumn"};
		foreach my $tmpA (0..$#temAA)
		{
			my @temBB=split /\:/,$temAA[$tmpA];
			if ($temBB[0]=~s/File//g)
			{
				$temBB[0]--;
				my $VV=$FileColumn[$temBB[0]]; $VV||=-1;
				if ($VV<0) { print "Error:\tCan't find the File $temBB[0]+1 \n"; exit ;}
				my @temCC=split /\,/,$temBB[-1];
				foreach my $coumn (@temCC)
				{
					$coumn--;
					if  ($coumn <3 || $coumn>$VV)
					{
						print "File $temBB[0] Column only $VV+1, but you give the ShowColumn is $coumn; skip this Level info draw\n";
						next ;
					}
					else
					{
						my $AA=$Level-1;
						push @{$ShowColumn[$AA]},[$temBB[0],$coumn];
					}
				}
			}
			else
			{
				print "Error:\tPara  ShowColumn  For $Level Format wrong \n";
				exit;
			}			
		}


		foreach my $kk (0..$NumParaFlag)
		{
			my $thisPara=$ParaFlag[$kk];
			if ((exists $HashConfi{"ALL"}{$thisPara}) && (!exists $HashConfi{$Level}{$thisPara}))
			{
				$HashConfi{$Level}{$thisPara}=$HashConfi{"ALL"}{$thisPara};
			}
		}	





		my %ChrName2DiffGenome=();
		my %SameChrName=();
		my %GenomeFlag=(); 
		$GenomeFlag{"Ref0"}=0;$GenomeFlag{"Ref1"}=1; $GenomeFlag{"Ref2"}=2;
		foreach my $chr (keys %ChrGenomeA)
		{
			$ChrName2DiffGenome{$chr}=0;
		}
		foreach my $chr (keys %ChrGenomeB)
		{
			if  (!exists $ChrName2DiffGenome{$chr})
			{
				$ChrName2DiffGenome{$chr}=1;
			}
			else
			{
				$SameChrName{$chr}=$ChrName2DiffGenome{$chr}."/1";
			}
		}
		foreach my $chr (keys %ChrGenomeC)
		{
			if  (!exists $ChrName2DiffGenome{$chr})
			{
				$ChrName2DiffGenome{$chr}=2;
			}
			else
			{
				$SameChrName{$chr}=$ChrName2DiffGenome{$chr}."/2";
			}
		}



		my %FlagValue=();
		$HashConfi{$Level}{"IsNumber"}=1;
		$HashConfi{$Level}{"TotalValue"}=0;
		my $PlotInfo=$ShowColumn[$Level-1];
		my $PlotArryNum=$#$PlotInfo+1;







		for (my $i=0; $i<$PlotArryNum; $i++)
		{
			my $NowPlot=$PlotInfo->[$i];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				next if  ($FileData[$FileNow][$StartCount][$CoumnNow] eq "NA");	
				if ($HashConfi{$Level}{"LogP"}!=0)
				{
					$FileData[$FileNow][$StartCount][$CoumnNow]=0-log($FileData[$FileNow][$StartCount][$CoumnNow])/$log10;
				}
				$FlagValue{$FileData[$FileNow][$StartCount][$CoumnNow]}++;
				$HashConfi{$Level}{"TotalValue"}++;
				if ($FileData[$FileNow][$StartCount][$CoumnNow]=~s/\./\./)
				{
					$Accu="%.2f";
				}

				if ( $FileData[$FileNow][$StartCount][$CoumnNow]  =~ /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([eE][-+]?[0-9]+)?$/)
				{

				}
				elsif (!( $FileData[$FileNow][$StartCount][$CoumnNow]  =~ /^[+-]?\d+(\.\d+)?$/ ))
				{
					$HashConfi{$Level}{"IsNumber"}=0;
				}
			}
		}

		if (exists $HashConfi{$Level}{"asFlag"} ) {	  $HashConfi{$Level}{"IsNumber"}=0; }
		my @ValueArry= sort  keys  %FlagValue ;
		if ($HashConfi{$Level}{"IsNumber"}==1)
		{
			@ValueArry= sort {$a<=>$b} @ValueArry;
		}
		my $ValueMin=$ValueArry[0];
		my $ValueCount=$#ValueArry;
		my $ValueMax=$ValueArry[$ValueCount];

		if (!exists   $HashConfi{$Level}{"TopVHigh"} )
		{
			if (($HashConfi{$Level}{"PType"} ne  "heatmap" )  &&  ( $HashConfi{$Level}{"PType"} ne  "highlights")  &&  ($HashConfi{"ALL"}{"TopVHigh"} ==0.95)  )
			{
				$HashConfi{$Level}{"TopVHigh"}=1.01;
			}
			else
			{
				$HashConfi{$Level}{"TopVHigh"}=$HashConfi{"ALL"}{"TopVHigh"};
			}
		}

		my $MinCutNum=$HashConfi{$Level}{"TopVLow"} * $HashConfi{$Level}{"TotalValue"};
		my $MaxCutNum=$HashConfi{$Level}{"TopVHigh"} * $HashConfi{$Level}{"TotalValue"};
		my $MinCutCount=0;		my $MaxCutCount=0;
		my $EndCountBin=$#ValueArry;			my $StartCountBin=0;
		foreach my $key (0..$ValueCount)
		{
			my $VCount=$ValueArry[$key];
			$MinCutCount+=$FlagValue{$VCount};
			$MaxCutCount+=$FlagValue{$VCount};
			if ($MinCutCount<=$MinCutNum)
			{
				$StartCountBin=$key;
			}
			if ($MaxCutCount<=$MaxCutNum)
			{
				$EndCountBin=$key;
			}
		}
		my $MinCutValue=$ValueArry[$StartCountBin];	
		my $MaxCutValue=$ValueArry[$EndCountBin];


		if(exists $HashConfi{$Level}{"YMax"})
		{
			if ($HashConfi{$Level}{"YMax"}>$MaxCutValue)
			{
				$MaxCutValue=$HashConfi{$Level}{"YMax"};
			}
			else
			{
				my $eeetmp=$HashConfi{$Level}{"YMax"};
				print "InPut Para For [Level $Level] YMax  $eeetmp  must > $MaxCutValue \t since the data max Value is $MaxCutValue\n";
			}
		}
		else
		{
			$HashConfi{$Level}{"YMax"}=$MaxCutValue;
		}


		if (exists $HashConfi{$Level}{"YMin"})
		{
			if  ($HashConfi{$Level}{"YMin"}> $MinCutValue )
			{
				my $eeetmp=$HashConfi{$Level}{"YMin"};
				print "InPut -YMin For [Level $Level] $eeetmp must < $ValueMin \t since the data min Value is $MinCutValue\n";
			}
			else
			{
				$MinCutValue=$HashConfi{$Level}{"YMin"};
			}
		}
		else
		{
			$HashConfi{$Level}{"YMin"}= $MinCutValue;
		}

		if ($HashConfi{$Level}{"IsNumber"}==1)
		{
			foreach my $key (0..$ValueCount)
			{
				my $VCount=$ValueArry[$key];
				if ( $VCount  <= $MinCutValue )
				{
					$StartCountBin=$key;
				}
				if ( $VCount <= $MaxCutValue )
				{
					$EndCountBin=$key;
				}
			}
		}
		else
		{
			foreach my $key (0..$ValueCount)
			{
				my $VCount=$ValueArry[$key];
				if ( $VCount le  $MinCutValue)
				{
					$StartCountBin=$key;
				}
				if ($VCount le  $MaxCutValue)
				{
					$EndCountBin=$key;
				}
			}
		}




		my %hashValue2Col=();
		my @ArryCol=();
		my @ArryValue=();
		my $MaxCol=1;



		my $Precision=$Accu;
		if (exists $HashConfi{$Level}{"Precision"} )
		{
			my $Num=int($HashConfi{$Level}{"Precision"});
			$Precision="%.$Num"."f";
		}

		if ( ( $HashConfi{$Level}{"IsNumber"}==1 )   &&  ( abs($ValueMax)<0.01 )  &&  ( abs($ValueMin)<0.01 ) )
		{
			my $e='e';	my $f='f';
			$Precision =~ s/$f/$e/g;
		}

		my $NumGradien= $HashConfi{$Level}{"Gradien"};
		if ($ValueCount<$NumGradien)
		{
			$HashConfi{$Level}{"Gradien"}=$ValueCount+1;
			$NumGradien=  $ValueCount+1;
			$EndCountBin=$ValueCount;$StartCountBin=0;
			$MaxCutValue=$ValueMax  ; $MinCutValue=$ValueMin;
		}

		if ($EndCountBin<($NumGradien-2))
		{
			$EndCountBin=$NumGradien-2;
		}
		if ($EndCountBin==$ValueCount)
		{
			if  (($EndCountBin-$StartCountBin)<($NumGradien-2))
			{
				$StartCountBin=$EndCountBin+2-$NumGradien;				 
			}
		}
		else
		{
			if  (($EndCountBin-$StartCountBin)<($NumGradien-3))
			{
				$StartCountBin=$EndCountBin+3-$NumGradien;
			}
		}
		if ($StartCountBin<0) {$StartCountBin=0;}





		if ( exists $HashConfi{$Level}{"ColorBrewer"}  )
		{
			if ( $HashConfi{$Level}{"ColorBrewer"}  eq  "NANA" )
			{
				if ($HashConfi{$Level}{"IsNumber"}==1 )
				{
					$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
					$HashConfi{$Level}{"Gradien"}=10;
					$NumGradien=10;
					if (($HashConfi{$Level}{"PType"}  eq  "lines")  || ( $HashConfi{$Level}{"PType"}  eq  "line"))
					{
						$HashConfi{$Level}{"ColorBrewer"}="Dark2";
						$HashConfi{$Level}{"Gradien"}=8;
						$NumGradien=8;
					}
					elsif (($HashConfi{$Level}{"PType"}  eq  "scatter" )  || ( $HashConfi{$Level}{"PType"}  eq  "point" ) || ( $HashConfi{$Level}{"PType"}  eq  "points" ))
					{
						if  ($PlotArryNum>1) { $HashConfi{$Level}{"ColorBrewer"}="Set1"; $HashConfi{$Level}{"Gradien"}=9;$NumGradien=9;}
					}
				}
				else
				{
					$HashConfi{$Level}{"ColorBrewer"}="Paired";
					$HashConfi{$Level}{"Gradien"}=8;
					$NumGradien=8;
				}
			}
			elsif ( $HashConfi{$Level}{"ColorBrewer"}  eq  "NA" )
			{
				if ($HashConfi{$Level}{"IsNumber"}==1 )
				{
					$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
					if (($HashConfi{$Level}{"PType"}  eq  "lines")  || ( $HashConfi{$Level}{"PType"}  eq  "line"))
					{
						$HashConfi{$Level}{"ColorBrewer"}="Dark2";
					}
					elsif (($HashConfi{$Level}{"PType"}  eq  "scatter" )  || ( $HashConfi{$Level}{"PType"}  eq  "point" ) || ( $HashConfi{$Level}{"PType"}  eq  "points" ))
					{
						if  ($PlotArryNum>1) { $HashConfi{$Level}{"ColorBrewer"}="Set1";}
					}
				}
				else
				{
					$HashConfi{$Level}{"ColorBrewer"}="Paired";
				}
			}

			if ($ValueCount<$NumGradien)
			{
				$HashConfi{$Level}{"Gradien"}=$ValueCount+1;
				$NumGradien=  $ValueCount+1;
				$EndCountBin=$ValueCount;$StartCountBin=0;
				$MaxCutValue=$ValueMax  ; $MinCutValue=$ValueMin;
			}
			if ($EndCountBin<($NumGradien-2))
			{
				$EndCountBin=$NumGradien-2;
			}
			if ($EndCountBin==$ValueCount)
			{
				if  (($EndCountBin-$StartCountBin)<($NumGradien-2))
				{
					$StartCountBin=$EndCountBin+2-$NumGradien;				 
				}
			}
			else
			{
				if  (($EndCountBin-$StartCountBin)<($NumGradien-3))
				{
					$StartCountBin=$EndCountBin+3-$NumGradien;
				}
			}
			if ($StartCountBin<0) {$StartCountBin=0;}

			my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
			GetColGradien($ColFlag,$NumGradien,\@ArryCol);			
			if  (exists  $HashConfi{$Level}{"ReverseColor"})
			{
				my @cccTmpCor=();
				foreach my $k (0..$#ArryCol)
				{
					my $Tho=$#ArryCol-$k;
					$cccTmpCor[$Tho]=$ArryCol[$k];
				}
				foreach my $k (0..$#ArryCol)
				{
					$ArryCol[$k]=$cccTmpCor[$k];
				}
			}
			$MaxCol=$NumGradien-1;


			if ($HashConfi{$Level}{"IsNumber"}==1 )
			{
				my $ShiftTmpEnd=$NumGradien-1;

				if ($EndCountBin< $ValueCount)
				{
					my $tttEnd=$EndCountBin+1;
					my $VV=$ValueArry[$tttEnd];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[$ShiftTmpEnd]=">$VV";
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpEnd];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}

				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpStart];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}


				my $Diff=1;
				if ($NumGradien>1)
				{
					$Diff=($MaxCutValue-$MinCutValue)/($NumGradien-1);
					if ($Diff==0) {$Diff=1;}
				}

				foreach my $k ($StartCountBin..$EndCountBin)
				{
					my $VV=$ValueArry[$k];
					my $KKey=int(($VV-$MinCutValue)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}

				my $Shift=$ShiftTmpStart;
				foreach my $k ($ShiftTmpStart..$ShiftTmpEnd)
				{
					my $MinAA=$MinCutValue+($k-$Shift)*$Diff;
					$MinAA=sprintf ($Precision,$MinAA*1.0);
					$ArryValue[$k]="$MinAA";
				}
			}
			else
			{
				my $ShiftTmpEnd=$NumGradien-1;
				if ($EndCountBin< $ValueCount)
				{
					my $tttEnd=$EndCountBin+1;
					my $VV=$ValueArry[$tttEnd];
					$ArryValue[$ShiftTmpEnd]="$VV";
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpEnd];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}
				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpStart];
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}

				my $Diff=1;
				if ($NumGradien>1)
				{
					$Diff=($EndCountBin-$StartCountBin)/($NumGradien-1);
					if ($Diff==0) {$Diff=1;}
				}
				foreach my $k ($StartCountBin..$EndCountBin)
				{			
					my $VV=$ValueArry[$k];
					my $KKey=int(($k-$StartCountBin)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					$ArryValue[$KKey]||="$VV";
				}
			}
		}
		elsif  ($ValueCount==2)
		{
			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
			$VV=$ValueArry[1];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crMid"};$ArryCol[1]=$HashConfi{$Level}{"crMid"}; $ArryValue[1]=$VV;
			$VV=$ValueArry[2];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[2]=$HashConfi{$Level}{"crEnd"}; $ArryValue[2]=$VV;
			$MaxCol=2;
		}
		elsif ($ValueCount < 2)
		{
			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
			if ($ValueCount==0) {$ValueArry[1]=$ValueArry[0];}
			$VV=$ValueArry[1]; 
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[1]=$HashConfi{$Level}{"crEnd"}; $ArryValue[1]=$VV;
			$MaxCol=1;
		}
		elsif ($ValueCount< $HashConfi{$Level}{"Gradien"})
		{

			my $Atmp=int($ValueCount/2);
			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV}) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
			$VV=$ValueArry[$Atmp];
			if (exists $Value2SelfCol{$VV}) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crMid"};$ArryCol[$Atmp]=$HashConfi{$Level}{"crMid"}; $ArryValue[$Atmp]=$VV;
			$VV=$ValueArry[$ValueCount];
			if (exists $Value2SelfCol{$VV}) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
			$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[$ValueCount]=$HashConfi{$Level}{"crEnd"}; $ArryValue[$ValueCount]=$VV;

			my @StartRGB;
			($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
			my @EndRGB;
			($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
			my @MidRGB;
			($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});


			my $MidNumGradien=$Atmp; my $Btmp=$Atmp-1;
			foreach my $k (1..$Btmp)
			{
				my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
				my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
				my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
				$VV=$ValueArry[$k];   $hashValue2Col{$VV}="rgb($RR,$GG,$BB)";
				$ArryCol[$k]="rgb($RR,$GG,$BB)";  $ArryValue[$k]=$VV;
				if (exists $Value2SelfCol{$VV} )
				{
					$hashValue2Col{$VV}=$Value2SelfCol{$VV};
					$ArryCol[$k]=$Value2SelfCol{$VV};
				}
			}
			$Btmp=$Atmp+1;  my $Ctmp=$ValueCount-1;

			foreach my $k ($Btmp..$Ctmp)
			{
				my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$Atmp)*1.0/$MidNumGradien);
				my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$Atmp)*1.0/$MidNumGradien);
				my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$Atmp)*1.0/$MidNumGradien);
				$VV=$ValueArry[$k];   $hashValue2Col{$VV}="rgb($RR,$GG,$BB)";
				$ArryCol[$k]="rgb($RR,$GG,$BB)";  $ArryValue[$k]=$VV;
				if (exists $Value2SelfCol{$VV} )
				{
					$hashValue2Col{$VV}=$Value2SelfCol{$VV};
					$ArryCol[$k]=$Value2SelfCol{$VV};				
				}
			}
			$MaxCol=$ValueCount;
		}
		else
		{

			my $NumGradien=$HashConfi{$Level}{"Gradien"};
			$MaxCol=$NumGradien-1;
			my $MidNumGradien=int($MaxCol/2);


			my $VV=$ValueArry[0];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
			$VV=$ValueArry[$MidNumGradien];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
			$VV=$ValueArry[$MaxCol];
			if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}



			my @StartRGB;
			($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
			my @EndRGB;
			($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
			my @MidRGB;
			($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

			foreach my $k (0..$MidNumGradien)
			{
				my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
				my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
				my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
				$ArryCol[$k]="rgb($RR,$GG,$BB)";
			}
			my $MidNumGradienBB=$MidNumGradien+1;
			$NumGradien--;
			foreach my $k ($MidNumGradienBB..$NumGradien)
			{
				my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
				my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
				my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
				$ArryCol[$k]="rgb($RR,$GG,$BB)";
			}
			$ArryCol[$NumGradien+1]=$HashConfi{$Level}{"crEnd"};


			if ($HashConfi{$Level}{"IsNumber"}==1)
			{
				my $ShiftTmpEnd=$NumGradien;
				if ($EndCountBin< $ValueCount)
				{
					my $VV=$ValueArry[$EndCountBin];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[$NumGradien]=">$VV";
					my $tttEnd=$EndCountBin+1;
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}

				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$VV=sprintf ($Precision,$VV*1.0);
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}


				my $Diff=($MaxCutValue-$MinCutValue)/($NumGradien+1);
				if ($Diff==0) {$Diff=1;}
				foreach my $k ($StartCountBin..$EndCountBin)
				{
					my $VV=$ValueArry[$k];
					my $KKey=int(($VV-$MinCutValue)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				my $Shift=$ShiftTmpStart;	
				foreach my $k ($ShiftTmpStart..$ShiftTmpEnd)
				{
					my $MinAA=$MinCutValue+($k-$Shift)*$Diff;
					$MinAA=sprintf ($Precision,$MinAA*1.0);
					$ArryValue[$k]="$MinAA";
				}
			}
			else
			{
				my $ShiftTmpEnd=$NumGradien;
				if ($EndCountBin< $ValueCount)
				{
					my $VV=$ValueArry[$EndCountBin];
					$ArryValue[$NumGradien]=">$VV";
					my $tttEnd=$EndCountBin+1;
					foreach my $k ($tttEnd..$ValueCount)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpEnd--;
				}

				my $ShiftTmpStart=0;
				if ($StartCountBin>0)
				{
					my $VV=$ValueArry[$StartCountBin];
					$ArryValue[0]="<$VV";
					my $tttEnd=$StartCountBin-1;
					foreach my $k (0..$tttEnd)
					{
						my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};
						if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					}
					$NumGradien--;
					$ShiftTmpStart=1;
				}

				my $Diff=($EndCountBin-$StartCountBin)/($NumGradien);
				if ($Diff==0) {$Diff=1;}
				foreach my $k ($StartCountBin..$EndCountBin)
				{
					my $VV=$ValueArry[$k];
					my $KKey=int(($k-$StartCountBin)/$Diff)+$ShiftTmpStart;
					$hashValue2Col{$VV}= $ArryCol[$KKey];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
					$ArryValue[$KKey]||="$VV";
				}
			}
		}









		if (%Value2SelfCol)
		{
			my @TmpCol=keys %Value2SelfCol;
			if ($#TmpCol >=$ValueCount)
			{
				foreach my $yy (0..$MaxCol)
				{
					my $cc=$ArryValue[$yy];
					if  (exists $Value2SelfCol{$cc}) { $ArryCol[$yy]=$Value2SelfCol{$cc};}
				}
			}
		}






		my $LevelCorGra=$HashConfi{$Level}{"SizeGradienRatio"}*$CorGra;
		my $NumPlotArry=$#$PlotInfo+1;





		#################### Start  Plot ########
		if (($HashConfi{$Level}{"PType"}  eq  "heatmap")   ||  ($HashConfi{$Level}{"PType"}  eq  "highlights"))
		{
			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
			$XX2=$XX1+$LevelCorGra;

			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill' =>'none',
						'stroke'         => 'black',
						'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => "$ArryCol[$k]",
							'stroke'         => 'black',
							'stroke-width'   =>  0,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);		
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}


			my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};

			foreach my $tmpkk (1..$NumPlotArry) 
			{
				my $ThisBoxbin=$tmpkk-1;
				my $NowPlot=$PlotInfo->[$ThisBoxbin];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				my $StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}

				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");

					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}



					next if (!exists $hashYY1{$ThisChrName} ) ;

					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}
					my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
					my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
					my $binYYHeat=($YY2-$YY1)/$NumPlotArry;
					$YY1=$YY1+$ThisBoxbin*$binYYHeat;
					$YY2=$YY1+$binYYHeat;
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');
					$svg->polygon(
						%$path,
						style => {
							'fill'           => $hashValue2Col{$Value},
							'stroke'         => $hashValue2Col{$Value},
							'stroke-width'   => $HeatMapstrokewidth,
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}
			}
		}
		elsif (( $HashConfi{$Level}{"PType"}  eq  "pairwiselink" )  || ( $HashConfi{$Level}{"PType"}  eq  "PairWiseLink" ))
		{
			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
			$XX2=$XX1+$LevelCorGra;
			my %hashHHC=();
			my $HH=($HashConfi{$Level}{"ChrWidth"});
			my $HHbinS=$HH/($MaxCol+1);
			$hashHHC{$HashConfi{$Level}{"crEnd"}}=$MaxCol;
			$hashHHC{$HashConfi{$Level}{"crBegin"}}=0;

			foreach my $k (0..$MaxCol)
			{
				$hashHHC{$ArryCol[$k]}=($k+1)*$HHbinS;
				my $HTML=RGB2HTML($ArryCol[$k]);
				$hashHHC{$HTML}=($k+1)*$HHbinS;
				if ((exists ($HashConfi{$Level}{"SameHigh"}))   &&  ($HashConfi{$Level}{"SameHigh"}!=0) )
				{
					$hashHHC{$ArryCol[$k]}=$HH;
					$hashHHC{$HTML}=$HH;
				}
			}





			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill' =>'none',
						'stroke'         => 'black',
						'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);

				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => "$ArryCol[$k]",
							'stroke'         => 'black',
							'stroke-width'   =>  0,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}

			my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};

			foreach my $tmpkk (1..$NumPlotArry) 
			{
				my $ThisBoxbin=$tmpkk-1;
				my $NowPlot=$PlotInfo->[$ThisBoxbin];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				my $StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}


				if ( (exists ($HashConfi{$Level}{"lineType"}))   &&  ( $HashConfi{$Level}{"lineType"} eq "line") )
				{
					if ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUp" ))
					{
						for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
						{
							my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
							next if  ($Value eq "NA");

							my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

							$LevelV2=$FileData[$FileNow][$StartCount][0];
							if (exists $GenomeFlag{$LevelV2})
							{
								$LevelV2=~s/Ref//g;
								$ThisChrName=$FileData[$FileNow][$StartCount][1];
								$StartSite=$FileData[$FileNow][$StartCount][2];
								$EndSite=$FileData[$FileNow][$StartCount][3];
							}
							else
							{
								if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
								{
									$ThisChrName=$LevelV2;
									$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
									$StartSite=$FileData[$FileNow][$StartCount][1];
									$EndSite=$FileData[$FileNow][$StartCount][2];
								}
								elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
								{
									print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
								}
							}


							next if (!exists $hashYY1{$ThisChrName} ) ;
							if (exists $ReverseChr{$ThisChrName})
							{
								my $TS=$ReverseChr{$ThisChrName}-$EndSite;
								my $TE=$ReverseChr{$ThisChrName}-$StartSite;
								$StartSite=$TS;
								$EndSite=$TE;
							}

							my $YY1=$hashYY1{$ThisChrName}{$Level};
							my $YY2=$hashYY2{$ThisChrName}{$Level};
							my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
							my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
							if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
							$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						}
					}
					else
					{
						for ( ;$StartCount<$FileRow[$FileNow]; $StartCount++)
						{
							my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
							next if  ($Value eq "NA");

							my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

							$LevelV2=$FileData[$FileNow][$StartCount][0];
							if (exists $GenomeFlag{$LevelV2})
							{
								$LevelV2=~s/Ref//g;
								$ThisChrName=$FileData[$FileNow][$StartCount][1];
								$StartSite=$FileData[$FileNow][$StartCount][2];
								$EndSite=$FileData[$FileNow][$StartCount][3];
							}
							else
							{
								if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
								{
									$ThisChrName=$LevelV2;
									$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
									$StartSite=$FileData[$FileNow][$StartCount][1];
									$EndSite=$FileData[$FileNow][$StartCount][2];
								}
								elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
								{
									print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
								}
							}



							next if (!exists $hashYY1{$ThisChrName} ) ;
							if (exists $ReverseChr{$ThisChrName})
							{
								my $TS=$ReverseChr{$ThisChrName}-$EndSite;
								my $TE=$ReverseChr{$ThisChrName}-$StartSite;
								$StartSite=$TS;
								$EndSite=$TE;
							}

							my $YY1=$hashYY1{$ThisChrName}{$Level};
							my $YY2=$hashYY2{$ThisChrName}{$Level};
							my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
							my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
							if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
							$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value});
						}
					}
				}


				elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"}  eq "DownDown" ) )
				{
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");

						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}




						next if (!exists $hashYY1{$ThisChrName} ) ;
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}

						my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
						my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
						my $Q1_X=($XX1+$XX2)*0.5;
						my $Q1_Y=$YY2-2*$hashHHC{$hashValue2Col{$Value}};
						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
						if ( $XX1 ==  $XX2 )
						{
							$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY2-$hashHHC{$hashValue2Col{$Value}} , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
							next ;
						}

						$svg->path(
							'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,  $XX2 $YY2 ",
							style => {
								'fill'           =>  'none',
								'stroke'         =>  $hashValue2Col{$Value},
								'stroke-width'   =>  $HeatMapstrokewidth,
								'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
								'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
							},
						);
					}
				}









				elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "UpDownV2" ))
				{
					my $MidHH=$HashConfi{$Level}{"ChrWidth"};
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");



						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}








						next if (!exists $hashYY1{$ThisChrName} ) ;
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}




						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

						if ( $XX1 ==  $XX2 )
						{
							$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
							next ;
						}

						my $M1_X=($XX1+$XX2)*0.5;
						my $M1_Y=($YY1+$YY2)*0.5;

						my $kk=($XX2-$M1_X)*0.4/$MidHH;
						my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
						my $Q1_Y=($YY1+$M1_Y)*0.5;
						$svg->path(
							'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY2  ",
							style => {
								'fill'           =>  'none',
								'stroke'         =>  $hashValue2Col{$Value},
								'stroke-width'   =>  $HeatMapstrokewidth,
								'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
								'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
							},
						);
					}


				}
				elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "UpDown") )
				{
					my $MidHH=$HashConfi{$Level}{"ChrWidth"};
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");


						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}









						next if (!exists $hashYY1{$ThisChrName} ) ;
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

						if ( $XX1 ==  $XX2 )
						{
							$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
							next ;
						}

						my $M1_X=($XX1+$XX2)*0.5;
						my $M1_Y=($YY1+$YY2)*0.5;

						my $kk=($XX1-$M1_X)*0.4/$MidHH;
						my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
						my $Q1_Y=($YY1+$M1_Y)*0.5;
						$svg->path(
							'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY2  ",
							style => {
								'fill'           =>  'none',
								'stroke'         =>  $hashValue2Col{$Value},
								'stroke-width'   =>  $HeatMapstrokewidth,
								'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
								'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
							},
						);
					}
				}

				elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUpV2" ))
				{
					my $MidHH=$HashConfi{$Level}{"ChrWidth"};
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");


						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}





						next if (!exists $hashYY1{$ThisChrName} ) ;
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}

						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

						if ( $XX1 ==  $XX2 )
						{
							$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
							next ;
						}

						my $M1_X=($XX1+$XX2)*0.5;
						my $M1_Y=($YY1+$YY2)*0.5;

						my $kk=($XX2-$M1_X)*0.4/$MidHH;
						my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
						my $Q1_Y=($YY1+$M1_Y)*0.5;
						$svg->path(
							'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY1  ",
							style => {
								'fill'           =>  'none',
								'stroke'         =>  $hashValue2Col{$Value},
								'stroke-width'   =>  $HeatMapstrokewidth,
								'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
								'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
							},
						);
					}


				}
				elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUp") )
				{
					my $MidHH=$HashConfi{$Level}{"ChrWidth"};
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");


						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}




						next if (!exists $hashYY1{$ThisChrName} ) ;
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}

						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

						if ( $XX1 ==  $XX2 )
						{
							$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
							next ;
						}

						my $M1_X=($XX1+$XX2)*0.5;
						my $M1_Y=($YY1+$YY2)*0.5;


						my $kk=($XX2-$M1_X)*0.4/$MidHH;
						my $Q1_X=($XX1+$M1_X)*0.5-$MidHH*$kk;
						my $Q1_Y=($YY1+$M1_Y)*0.5;
						$svg->path(
							'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY1  ",
							style => {
								'fill'           =>  'none',
								'stroke'         =>  $hashValue2Col{$Value},
								'stroke-width'   =>  $HeatMapstrokewidth,
								'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
								'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
							},
						);


					}
				}







				else
				{

					for (; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");


						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}





						next if (!exists $hashYY1{$ThisChrName} ) ;
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}

						my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
						my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
						my $Q1_X=($XX1+$XX2)*0.5;
						my $Q1_Y=$YY1+2*$hashHHC{$hashValue2Col{$Value}};
						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
						if ($XX1 ==  $XX2 )
						{
							$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY1+$hashHHC{$hashValue2Col{$Value}} , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
							next ;
						}

						$svg->path(
							'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,  $XX2 $YY1 ",
							style => {
								'fill'           =>  'none',
								'stroke'         =>  $hashValue2Col{$Value},
								'stroke-width'   =>  $HeatMapstrokewidth,
								'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
								'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
							},
						);
					}



				}
			}








		}
		elsif (( $HashConfi{$Level}{"PType"}  eq  "histogram" )  || ( $HashConfi{$Level}{"PType"}  eq  "hist" ))
		{
			if ($NumPlotArry>2)
			{
				print "Error:\tFor -PType histogram  on Level [$Level] only One/two Plot,you can modify to add the Level for it or change the -PType\n";
				for (my $i=0; $i<$NumPlotArry; $i++)
				{
					my $NowPlot=$PlotInfo->[$i];
					print "\t\tFile$NowPlot->[0]\tCoumn$NowPlot->[1]\n";
				}
				exit;
			}

			if ($NumPlotArry==2)
			{
				$ArryCol[1]=$ArryCol[$MaxCol];
				$MaxCol=1;
				my $NowPlot=$PlotInfo->[0];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				$ArryValue[0]="U:$FileData[$FileNow][0][$CoumnNow]";
				$NowPlot=$PlotInfo->[1];
				$FileNow=$NowPlot->[0];
				$CoumnNow=$NowPlot->[1];
				$ArryValue[1]="D:$FileData[$FileNow][0][$CoumnNow]";
			}
			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
			$XX2=$XX1+$LevelCorGra;

			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill' =>'none',
						'stroke'         => 'black',
						'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => "$ArryCol[$k]",
							'stroke'         => 'black',
							'stroke-width'   =>  0,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);  
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}

			my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
			my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
			if ($NumPlotArry==1)
			{
				if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
				{
					my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
					my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
					my $countTmpChr=$#ChrArry;
					if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
					{
						$countTmpChr=0;
					}
					foreach my $thisChr (0..$countTmpChr)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
						my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
						my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
						$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
						$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);

					}
				}


				my $NowPlot=$PlotInfo->[0];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				my $StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}

				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");

					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}




					next if (!exists $hashYY1{$ThisChrName} ) ;
					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}

					my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
					my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
					$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');
					$svg->polygon(
						%$path,
						style => {
							'fill'           => $hashValue2Col{$Value},
							'stroke'         => $hashValue2Col{$Value},
							'stroke-width'   => $HHstrokewidth,
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}

			}
			else
			{

				if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
				{
					my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
					my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
					my $countTmpChr=$#ChrArry;
					if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
					{
						$countTmpChr=0;
					}
					foreach my $thisChr (0..$countTmpChr)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
						my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
						my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
						$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
						$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
						$svg->text('text-anchor','middle','x',$XX2,'y',($YY2+$YY1)/2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					}
				}
				my $NowPlot=$PlotInfo->[0];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				my $StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");


					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}






					next if (!exists $hashYY1{$ThisChrName} ) ;
					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}

					my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
					my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
					$YY2=($YY1+$YY2)/2;
					$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');
					$svg->polygon(
						%$path,
						style => {
							'fill'           => $ArryCol[0],
							'stroke'         => $ArryCol[0],
							'stroke-width'   => $HHstrokewidth,
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}



				$NowPlot=$PlotInfo->[1];
				$FileNow=$NowPlot->[0];
				$CoumnNow=$NowPlot->[1];
				$StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");	

					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}



					next if (!exists $hashYY1{$ThisChrName} ) ;
					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}

					my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
					my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
					$YY1=($YY1+$YY2)/2;
					$YY2=$YY1+($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');
					$svg->polygon(
						%$path,
						style => {
							'fill'           => $ArryCol[1],
							'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
							'stroke'         => $ArryCol[1],
							'stroke-width'   => $HHstrokewidth,
							'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						},
					);
				}


			}

			if (exists $HashConfi{$Level}{"Cutline"}  )
			{
				my $Value=$HashConfi{$Level}{"Cutline"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline1"}  )
			{
				my $Value=$HashConfi{$Level}{"Cutline1"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}
			if (exists $HashConfi{$Level}{"Cutline2"}  )
			{
				my $Value=$HashConfi{$Level}{"Cutline2"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}




		}
		elsif (($HashConfi{$Level}{"PType"}  eq  "scatter" )  || ( $HashConfi{$Level}{"PType"}  eq  "point" ) || ( $HashConfi{$Level}{"PType"}  eq  "points" ))
		{

			my $cirsize=$LevelCorGra/12;
			if  ( (exists $HashConfi{$Level}{"CirsizeRatio"} )  && ( $HashConfi{$Level}{"CirsizeRatio"} >0 ) )
			{
				$cirsize=$cirsize*$HashConfi{$Level}{"CirsizeRatio"};
			}
			my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};

			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}	


			if ($NumPlotArry==1)
			{

				$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra*($MaxCol+1);
				$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.8+$HashConfi{$Level}{"ShiftGradienX"};
				$XX2=$XX1+$LevelCorGra;

				if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
				{

				}
				else
				{
					foreach my $k (0..$MaxCol)
					{
						$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
						$YY2=$YY1+$LevelCorGra;
						$svg->circle(cx=>$XX1, cy=>$YY2, r=>$cirsize*5, fill => "$ArryCol[$k]");
						$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
					}
				}

				my $NowPlot=$PlotInfo->[0];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				my $StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}
				my %Uniq=();
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");

					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}


					next if (!exists $hashYY1{$ThisChrName});
					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}
					my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
					my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
					$YY1=sprintf("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
					my $key=$XX1."_".$YY1;
					next if (exists $Uniq{$key});
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$svg->circle(cx=>$XX1, cy=>$YY1, r=>$cirsize, fill => "$hashValue2Col{$Value}" );
					$Uniq{$key}=1;
				}
			}
			else
			{
				my $NumGradien=$NumPlotArry;
				if (! exists $HashConfi{$Level}{"ColorBrewer"} )
				{			
					my @StartRGB;
					($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
					my @EndRGB;
					($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
					my @MidRGB;
					($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

					my $MidNumGradien=int($NumGradien/2);
					foreach my $k (0..$MidNumGradien)
					{
						my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
						my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
						my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
					my $MidNumGradienBB=$MidNumGradien+1;
					$NumGradien--;
					foreach my $k ($MidNumGradienBB..$NumGradien)
					{
						my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
					$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
					if ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
				}
				else
				{
					@ArryCol=();
					my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
					GetColGradien($ColFlag,$NumGradien,\@ArryCol);
					if (exists  $HashConfi{$Level}{"ReverseColor"})
					{
						my @cccTmpCor=();
						foreach my $k (0..$#ArryCol)
						{
							my $Tho=$#ArryCol-$k;
							$cccTmpCor[$Tho]=$ArryCol[$k];
						}
						foreach my $k (0..$#ArryCol)
						{
							$ArryCol[$k]=$cccTmpCor[$k];
						}
					}

				}


				foreach my $k (1..$NumPlotArry)
				{
					my	$NowPlot=$PlotInfo->[$k-1];
					my  $FileNow=$NowPlot->[0];
					my	$CoumnNow=$NowPlot->[1];
					my  $StartCount=0;
					$ArryValue[$k-1]="$FileData[$FileNow][0][$CoumnNow]";


					$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
					$XX2=$XX1+$LevelCorGra;
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*($k-1)+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;
					if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
					{

					}
					else
					{
						$svg->circle(cx=>$XX1, cy=>$YY1, r=>$cirsize*5, fill => "$ArryCol[$k-1]" );
						$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k-1])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k-1]",'font-family','Arial','font-size',$LevelCorGra);
					}


					if  ($FileData[$FileNow][0][0] =~s/#/#/) 
					{
						$StartCount=1;
					}

					my %Uniq=();
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");
						my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

						$LevelV2=$FileData[$FileNow][$StartCount][0];
						if (exists $GenomeFlag{$LevelV2})
						{
							$LevelV2=~s/Ref//g;
							$ThisChrName=$FileData[$FileNow][$StartCount][1];
							$StartSite=$FileData[$FileNow][$StartCount][2];
							$EndSite=$FileData[$FileNow][$StartCount][3];
						}
						else
						{
							if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								$ThisChrName=$LevelV2;
								$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
								$StartSite=$FileData[$FileNow][$StartCount][1];
								$EndSite=$FileData[$FileNow][$StartCount][2];
							}
							elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
							{
								print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
							}
						}


						next if (!exists $hashYY1{$ThisChrName} ) ;	
						if (exists $ReverseChr{$ThisChrName})
						{
							my $TS=$ReverseChr{$ThisChrName}-$EndSite;
							my $TE=$ReverseChr{$ThisChrName}-$StartSite;
							$StartSite=$TS;
							$EndSite=$TE;
						}

						my $YY1=$hashYY1{$ThisChrName}{$LevelV2};
						my $YY2=$hashYY2{$ThisChrName}{$LevelV2};
						$YY1= sprintf("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
						my $key=$XX1."_".$YY1;
						next if (exists $Uniq{$key});
						$svg->circle(cx=>$XX1, cy=>$YY1, r=>$cirsize, fill => "$ArryCol[$k-1]");
						$Uniq{$key}=1;
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline"})
			{
				my $Value=$HashConfi{$Level}{"Cutline"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline1"})
			{
				my $Value=$HashConfi{$Level}{"Cutline1"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline2"})
			{
				my $Value=$HashConfi{$Level}{"Cutline2"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}




		}
		elsif (($HashConfi{$Level}{"PType"}  eq  "shape" )  || ( $HashConfi{$Level}{"PType"}  eq  "shapes" ) || ( $HashConfi{$Level}{"PType"}  eq  "Shape" ))
		{

			my $cirsize=$LevelCorGra/12;
			if  ( (exists $HashConfi{$Level}{"CirsizeRatio"} )  && ( $HashConfi{$Level}{"CirsizeRatio"} >0 ) )
			{
				$cirsize=$cirsize*$HashConfi{$Level}{"CirsizeRatio"};
			}
			if  ( (exists $HashConfi{$Level}{"ShapesizeRatio"} )  && ( $HashConfi{$Level}{"ShapesizeRatio"} >0 ) )
			{
				$cirsize=$cirsize*$HashConfi{$Level}{"ShapesizeRatio"};
			}
			my $MaxDiffValue=1;
			if ($HashConfi{$Level}{"IsNumber"}==1 )
			{
				$MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
			}

			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical")
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}

			if ($NumPlotArry==1)
			{
				$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra*($MaxCol+1);
				$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.8+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
				$XX2=$XX1+$LevelCorGra;
				my @shapeType=();
				foreach my $k (0..$MaxCol)
				{
					my $Type= $k % 14;
					$shapeType[$k]=$Type;
				}
				if (exists $HashConfi{$Level}{"ShapeType"} )
				{
					my  @ccc=split/\,/,$HashConfi{$Level}{"ShapeType"};
					foreach my $k (0..$#ccc)
					{
						if ($ccc[$k]<14)
						{				
							$shapeType[$k]=$ccc[$k];
						}
					}
				}
				my %Col2Shape=();
				if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
				{
					foreach my $k (0..$MaxCol)
					{
						$Col2Shape{"$ArryCol[$k]"}=$shapeType[$k];
					}
				}
				else
				{
					foreach my $k (0..$MaxCol)
					{
						$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
						$YY2=$YY1+$LevelCorGra;
						SVGgetShape($XX1,$YY2-$LevelCorGra*0.5,$LevelCorGra*0.5,$shapeType[$k],$ArryCol[$k],$svg);
						$Col2Shape{"$ArryCol[$k]"}=$shapeType[$k];
						$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
					}
				}


				my $NowPlot=$PlotInfo->[0];
				my $FileNow=$NowPlot->[0];
				my $CoumnNow=$NowPlot->[1];
				my $StartCount=0;
				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}
				my %Uniq=();
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");	
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;	
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					if ($HashConfi{$Level}{"IsNumber"}==1 )
					{
						$YY1=sprintf ("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
					}
					else
					{
						$YY1=($YY1+$YY2)*0.5;
					}
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $shapeT=$Col2Shape{$hashValue2Col{$Value}};
					my $key=$XX1."_".$YY1."_$shapeT";
					next if (exists $Uniq{$key});
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					SVGgetShape($XX1,$YY1,$cirsize,$shapeT,$hashValue2Col{$Value},$svg);
					$Uniq{$key}=1;
				}
			}
			else
			{			
				my $NumGradien=$NumPlotArry;

				if (! exists $HashConfi{$Level}{"ColorBrewer"} )
				{			
					my @StartRGB;
					($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
					my @EndRGB;
					($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
					my @MidRGB;
					($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

					my $MidNumGradien=int($NumGradien/2);
					foreach my $k (0..$MidNumGradien)
					{
						my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
						my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
						my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
					my $MidNumGradienBB=$MidNumGradien+1;
					$NumGradien--;
					foreach my $k ($MidNumGradienBB..$NumGradien)
					{
						my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
					$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
					if ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
				}
				else
				{
					@ArryCol=();
					my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
					GetColGradien($ColFlag,$NumGradien,\@ArryCol);
					if (exists  $HashConfi{$Level}{"ReverseColor"})
					{
						my @cccTmpCor=();
						foreach my $k (0..$#ArryCol)
						{
							my $Tho=$#ArryCol-$k;
							$cccTmpCor[$Tho]=$ArryCol[$k];
						}
						foreach my $k (0..$#ArryCol)
						{
							$ArryCol[$k]=$cccTmpCor[$k];
						}
					}
				}


				my @shapeType=();
				foreach my $kk (1..$NumPlotArry)
				{
					my $k=$kk-1;
					my $Type= $k % 14;
					$shapeType[$k]=$Type;
				}

				if (exists $HashConfi{$Level}{"ShapeType"} )
				{
					my  @ccc=split/\,/,$HashConfi{$Level}{"ShapeType"};
					foreach my $k (0..$#ccc)
					{
						if ($ccc[$k]<14)
						{				
							$shapeType[$k]=$ccc[$k];
						}
					}
				}

				foreach my $k (1..$NumPlotArry)
				{
					my	$NowPlot=$PlotInfo->[$k-1];
					my  $FileNow=$NowPlot->[0];
					my	$CoumnNow=$NowPlot->[1];
					my  $StartCount=0;
					my  $shapeT=$shapeType[$k-1];
					$ArryValue[$k-1]="$FileData[$FileNow][0][$CoumnNow]";

					$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
					$XX2=$XX1+$LevelCorGra;
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*($k-1)+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;
					if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
					{

					}
					else
					{
						SVGgetShape($XX1,$YY2-$LevelCorGra*0.5,$LevelCorGra*0.5,$shapeT,$ArryCol[$k-1],$svg);
						$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k-1])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k-1]",'font-family','Arial','font-size',$LevelCorGra);
					}


					if  ($FileData[$FileNow][0][0] =~s/#/#/) 
					{
						$StartCount=1;
					}
					my %Uniq=();
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");	
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $hashYY1{$ThisChrName} ) ;	
						my $StartSite=$FileData[$FileNow][$StartCount][1];
						my $EndSite=$FileData[$FileNow][$StartCount][2];
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						if ($HashConfi{$Level}{"IsNumber"}==1 )
						{
							$YY1=sprintf ("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
						}
						else
						{
							$YY1=($YY1+$YY2)*0.5;
						}
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $key=$XX1."_".$YY1."_$shapeT";
						next if (exists $Uniq{$key});
						SVGgetShape($XX1,$YY1,$cirsize,$shapeT,$ArryCol[$k-1],$svg);
						$Uniq{$key}=1;
					}
				}
			}


			if (exists $HashConfi{$Level}{"Cutline"})
			{
				my $Value=$HashConfi{$Level}{"Cutline"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}

					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}
			if (exists $HashConfi{$Level}{"Cutline1"})
			{
				my $Value=$HashConfi{$Level}{"Cutline1"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}

					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline2"})
			{
				my $Value=$HashConfi{$Level}{"Cutline2"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}

					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}




		}
		elsif (	($HashConfi{$Level}{"PType"}  eq  "text" )	  )
		{

			if ($NumPlotArry>1)
			{
				print "Error:\tFor -PType txt  one Level [$Level] only One Plot,you can modify to add the Level for it or change the -PType\n";
				for (my $i=0; $i<$NumPlotArry; $i++)
				{
					my $NowPlot=$PlotInfo->[$i];
					print "\t\tFile$NowPlot->[0]\tCoumn$NowPlot->[1]\n";
				}
				exit;
			}

			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
			$XX2=$XX1+$LevelCorGra;
			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{
			}
			else
			{
				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;
					$svg->text('text-anchor','middle','x',$XX1+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra,'stroke',$ArryCol[$k]);
				}
			}



			my $NowPlot=$PlotInfo->[0];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/)
			{
				$StartCount=1;
			}
			my $text_font_size=$fontsize*0.5;
			if (exists $HashConfi{$Level}{"text-font-size"})
			{
				$text_font_size=$HashConfi{$Level}{"text-font-size"};
			}
			if (exists $HashConfi{$Level}{"TextFontRatio"})
			{
				$text_font_size=$text_font_size*$HashConfi{$Level}{"TextFontRatio"};
			}
			my $TextAnchor="middle"; 
			if (exists $HashConfi{$Level}{"TextAnchor"})
			{
				$TextAnchor=$HashConfi{$Level}{"TextAnchor"};
			}

			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

				$LevelV2=$FileData[$FileNow][$StartCount][0];
				if (exists $GenomeFlag{$LevelV2})
				{
					$LevelV2=~s/Ref//g;
					$ThisChrName=$FileData[$FileNow][$StartCount][1];
					$StartSite=$FileData[$FileNow][$StartCount][2];
					$EndSite=$FileData[$FileNow][$StartCount][3];
				}
				else
				{
					if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
					{
						$ThisChrName=$LevelV2;
						$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
						$StartSite=$FileData[$FileNow][$StartCount][1];
						$EndSite=$FileData[$FileNow][$StartCount][2];
					}
					elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
					{
						print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
					}
				}



				next if (!exists $hashYY1{$ThisChrName} ) ;
				if (exists $ReverseChr{$ThisChrName})
				{
					my $TS=$ReverseChr{$ThisChrName}-$EndSite;
					my $TE=$ReverseChr{$ThisChrName}-$StartSite;
					$StartSite=$TS;
					$EndSite=$TE;
				}


				$YY1=$hashYY1{$ThisChrName}{$LevelV2};
				$YY2=$hashYY2{$ThisChrName}{$LevelV2};
				$XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

				if ($HashConfi{$Level}{"Rotate"}!=0) 
				{		
					my $Rotate=$HashConfi{$Level}{"Rotate"};
					$YY1=$YY1+($YY2-$YY1)*3/5;
					$svg->text('text-anchor',$TextAnchor,'x',$XX1,'y',$YY1,'-cdata',"$Value",'fill',$hashValue2Col{$Value},'font-family',$HashConfi{$Level}{"font-family"},'font-size',$text_font_size,'transform',"rotate($Rotate,$XX1,$YY1)");
				}
				else
				{
					$svg->text('text-anchor',$TextAnchor,'x',$XX1,'y',$YY2,'-cdata',"$Value",'fill',$hashValue2Col{$Value},'font-family',$HashConfi{$Level}{"font-family"},'font-size',$text_font_size);
				}
			}
		}
		elsif (( $HashConfi{$Level}{"PType"}  eq  "lines" )  || ( $HashConfi{$Level}{"PType"}  eq  "line" ))
		{

			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}	



			if ( !exists $HashConfi{$Level}{"ColorBrewer"})
			{
				my @StartRGB;
				($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
				my @EndRGB;
				($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
				my @MidRGB;
				($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});
				if  ($NumGradien!=1)
				{
					my $MidNumGradien=int($NumGradien/2);
					foreach my $k (0..$MidNumGradien)
					{
						my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
						my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
						my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
					my $MidNumGradienBB=$MidNumGradien+1;
					$NumGradien--;
					foreach my $k ($MidNumGradienBB..$NumGradien)
					{
						my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
				}
				else
				{
					$ArryCol[0]=$HashConfi{$Level}{"crBegin"};
				}
				$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
				if  ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
			}
			else
			{
				@ArryCol=();
				my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
				GetColGradien($ColFlag,$NumGradien,\@ArryCol);
				if  (exists  $HashConfi{$Level}{"ReverseColor"})
				{
					my @cccTmpCor=();
					foreach my $k (0..$#ArryCol)
					{
						my $Tho=$#ArryCol-$k;
						$cccTmpCor[$Tho]=$ArryCol[$k];
					}
					foreach my $k (0..$#ArryCol)
					{
						$ArryCol[$k]=$cccTmpCor[$k];
					}
				}
			}


			my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
			my $strokewidthV2=$HashConfi{"ALL"}{"strokewidth"}*0.88;
			if  (exists  $HashConfi{$Level}{"strokewidth"} ) {$strokewidthV2= $HashConfi{$Level}{"strokewidth"} ;}
			foreach my $tmpkk (1..$NumPlotArry)
			{
				my  $ThisBoxbin=$tmpkk-1;
				my	$NowPlot=$PlotInfo->[$ThisBoxbin];
				my  $FileNow=$NowPlot->[0];
				my	$CoumnNow=$NowPlot->[1];
				my  $StartCount=0;
				$ArryValue[$ThisBoxbin]="$FileData[$FileNow][0][$CoumnNow]";
				$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
				$XX2=$XX1+$LevelCorGra;
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$tmpkk+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;
				if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
				{

				}
				else
				{
					$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2',$YY2,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$HashConfi{"ALL"}{"strokewidth"});
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$ThisBoxbin])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$ThisBoxbin]",'font-family','Arial','font-size',$LevelCorGra);
				}



				if ($FileData[$FileNow][0][0] =~s/#/#/)
				{
					$StartCount=1;
				}
				my $FirstPoint=1;
				my $pointAX; 
				my $pointAY;
				my $ChrThisNow="NA";

				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{

					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					if ($Value eq "NA")
					{
						$FirstPoint=1;
						next;
					}

					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}



					next if (!exists $hashYY1{$ThisChrName} ) ;
					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}


					$YY1=$hashYY1{$ThisChrName}{$LevelV2};
					$YY2=$hashYY2{$ThisChrName}{$LevelV2};
					$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});

					if (($FirstPoint==1)   || ($ChrThisNow ne  $ThisChrName ) )
					{
						$pointAX=$XX1;
						$pointAY=$YY1;
						$ChrThisNow=$ThisChrName;
						$FirstPoint=0;
						next;
					}
					$svg->line('x1',$pointAX,'y1',$pointAY,'x2',$XX1,'y2',$YY1,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$strokewidthV2);
					$pointAX=$XX1;
					$pointAY=$YY1;
				}
			}
			if (exists $HashConfi{$Level}{"Cutline"})
			{
				my $Value=$HashConfi{$Level}{"Cutline"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline1"})
			{
				my $Value=$HashConfi{$Level}{"Cutline1"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}


			if (exists $HashConfi{$Level}{"Cutline2"})
			{
				my $Value=$HashConfi{$Level}{"Cutline2"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}







		}
		elsif (( $HashConfi{$Level}{"PType"}  eq  "ridgeline" ) )
		{

			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}	



			if ( !exists $HashConfi{$Level}{"ColorBrewer"})
			{
				my @StartRGB;
				($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
				my @EndRGB;
				($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
				my @MidRGB;
				($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});
				if  ($NumGradien!=1)
				{
					my $MidNumGradien=int($NumGradien/2);
					foreach my $k (0..$MidNumGradien)
					{
						my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
						my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
						my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
					my $MidNumGradienBB=$MidNumGradien+1;
					$NumGradien--;
					foreach my $k ($MidNumGradienBB..$NumGradien)
					{
						my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
						$ArryCol[$k]="rgb($RR,$GG,$BB)";
					}
				}
				else
				{
					$ArryCol[0]=$HashConfi{$Level}{"crBegin"};
				}
				$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
				if  ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
			}
			else
			{
				@ArryCol=();
				my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
				GetColGradien($ColFlag,$NumGradien,\@ArryCol);
				if  (exists  $HashConfi{$Level}{"ReverseColor"})
				{
					my @cccTmpCor=();
					foreach my $k (0..$#ArryCol)
					{
						my $Tho=$#ArryCol-$k;
						$cccTmpCor[$Tho]=$ArryCol[$k];
					}
					foreach my $k (0..$#ArryCol)
					{
						$ArryCol[$k]=$cccTmpCor[$k];
					}
				}
			}


			my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
			my $strokewidthV2=$HashConfi{"ALL"}{"strokewidth"}*0.88;
			if  (exists  $HashConfi{$Level}{"strokewidth"} ) {$strokewidthV2= $HashConfi{$Level}{"strokewidth"} ;}
			foreach my $tmpkk (1..$NumPlotArry)
			{
				my  $ThisBoxbin=$tmpkk-1;
				my	$NowPlot=$PlotInfo->[$ThisBoxbin];
				my  $FileNow=$NowPlot->[0];
				my	$CoumnNow=$NowPlot->[1];
				my  $StartCount=0;
				$ArryValue[$ThisBoxbin]="$FileData[$FileNow][0][$CoumnNow]";
				$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"};
				$XX2=$XX1+$LevelCorGra;
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$tmpkk+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;
				if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
				{

				}
				else
				{
					$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2',$YY2,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$HashConfi{"ALL"}{"strokewidth"});
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$ThisBoxbin])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$ThisBoxbin]",'font-family','Arial','font-size',$LevelCorGra);
				}



				if ($FileData[$FileNow][0][0] =~s/#/#/)
				{
					$StartCount=1;
				}
				my $FirstPoint=1;
				my $pointAX; 
				my $pointAY;
				my $ChrThisNow="NA";

				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{

					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					if ($Value eq "NA")
					{
						$FirstPoint=1;
						next;
					}

					my $ThisChrName="XXNAX";my $StartSite;my $EndSite;my $LevelV2;

					$LevelV2=$FileData[$FileNow][$StartCount][0];
					if (exists $GenomeFlag{$LevelV2})
					{
						$LevelV2=~s/Ref//g;
						$ThisChrName=$FileData[$FileNow][$StartCount][1];
						$StartSite=$FileData[$FileNow][$StartCount][2];
						$EndSite=$FileData[$FileNow][$StartCount][3];
					}
					else
					{
						if ( (!exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							$ThisChrName=$LevelV2;
							$LevelV2=$ChrName2DiffGenome{$ThisChrName} ;
							$StartSite=$FileData[$FileNow][$StartCount][1];
							$EndSite=$FileData[$FileNow][$StartCount][2];
						}
						elsif ( (exists $SameChrName{$LevelV2})  &&  ( exists $ChrName2DiffGenome{$LevelV2}) )
						{
							print "The chromosome name [$LevelV2] exists on both genomes Ref [$SameChrName{$LevelV2}], and it is impossible to distinguish which one, so skip this line\nYou can add Flag [RefX]  X=[$SameChrName{$LevelV2}] to the previous column of this row of data to distinguish\n";
						}
					}



					next if (!exists $hashYY1{$ThisChrName} ) ;
					if (exists $ReverseChr{$ThisChrName})
					{
						my $TS=$ReverseChr{$ThisChrName}-$EndSite;
						my $TE=$ReverseChr{$ThisChrName}-$StartSite;
						$StartSite=$TS;
						$EndSite=$TE;
					}


					$YY1=$hashYY1{$ThisChrName}{$LevelV2};
					$YY2=$hashYY2{$ThisChrName}{$LevelV2};
					$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$LevelV2});

					if (($FirstPoint==1)   || ($ChrThisNow ne  $ThisChrName ) )
					{
						$pointAX=$XX1;
						$pointAY=$YY1;
						$ChrThisNow=$ThisChrName;
						$FirstPoint=0;
						next;
					}
					$svg->line('x1',$pointAX,'y1',$pointAY,'x2',$XX1,'y2',$YY1,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$strokewidthV2);
					$path = $svg->get_path(
						x => [$pointAX, $XX1, $XX1,$pointAX],
						y => [$pointAY, $YY1, $YY2,$YY2],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill' =>$ArryCol[$ThisBoxbin],
							'stroke'         =>  $ArryCol[$ThisBoxbin],
							'stroke-width'   =>  $strokewidthV2,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);


					$pointAX=$XX1;
					$pointAY=$YY1;
				}
			}
			if (exists $HashConfi{$Level}{"Cutline"})
			{
				my $Value=$HashConfi{$Level}{"Cutline"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}

			if (exists $HashConfi{$Level}{"Cutline1"})
			{
				my $Value=$HashConfi{$Level}{"Cutline1"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}


			if (exists $HashConfi{$Level}{"Cutline2"})
			{
				my $Value=$HashConfi{$Level}{"Cutline2"};
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
				if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
				{
					my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
					my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
					foreach my $thisChr (0..$#ChrArry)
					{
						my $ThisChrName=$ChrArry[$thisChr];
						my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
						$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
					}
				}
			}







		}



		elsif (($HashConfi{$Level}{"PType"}  eq  "heatmapAnimated")   ||  ($HashConfi{$Level}{"PType"}  eq  "highlightsAnimated"))
		{
			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			$XX2=$XX1+$LevelCorGra;

			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill' =>'none',
						'stroke'         => 'black',
						'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);

				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => "$ArryCol[$k]",
							'stroke'         => 'black',
							'stroke-width'   =>  0,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}


			my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};


			my $ThisBoxbin;my $NowPlot;my $CoumnNow;my $FileNow;
			my $StartCount=0;
			my @NowPLotCoumn=();
			my $textDataLine="";
			my $textData="";
			foreach my $tmpkk (1..1)
			{
				$ThisBoxbin=$tmpkk-1;
				$NowPlot=$PlotInfo->[$ThisBoxbin];
				$FileNow=$NowPlot->[0];
				$CoumnNow=$NowPlot->[1];
				$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
				$textDataLine=$FileData[$FileNow][0][$CoumnNow];
			}

			foreach my $tmpkk (2..$NumPlotArry)
			{
				$ThisBoxbin=$tmpkk-1;
				$NowPlot=$PlotInfo->[$ThisBoxbin];
				$FileNow=$NowPlot->[0];
				$CoumnNow=$NowPlot->[1];
				$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
				$textData=$FileData[$FileNow][0][$CoumnNow];
				$textDataLine=$textDataLine.";".$textData;
			}

			if  ($FileData[$FileNow][0][0] =~s/#/#/)
			{
				$StartCount=1;
			}
			$YY2=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"}-$LevelCorGra*2;
			my $textLength=$LevelCorGra*$NumPlotArry;
			$svg->text('text-anchor','start','x',$XX1,'y',$YY2,'textlength',$textLength,'-cdata',$textDataLine,'font-family','Arial','font-size',$LevelCorGra);
			$svg->rect('x',$XX1,'y',$YY2,'width',$textLength,'height',$LevelCorGra,'fill',"grey");
			my $animateTxt=$svg->text('text-anchor','start','x',$XX1,'y',$YY2+$LevelCorGra,'-cdata',"Time",'font-family','Arial','font-size',$LevelCorGra);
			$XX2=$XX1+$textLength;
			$animateTxt->animate(attributeName=>"x",from=>$XX1,to=>$XX2,begin=>"0s",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			$hashValue2Col{"NA"}="white";


			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{

				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;				
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');


				my $Tag=$svg->polygon(
					%$path,
					style => {
						'fill'           => $hashValue2Col{$Value},
						'stroke'         => $hashValue2Col{$Value},
						'stroke-width'   => $HeatMapstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
					},
				);

				my $animateLine=$hashValue2Col{$Value};
				for (my $NowAA=$NumPlotArry-2;$NowAA>=0; $NowAA--)
				{
					$Value=$FileData[$FileNow][$StartCount][$NowPLotCoumn[$NowAA]];
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$animateLine=$hashValue2Col{$Value}.";".$animateLine;
				}
				$Tag->animate(attributeName=>"fill",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
				$Tag->animate(attributeName=>"stroke",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			}
		}
		elsif (( $HashConfi{$Level}{"PType"}  eq  "histogramAnimated" )  || ( $HashConfi{$Level}{"PType"}  eq  "histAnimated" ))
		{
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			my $ThisBoxbin;my $NowPlot;my $CoumnNow;my $FileNow;
			my $StartCount=0;
			my @NowPLotCoumn=();
			my $textDataLine="";
			my $textData="";
			foreach my $tmpkk (1..1)
			{
				$ThisBoxbin=$tmpkk-1;
				$NowPlot=$PlotInfo->[$ThisBoxbin];
				$FileNow=$NowPlot->[0];
				$CoumnNow=$NowPlot->[1];
				$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
				$textDataLine=$FileData[$FileNow][0][$CoumnNow];
			}

			foreach my $tmpkk (2..$NumPlotArry)
			{
				$ThisBoxbin=$tmpkk-1;
				$NowPlot=$PlotInfo->[$ThisBoxbin];
				$FileNow=$NowPlot->[0];
				$CoumnNow=$NowPlot->[1];
				$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
				$textData=$FileData[$FileNow][0][$CoumnNow];
				$textDataLine=$textDataLine.";".$textData;
			}

			if ($FileData[$FileNow][0][0] =~s/#/#/)
			{
				$StartCount=1;
			}


			$YY2=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"}-$LevelCorGra*2;

			my $textLength=$LevelCorGra*$NumPlotArry;
			$svg->text('text-anchor','start','x',$XX1,'y',$YY2,'textlength',$textLength,'-cdata',$textDataLine,'font-family','Arial','font-size',$LevelCorGra);
			$svg->rect('x',$XX1,'y',$YY2,'width',$textLength,'height',$LevelCorGra,'fill',"grey");
			my $animateTxt=$svg->text('text-anchor','start','x',$XX1,'y',$YY2+$LevelCorGra,'-cdata',"Time",'font-family','Arial','font-size',$LevelCorGra);
			$XX2=$XX1+$textLength;
			$animateTxt->animate(attributeName=>"x",from=>$XX1,to=>$XX2,begin=>"0s",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			$hashValue2Col{"NA"}="white";




			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			$XX2=$XX1+$LevelCorGra;

			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill' =>'none',
						'stroke'         => 'black',
						'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;

					$path = $svg->get_path(
						x => [$XX1, $XX1, $XX2,$XX2],
						y => [$YY1, $YY2, $YY2,$YY1],
						-type => 'polygon');

					$svg->polygon(
						%$path,
						style => {
							'fill'           => "$ArryCol[$k]",
							'stroke'         => 'black',
							'stroke-width'   =>  0,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);  
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}

			my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
			my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};


			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}





			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];

				my $YY1A=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				my $heightLL=0;
				if ($Value ne "NA") { $heightLL=($YY2-$YY1A)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;}
				my $YY1=$YY2-$heightLL;

				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $widthLL=$XX2-$XX1;
				my $Tag=$svg->rect('x',$XX1,'y',$YY2,'width',$widthLL,'height',$heightLL,'fill',$hashValue2Col{$Value},'stroke',$hashValue2Col{$Value},'stroke-width',$HHstrokewidth,'stroke-opacity', $HashConfi{$Level}{"stroke-opacity"},'fill-opacity',$HashConfi{$Level}{"fill-opacity"});
				my $animateLine=$hashValue2Col{$Value};
				my $YY1line=$YY1;
				my $heightLLline=$heightLL;
				for (my $NowAA=$NumPlotArry-2;$NowAA>=0; $NowAA--)
				{
					$Value=$FileData[$FileNow][$StartCount][$NowPLotCoumn[$NowAA]];
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$animateLine=$hashValue2Col{$Value}.";".$animateLine;
					$heightLL=0;
					if ($Value ne "NA") {$heightLL=($YY2-$YY1A)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;}
					$YY1=$YY2-$heightLL;
					$YY1line=$YY1.";".$YY1line;
					$heightLLline=$heightLL.";".$heightLLline;
				}
				$Tag->animate(attributeName=>"fill",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
				$Tag->animate(attributeName=>"stroke",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
				$Tag->animate(attributeName=>"y",values=>"$YY1line",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
				$Tag->animate(attributeName=>"height",values=>"$heightLLline",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			}
		}





	}











	svg2PNGfuntion($svg,$OutPut);
	exit;

}





print STDERR "Start draw... SVG info: ChrNumber :$ChrCount Level Number is $NumberLevel, SVG (width,height) = ($width,$height)\n";

$ChrCount--;





my  $StarGradienRatio=0.5;
my  $Y2=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{"ALL"}{"SizeGradienRatio"}*$CorGra*($MaxGradien+1);
if ($Y2 > $height )
{
	$height=$Y2*1.10;
	$StarGradienRatio=0.3;
}


my $ALLBetweenChrHH=0;
if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
{
	$ALLBetweenChrHH=$ChrCount*$widthBetweenChr;
	$width+=$ALLBetweenChrHH;
	$ChrMax=$TotalChrLength;
}



my $CanvasHeight=$height;
my $CanvasWidth=$width;
if ((exists $HashConfi{"global"}{"CanvasHeightRitao"})  &&  ($HashConfi{"global"}{"CanvasHeightRitao"}>0.1))
{
	$CanvasHeight=$CanvasHeight*$HashConfi{"global"}{"CanvasHeightRitao"};
}

if ((exists $HashConfi{"global"}{"CanvasWidthRitao"})  &&  ($HashConfi{"global"}{"CanvasWidthRitao"}>0.1))
{
	$CanvasWidth=$CanvasWidth*$HashConfi{"global"}{"CanvasWidthRitao"};
}

my $svg = SVG->new('width',$CanvasWidth,'height',$CanvasHeight);



my $YY3=$HashConfi{"global"}{"up"}+$HashConfi{"global"}{"ShiftXaxisY"};
my $YY1=$YY3-$fontsize*0.75;
my $YY2=$YY1+$fontsize*0.25;
my $XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"};
my $XX2=$XX1+$ALLBetweenChrHH+$HashConfi{"global"}{"strokewidth"};
my $ScaleNum=$HashConfi{"global"}{"ScaleNum"}; if ($ScaleNum<1) {$ScaleNum=-1;}
my $ScaleNumChrMax=$ScaleNum;
my $BinXX=($HashConfi{"global"}{"body"}+$ALLBetweenChrHH)/$ScaleNum;
if  (exists $HashConfi{"global"}{"ScaleUnit"}  )
{
	$ScaleNumChrMax=$ChrMax*1.0/$HashConfi{"global"}{"ScaleUnit"};	
	if ($ScaleNumChrMax  < 2   ||  $ScaleNumChrMax >100 ) 
	{
		print "Pare [ScaleUnit] set is too small or too big, we use ScaleNum= $ScaleNum \n ";
		$ScaleNumChrMax=$ScaleNum;
	}
	$BinXX=($HashConfi{"global"}{"body"}+$ALLBetweenChrHH)/$ScaleNumChrMax;
	$ScaleNum=int($ScaleNumChrMax);
}

foreach my $k (0..$ScaleNum)
{
	$XX1=$HashConfi{"global"}{"left"}+$k*$BinXX;
	my $VV=int($ChrMax*$k/($bin*$ScaleNumChrMax)+$RegionStart/$bin);
	if ($label eq "kb")		{ $VV= sprintf ("%.1f",($RegionStart/$bin+$ChrMax*$k/($bin*$ScaleNumChrMax))*1.0);}

	if ( !exists $HashConfi{"global"}{"RotateAxisText"})
	{
		$svg->text('text-anchor','middle','x',$XX1,'y',$YY1-0.60*$fontsize,'-cdata',"$VV $label",'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize);
	}
	else
	{
		my $XXRR= $XX1;
		my $YYRR= $YY1;
		my $rotate=$HashConfi{"global"}{"RotateAxisText"};
		$svg->text('text-anchor','start','x',$XX1,'y',$YYRR,'-cdata',"$VV $label",'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize,'transform',"rotate($rotate,$XXRR,$YYRR)");
	}

	$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX1,'y2',$YY3,'stroke','black','stroke-width',$HashConfi{"global"}{"strokewidth"},'fill',$HashConfi{"global"}{"fill"}); #X
}

if (exists $HashConfi{"global"}{"Main"})
{
	my $colr="blue";
	my $MainRatioFontSize=1;
	my $ShiftMainX=0;
	my $ShiftMainY=0;
	if (exists $HashConfi{"global"}{"MainCol"})	{	$colr=$HashConfi{"global"}{"MainCol"};	}
	if (exists $HashConfi{"global"}{"MainRatioFontSize"})	{	$MainRatioFontSize=$HashConfi{"global"}{"MainRatioFontSize"};	}
	if (exists $HashConfi{"global"}{"ShiftMainX"})	{	$ShiftMainX=$HashConfi{"global"}{"ShiftMainX"};	}
	if (exists $HashConfi{"global"}{"ShiftMainY"})	{	$ShiftMainY=$HashConfi{"global"}{"ShiftMainY"};	}
	my $MainXX1=($HashConfi{"global"}{"left"}+$XX1)/2+$ShiftMainX;
	my $MainYY1=($YY1-2*$fontsize)+$ShiftMainY;
	my $Mainfortsize=$fontsize*1.2*$MainRatioFontSize;
	$svg->text('text-anchor','middle','x',$MainXX1,'y',$MainYY1,'-cdata',$HashConfi{"global"}{"Main"},'font-family',$HashConfi{"global"}{"font-family"},'font-size',$Mainfortsize,'stroke',$colr,'fill',$colr);


}




$XX1=$HashConfi{"global"}{"left"}-$HashConfi{"global"}{"strokewidth"};
my $path = $svg->get_path(
	x => [$XX1, $XX1, $XX2,$XX2],
	y => [$YY1, $YY2, $YY2,$YY1],
	-type => 'polygon');

if ($ScaleNum>0)
{
	$svg->polygon(
		%$path,
		style => {
			'fill'           => $HashConfi{"global"}{"fill"},
			'stroke'         => 'black',
			'stroke-width'   => 0,
			'stroke-opacity' => $HashConfi{ALL}{"stroke-opacity"},
			'fill-opacity'   => $HashConfi{ALL}{"fill-opacity"},
		},
	);
}

my %hashYY1=();
my %hashYY2=();
my %hashXX1=();

$XX1=$HashConfi{"global"}{"left"};
my $EndCurveOUT=0;

foreach my $thisChr (0..$#ChrArry)
{
	my $ThisChrName=$ChrArry[$thisChr];
	$XX2=($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$XX1;

	my $Y1=$HashConfi{"global"}{"up"}+$thisChr*($WidthForOneChr+$widthBetweenChr)+$widthBetweenChr;

	if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
	{
		$Y1=$HashConfi{"global"}{"up"}+$widthBetweenChr;
		$EndCurveOUT=-2;
	}

	foreach my $Level (1..$NumberLevel)
	{ 
		$YY1=$Y1;
		$YY2=$YY1+$HashConfi{$Level}{"ChrWidth"};
		$hashYY1{$ThisChrName}{$Level}=$YY1;
		$hashXX1{$ThisChrName}{$Level}=$XX1;
		$hashYY2{$ThisChrName}{$Level}=$YY2;
		$Y1=$YY2;
		if (!( ($HashConfi{$Level}{"crBG"}  eq  "#FFFFFF" )  && ($HashConfi{$Level}{"crStrokeBG"} eq  "#FFFFFF") ) && (!exists $HashConfi{$Level}{"NoShowBackGroup"}) )
		{
			my $Mid=($YY1+$YY2)/2;
			my $AA=$HashConfi{$Level}{"BGWidthRatio"}*$HashConfi{$Level}{"ChrWidth"}/2;
			$YY1=$Mid-$AA;
			$YY2=$Mid+$AA;
			my $BGCorThisChr=$HashConfi{$Level}{"crBG"} ;
			if (exists 	$Value2SelfCol{$ThisChrName}) {$BGCorThisChr=$Value2SelfCol{$ThisChrName};}

			if ($HashConfi{$Level}{"BGChrEndCurve"}==0)
			{
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');
				$svg->polygon(
					%$path,
					style => {
						'fill'           => $BGCorThisChr,
						'stroke'         => $HashConfi{$Level}{"crStrokeBG"},
						'stroke-width'   => $HashConfi{$Level}{"strokeWidthBG"},
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}
			else
			{
				my $EndCurveRadian=3;
				if (exists $HashConfi{$Level}{"EndCurveRadian"})
				{
					if ($HashConfi{$Level}{"EndCurveRadian"}>=2)
					{
						$EndCurveRadian=$HashConfi{$Level}{"EndCurveRadian"};
					}
					else
					{
						print "Leve $Level Para EndvurveRadian must >=2 ,so we chang it to be 2\n";
						$EndCurveRadian=2;$HashConfi{$Level}{"EndCurveRadian"}=2;
					}
				}
				my $HH=($YY2-$YY1)/$EndCurveRadian;
				if (($HH*2)>abs($XX2-$XX1)) {$HH=abs($XX2-$XX1)*0.48;}
				my $HM=($YY2-$YY1)-$HH-$HH;
				if  ((exists  $HashConfi{$Level}{"EndCurveOUT"}) &&  ($EndCurveOUT> -1)) {$XX1=$XX1-$HH;$XX2=$XX2+$HH;$EndCurveOUT=$HH;}
				my $P1_X=$XX1+$HH;  my $P1_Y=$YY1;
				my $P1Q_X=$XX1;  my $P1Q_Y=$YY1;
				my $P2_X=$XX1;  my $P2_Y=$YY1+$HH;
				my $P3_X=$XX1;  my $P3_Y=$P2_Y+$HM;
				my $P2Q_X=$XX1;  my $P2Q_Y=$YY2;
				my $P4_X=$XX1+$HH;  my $P4_Y=$YY2;
				my $P3Q_X=$XX2;  my $P3Q_Y=$YY2;
				my $P6_X=$XX2-$HH;  my $P6_Y=$YY2;
				my $P7_X=$XX2;  my $P7_Y=$YY2-$HH;
				my $P8_X=$XX2;  my $P8_Y=$P7_Y-$HM;
				my $P4Q_X=$XX2;  my $P4Q_Y=$YY1;
				my $P9_X=$XX2-$HH;  my $P9_Y=$YY1;
				$svg->path(
					'd'=>"M$P1_X $P1_Y Q $P1Q_X $P1Q_Y , $P2_X $P2_Y L  $P3_X $P3_Y  Q $P2Q_X $P2Q_Y , $P4_X $P4_Y   L $P6_X $P6_Y  Q $P3Q_X $P3Q_Y , $P7_X $P7_Y  L $P8_X $P8_Y Q $P4Q_X $P4Q_Y ,$P9_X $P9_Y  Z",
					style => {
						'fill'           =>  $BGCorThisChr,
						'stroke'         =>  $HashConfi{$Level}{"crStrokeBG"},
						'stroke-width'   =>  $HashConfi{$Level}{"strokeWidthBG"},
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				if  ((exists  $HashConfi{$Level}{"EndCurveOUT"}) &&  ($EndCurveOUT> 0)) {$XX1=$XX1+$HH;$XX2=$XX2-$HH;}
			}
		}
		if  ($Level !=$NumberLevel)
		{
			$Y1+=$HashConfi{$Level}{"ChrWidth"}*$HashConfi{$Level}{"ValueSpacingRatio"};
		}
	}

	my $ChrNameRatio=$HashConfi{"ALL"}{"ChrNameRatio"}; $ChrNameRatio||=1;
	my $AAAfontsize=$fontsize*$ChrNameRatio;
	my $ShiftChrNameX=$HashConfi{"ALL"}{"ShiftChrNameX"};
	my $XX3tmp=$XX1-length($ThisChrName)*$AAAfontsize*$chrNameShiftRitao+$ShiftChrNameX;
	if ($EndCurveOUT>0){$XX3tmp=$XX3tmp-$EndCurveOUT;}
	if ($XX3tmp<0) {$XX3tmp=0;}
	my $ShiftChrNameY=$HashConfi{"ALL"}{"ShiftChrNameY"};
	my $TextYY=($hashYY1{$ThisChrName}{1}+$hashYY2{$ThisChrName}{$NumberLevel})*0.5+$ShiftChrNameY+($AAAfontsize*0.5);

	if ($HashConfi{"global"}{"RotateChrName"}==0)
	{
		$svg->text('text-anchor','middle','x',$XX3tmp,'y',$TextYY,'-cdata',$ThisChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$AAAfontsize);
	}
	else
	{
		$XX3tmp=$XX1-$AAAfontsize*1.1+$ShiftChrNameX;
		my $rotate=$HashConfi{"global"}{"RotateChrName"};
		$svg->text('text-anchor','middle','x',$XX3tmp,'y',$TextYY,'-cdata',$ThisChrName,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$AAAfontsize,'transform',"rotate($rotate,$XX3tmp,$TextYY)");
	}


	if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
	{
		$XX1=$XX2+$widthBetweenChr;
	}
	else
	{
		$XX1=$HashConfi{"global"}{"left"};
	}
}


$SetParaFor=$#ChrArry ;
if ( $HashConfi{"global"}{"ChrArrayDirection"} ne  "vertical" )
{
	$SetParaFor=0;
}





$chrNameShiftRitao=$chrNameShiftRitao-0.3;


print "Level $NumberLevel\n";
foreach my $Level  (1..$NumberLevel)
{
	if  (exists  $HashConfi{$Level}{"LevelName"})
	{
		foreach my $thisChr (0..$SetParaFor)
		{
			my $ThisChrName=$ChrArry[$thisChr];
			my $NYY2=$hashYY2{$ThisChrName}{$Level};
			my $NYY1=$hashYY1{$ThisChrName}{$Level};
			my $NXX1=$hashXX1{$ThisChrName}{$Level};
			my $colr="green";
			my $NameRatioFontSize=1;
			my $ShiftNameX=0;
			my $ShiftNameY=0;
			my $NameRotate=0;
			my $textanchor="end";
			if (exists $HashConfi{$Level}{"NameCol"})	{	$colr=$HashConfi{$Level}{"NameCol"};	}
			if (exists $HashConfi{$Level}{"NameRatioFontSize"})	{	$NameRatioFontSize=$HashConfi{$Level}{"NameRatioFontSize"};	}
			if (exists $HashConfi{$Level}{"ShiftNameX"})	{	$ShiftNameX=$HashConfi{$Level}{"ShiftNameX"};	}
			if (exists $HashConfi{$Level}{"ShiftNameY"})	{	$ShiftNameY=$HashConfi{$Level}{"ShiftNameY"};	}
			if (exists $HashConfi{$Level}{"NameRotate"})	{	$NameRotate=$HashConfi{$Level}{"NameRotate"}; $textanchor="middle";	}
			elsif  ( ($NYY2-$NYY1)> 3*$fontsize )			{   $NameRotate=-90; $textanchor="middle"; }
			my $NameXX1=$NXX1+$ShiftNameX-$fontsize*0.8;
			my $NameYY1=($NYY1+$NYY2)/2+$ShiftNameY;
			my $Namefortsize=$fontsize*0.6*$NameRatioFontSize;
			$svg->text('text-anchor',$textanchor,'x',$NameXX1,'y',$NameYY1,'-cdata',$HashConfi{$Level}{"LevelName"},'font-family',$HashConfi{"global"}{"font-family"},'font-size',$Namefortsize,'stroke',$colr,'fill',$colr,'transform',"rotate($NameRotate,$NameXX1,$NameYY1)");
		}
	}




	my %FlagValue=();
	$HashConfi{$Level}{"IsNumber"}=1;
	$HashConfi{$Level}{"TotalValue"}=0;
	my $PlotInfo=$ShowColumn[$Level-1];
	my $PlotArryNum=$#$PlotInfo+1;
	for (my $i=0; $i<$PlotArryNum; $i++)
	{
		my $NowPlot=$PlotInfo->[$i];
		my $FileNow=$NowPlot->[0];
		my $CoumnNow=$NowPlot->[1];

		if(( $HashConfi{$Level}{"PType"}  eq  "LinkSelf" )   || ( $HashConfi{$Level}{"PType"}  eq  "LinkS" )   ||  (  $HashConfi{$Level}{"PType"}  eq  "PairWiseLinkV2")  ||   (  $HashConfi{$Level}{"PType"}  eq  "pairwiselinkV2") )
		{
			next if ($i>0) ;
		}

		my $StartCount=0;
		if ( defined($FileData[$FileNow][0][0])  && ($FileData[$FileNow][0][0] =~s/#/#/)  )
		{
			$StartCount=1;
		}
		for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
		{
			next if  ($FileData[$FileNow][$StartCount][$CoumnNow] eq "NA");	
			if ($HashConfi{$Level}{"LogP"}!=0)
			{
				$FileData[$FileNow][$StartCount][$CoumnNow]=0-log($FileData[$FileNow][$StartCount][$CoumnNow])/$log10;
			}
			$FlagValue{$FileData[$FileNow][$StartCount][$CoumnNow]}++;
			$HashConfi{$Level}{"TotalValue"}++;
			if ($FileData[$FileNow][$StartCount][$CoumnNow]=~s/\./\./)
			{
				$Accu="%.2f";
			}

			if ( $FileData[$FileNow][$StartCount][$CoumnNow]  =~ /^-?(0|([1-9][0-9]*))(\.[0-9]+)?([eE][-+]?[0-9]+)?$/)
			{

			}
			elsif (!( $FileData[$FileNow][$StartCount][$CoumnNow]  =~ /^[+-]?\d+(\.\d+)?$/ ))
			{
				$HashConfi{$Level}{"IsNumber"}=0;
			}
		}
	}

	if (exists $HashConfi{$Level}{"asFlag"} ) {	  $HashConfi{$Level}{"IsNumber"}=0; }
	my @ValueArry= sort  keys  %FlagValue ;
	if ($HashConfi{$Level}{"IsNumber"}==1 )
	{
		@ValueArry= sort {$a<=>$b} @ValueArry;
	}
	my $ValueMin=$ValueArry[0];  if  (!defined($ValueMin)) {$ValueMin=0;}
	my $ValueCount=$#ValueArry;
	my $ValueMax=$ValueArry[$ValueCount]; if  (!defined($ValueMax)) {$ValueMax=0;}
	my $MinCutNum=$HashConfi{$Level}{"TopVLow"} * $HashConfi{$Level}{"TotalValue"};
	my $MaxCutNum=$HashConfi{$Level}{"TopVHigh"} * $HashConfi{$Level}{"TotalValue"};
	my $MinCutCount=0;		my $MaxCutCount=0;
	my $EndCountBin=$#ValueArry;			my $StartCountBin=0;
	foreach my $key (0..$ValueCount)
	{
		my $VCount=$ValueArry[$key];
		$MinCutCount+=$FlagValue{$VCount};
		$MaxCutCount+=$FlagValue{$VCount};
		if ($MinCutCount<=$MinCutNum)
		{
			$StartCountBin=$key;
		}
		if ($MaxCutCount<=$MaxCutNum)
		{
			$EndCountBin=$key;
		}
	}
	my $MinCutValue=$ValueArry[$StartCountBin];	
	my $MaxCutValue=$ValueArry[$EndCountBin];
	if(exists $HashConfi{$Level}{"YMax"})
	{
		if ($HashConfi{$Level}{"YMax"}>$MaxCutValue)
		{
			$MaxCutValue=$HashConfi{$Level}{"YMax"};
		}
		else
		{
			my $eeetmp=$HashConfi{$Level}{"YMax"};
			print "InPut Para For [Level $Level] YMax  $eeetmp  must > $MaxCutValue \t since the data max Value is $MaxCutValue\n";
		}
	}
	else
	{
		$HashConfi{$Level}{"YMax"}=$MaxCutValue;
	}


	if (exists $HashConfi{$Level}{"YMin"})
	{
		if  ($HashConfi{$Level}{"YMin"}> $MinCutValue )
		{
			my $eeetmp=$HashConfi{$Level}{"YMin"};
			print "InPut -YMin For [Level $Level] $eeetmp must < $ValueMin \t since the data min Value is $MinCutValue\n";
		}
		else
		{
			$MinCutValue=$HashConfi{$Level}{"YMin"};
		}
	}
	else
	{
		$HashConfi{$Level}{"YMin"}= $MinCutValue;
	}

	if ($HashConfi{$Level}{"IsNumber"}==1 )
	{
		foreach my $key (0..$ValueCount)
		{
			my $VCount=$ValueArry[$key];
			if ( $VCount  <= $MinCutValue )
			{
				$StartCountBin=$key;
			}
			if ( $VCount <= $MaxCutValue )
			{
				$EndCountBin=$key;
			}
		}
	}
	else
	{		
		foreach my $key (0..$ValueCount)
		{
			my $VCount=$ValueArry[$key];
			if ( $VCount le  $MinCutValue)
			{
				$StartCountBin=$key;
			}
			if ($VCount le  $MaxCutValue)
			{
				$EndCountBin=$key;
			}
		}
	}



	my %hashValue2Col=();
	my @ArryCol=();
	my @ArryValue=();
	my $MaxCol=1;
	my $Precision=$Accu;
	if (exists $HashConfi{$Level}{"Precision"} )
	{
		my $Num=int($HashConfi{$Level}{"Precision"});
		$Precision="%.$Num"."f";
	}

	if ( ( $HashConfi{$Level}{"IsNumber"}==1 )   &&  ( abs($ValueMax)<0.01 )  &&  ( abs($ValueMin)<0.01 ) )
	{
		my $e='e';	my $f='f';
		$Precision =~ s/$f/$e/g;
	}

	my $NumGradien= $HashConfi{$Level}{"Gradien"};
	if ($ValueCount<$NumGradien)
	{
		$HashConfi{$Level}{"Gradien"}=$ValueCount+1;
		$NumGradien=  $ValueCount+1;
		$EndCountBin=$ValueCount;$StartCountBin=0;
		$MaxCutValue=$ValueMax  ; $MinCutValue=$ValueMin;
	}
	if ($EndCountBin<($NumGradien-2))
	{
		$EndCountBin=$NumGradien-2;
	}
	if ($EndCountBin==$ValueCount)
	{
		if  (($EndCountBin-$StartCountBin)<($NumGradien-2))
		{
			$StartCountBin=$EndCountBin+2-$NumGradien;				 
		}
	}
	else
	{
		if  (($EndCountBin-$StartCountBin)<($NumGradien-3))
		{
			$StartCountBin=$EndCountBin+3-$NumGradien;
		}
	}
	if ($StartCountBin<0) {$StartCountBin=0;}


	if ( exists $HashConfi{$Level}{"ColorBrewer"}  )
	{
		if ( $HashConfi{$Level}{"ColorBrewer"}  eq  "NANA" )
		{
			if ($HashConfi{$Level}{"IsNumber"}==1 )
			{
				$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
				$HashConfi{$Level}{"Gradien"}=10;
				$NumGradien=10;
				if (($HashConfi{$Level}{"PType"}  eq  "lines")  || ( $HashConfi{$Level}{"PType"}  eq  "line"))
				{
					$HashConfi{$Level}{"ColorBrewer"}="Dark2";
					$HashConfi{$Level}{"Gradien"}=8;
					$NumGradien=8;
				}
				elsif (($HashConfi{$Level}{"PType"}  eq  "scatter" )  || ( $HashConfi{$Level}{"PType"}  eq  "point" ) || ( $HashConfi{$Level}{"PType"}  eq  "points" ))
				{
					if  ($PlotArryNum>1) { $HashConfi{$Level}{"ColorBrewer"}="Set1"; $HashConfi{$Level}{"Gradien"}=9;$NumGradien=9;}
				}

			}
			else
			{
				$HashConfi{$Level}{"ColorBrewer"}="Paired";
				$HashConfi{$Level}{"Gradien"}=8;
				$NumGradien=8;
			}
		}
		elsif ($HashConfi{$Level}{"ColorBrewer"} eq "NA")
		{
			if ($HashConfi{$Level}{"IsNumber"}==1 )
			{
				$HashConfi{$Level}{"ColorBrewer"}="GnYlRd";
				if (($HashConfi{$Level}{"PType"}  eq  "lines")  || ( $HashConfi{$Level}{"PType"}  eq  "line"))
				{
					$HashConfi{$Level}{"ColorBrewer"}="Dark2";
				}
				elsif (($HashConfi{$Level}{"PType"}  eq  "scatter" )  || ( $HashConfi{$Level}{"PType"}  eq  "point" ) || ( $HashConfi{$Level}{"PType"}  eq  "points" ))
				{
					if  ($PlotArryNum>1) { $HashConfi{$Level}{"ColorBrewer"}="Set1"; }
				}
			}
			else
			{
				$HashConfi{$Level}{"ColorBrewer"}="Paired";
			}
		}
		if ($ValueCount<$NumGradien)
		{
			$HashConfi{$Level}{"Gradien"}=$ValueCount+1;
			$NumGradien=  $ValueCount+1;
			$EndCountBin=$ValueCount;$StartCountBin=0;
			$MaxCutValue=$ValueMax  ; $MinCutValue=$ValueMin;
		}
		if ($EndCountBin<($NumGradien-2))
		{
			$EndCountBin=$NumGradien-2;
		}
		if ($EndCountBin==$ValueCount)
		{
			if  (($EndCountBin-$StartCountBin)<($NumGradien-2))
			{
				$StartCountBin=$EndCountBin+2-$NumGradien;				 
			}
		}
		else
		{
			if  (($EndCountBin-$StartCountBin)<($NumGradien-3))
			{
				$StartCountBin=$EndCountBin+3-$NumGradien;
			}
		}
		if ($StartCountBin<0) {$StartCountBin=0;}


		my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
		GetColGradien($ColFlag,$NumGradien,\@ArryCol);
		if  (exists  $HashConfi{$Level}{"ReverseColor"})
		{
			my @cccTmpCor=();
			foreach my $k (0..$#ArryCol)
			{
				my $Tho=$#ArryCol-$k;
				$cccTmpCor[$Tho]=$ArryCol[$k];
			}
			foreach my $k (0..$#ArryCol)
			{
				$ArryCol[$k]=$cccTmpCor[$k];
			}
		}
		$MaxCol=$NumGradien-1;

		if ($HashConfi{$Level}{"IsNumber"}==1 )
		{
			my $ShiftTmpEnd=$NumGradien-1;
			if ($EndCountBin< $ValueCount)
			{
				my $tttEnd=$EndCountBin+1;
				my $VV=$ValueArry[$tttEnd];
				$VV=sprintf ($Precision,$VV*1.0);
				$ArryValue[$ShiftTmpEnd]=">$VV";
				foreach my $k ($tttEnd..$ValueCount)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpEnd];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpEnd--;
			}

			my $ShiftTmpStart=0;
			if ($StartCountBin>0)
			{
				my $VV=$ValueArry[$StartCountBin];
				$VV=sprintf ($Precision,$VV*1.0);
				$ArryValue[0]="<$VV";
				my $tttEnd=$StartCountBin-1;
				foreach my $k (0..$tttEnd)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpStart];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpStart=1;
			}


			my $Diff=1;
			if ($NumGradien>1)
			{
				$Diff=($MaxCutValue-$MinCutValue)/($NumGradien-1);
				if ($Diff==0) {$Diff=1;}
			}

			foreach my $k ($StartCountBin..$EndCountBin)
			{
				my $VV=$ValueArry[$k];
				my $KKey=int(($VV-$MinCutValue)/$Diff)+$ShiftTmpStart;
				$hashValue2Col{$VV}= $ArryCol[$KKey];
				if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
			}

			my $Shift=$ShiftTmpStart;
			foreach my $k ($ShiftTmpStart..$ShiftTmpEnd)
			{
				my $MinAA=$MinCutValue+($k-$Shift)*$Diff;
				$MinAA=sprintf ($Precision,$MinAA*1.0);
				$ArryValue[$k]="$MinAA";
			}
		}
		else
		{
			my $ShiftTmpEnd=$NumGradien-1;
			if ($EndCountBin< $ValueCount)
			{
				my $tttEnd=$EndCountBin+1;
				my $VV=$ValueArry[$tttEnd];
				$ArryValue[$ShiftTmpEnd]="$VV";
				foreach my $k ($tttEnd..$ValueCount)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpEnd];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpEnd--;
			}
			my $ShiftTmpStart=0;
			if ($StartCountBin>0)
			{
				my $VV=$ValueArry[$StartCountBin];
				$ArryValue[0]="<$VV";
				my $tttEnd=$StartCountBin-1;
				foreach my $k (0..$tttEnd)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$ArryCol[$ShiftTmpStart];
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpStart=1;
			}

			my $Diff=1;
			if ($NumGradien>1)
			{
				$Diff=($EndCountBin-$StartCountBin)/($NumGradien-1);
				if ($Diff==0) {$Diff=1;}
			}
			foreach my $k ($StartCountBin..$EndCountBin)
			{			
				my $VV=$ValueArry[$k];
				my $KKey=int(($k-$StartCountBin)/$Diff)+$ShiftTmpStart;
				$hashValue2Col{$VV}= $ArryCol[$KKey];
				if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				$ArryValue[$KKey]||="$VV";
			}
		}
	}
	elsif  ($ValueCount==2)
	{
		my $VV=$ValueArry[0];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
		$VV=$ValueArry[1];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crMid"};$ArryCol[1]=$HashConfi{$Level}{"crMid"}; $ArryValue[1]=$VV;
		$VV=$ValueArry[2];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[2]=$HashConfi{$Level}{"crEnd"}; $ArryValue[2]=$VV;
		$MaxCol=2;
	}
	elsif ($ValueCount < 2)
	{
		my $VV=$ValueArry[0];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
		if ($ValueCount==0) {$ValueArry[1]=$ValueArry[0];}
		$VV=$ValueArry[1]; 
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[1]=$HashConfi{$Level}{"crEnd"}; $ArryValue[1]=$VV;
		$MaxCol=1;
	}
	elsif ($ValueCount< $HashConfi{$Level}{"Gradien"})
	{
		my $Atmp=int($ValueCount/2);

		my $VV=$ValueArry[0];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};$ArryCol[0]=$HashConfi{$Level}{"crBegin"}; $ArryValue[0]=$VV;
		$VV=$ValueArry[$Atmp];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crMid"};$ArryCol[$Atmp]=$HashConfi{$Level}{"crMid"}; $ArryValue[$Atmp]=$VV;
		$VV=$ValueArry[$ValueCount];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}
		$hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};$ArryCol[$ValueCount]=$HashConfi{$Level}{"crEnd"}; $ArryValue[$ValueCount]=$VV;

		my @StartRGB;
		($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
		my @EndRGB;
		($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
		my @MidRGB;
		($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});


		my $MidNumGradien=$Atmp; my $Btmp=$Atmp-1;
		foreach my $k (1..$Btmp)
		{
			my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
			my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
			my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
			$VV=$ValueArry[$k];   $hashValue2Col{$VV}="rgb($RR,$GG,$BB)";
			$ArryCol[$k]="rgb($RR,$GG,$BB)";  $ArryValue[$k]=$VV;
			if (exists $Value2SelfCol{$VV} )
			{
				$hashValue2Col{$VV}=$Value2SelfCol{$VV};
				$ArryCol[$k]=$Value2SelfCol{$VV};				
			}
		}
		$Btmp=$Atmp+1;  my $Ctmp=$ValueCount-1;

		foreach my $k ($Btmp..$Ctmp)
		{
			my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$Atmp)*1.0/$MidNumGradien);
			my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$Atmp)*1.0/$MidNumGradien);
			my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$Atmp)*1.0/$MidNumGradien);
			$VV=$ValueArry[$k];   $hashValue2Col{$VV}="rgb($RR,$GG,$BB)";
			$ArryCol[$k]="rgb($RR,$GG,$BB)";  $ArryValue[$k]=$VV;
			if (exists $Value2SelfCol{$VV} )
			{
				$hashValue2Col{$VV}=$Value2SelfCol{$VV};
				$ArryCol[$k]=$Value2SelfCol{$VV};				
			}
		}
		$MaxCol=$ValueCount;
	}
	else
	{
		my $NumGradien=$HashConfi{$Level}{"Gradien"};
		$MaxCol=$NumGradien-1;
		my $MidNumGradien=int($MaxCol/2);

		my $VV=$ValueArry[0];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crBegin"}=$Value2SelfCol{$VV};}
		$VV=$ValueArry[$MidNumGradien];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crMid"}=$Value2SelfCol{$VV};}
		$VV=$ValueArry[$MaxCol];
		if (exists $Value2SelfCol{$VV} ) {$HashConfi{$Level}{"crEnd"}=$Value2SelfCol{$VV};}

		my @StartRGB;
		($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
		my @EndRGB;
		($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
		my @MidRGB;
		($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

		foreach my $k (0..$MidNumGradien)
		{
			my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
			my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
			my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
			$ArryCol[$k]="rgb($RR,$GG,$BB)";
		}
		my $MidNumGradienBB=$MidNumGradien+1;
		$NumGradien--;
		foreach my $k ($MidNumGradienBB..$NumGradien)
		{
			my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
			my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
			my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
			$ArryCol[$k]="rgb($RR,$GG,$BB)";
		}
		$ArryCol[$NumGradien+1]=$HashConfi{$Level}{"crEnd"};

		if ($HashConfi{$Level}{"IsNumber"}==1 )
		{
			my $ShiftTmpEnd=$NumGradien;
			if ($EndCountBin< $ValueCount)
			{
				my $VV=$ValueArry[$EndCountBin];
				$VV=sprintf ($Precision,$VV*1.0);
				$ArryValue[$NumGradien]=">$VV";
				my $tttEnd=$EndCountBin+1;
				foreach my $k ($tttEnd..$ValueCount)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpEnd--;
			}

			my $ShiftTmpStart=0;
			if ($StartCountBin>0)
			{
				my $VV=$ValueArry[$StartCountBin];
				$VV=sprintf ($Precision,$VV*1.0);
				$ArryValue[0]="<$VV";
				my $tttEnd=$StartCountBin-1;
				foreach my $k (0..$tttEnd)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpStart=1;
			}


			my $Diff=($MaxCutValue-$MinCutValue)/($NumGradien+1);
			if ($Diff==0) {$Diff=1;}
			foreach my $k ($StartCountBin..$EndCountBin)
			{
				my $VV=$ValueArry[$k];
				my $KKey=int(($VV-$MinCutValue)/$Diff)+$ShiftTmpStart;
				$hashValue2Col{$VV}= $ArryCol[$KKey];
				if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
			}
			my $Shift=$ShiftTmpStart;	
			foreach my $k ($ShiftTmpStart..$ShiftTmpEnd)
			{
				my $MinAA=$MinCutValue+($k-$Shift)*$Diff;
				$MinAA=sprintf ($Precision,$MinAA*1.0);
				$ArryValue[$k]="$MinAA";
			}
		}
		else
		{
			my $ShiftTmpEnd=$NumGradien;
			if ($EndCountBin< $ValueCount)
			{
				my $VV=$ValueArry[$EndCountBin];
				$ArryValue[$NumGradien]=">$VV";
				my $tttEnd=$EndCountBin+1;
				foreach my $k ($tttEnd..$ValueCount)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crEnd"};
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpEnd--;
			}

			my $ShiftTmpStart=0;
			if ($StartCountBin>0)
			{
				my $VV=$ValueArry[$StartCountBin];
				$ArryValue[0]="<$VV";
				my $tttEnd=$StartCountBin-1;
				foreach my $k (0..$tttEnd)
				{
					my $VV=$ValueArry[$k];   $hashValue2Col{$VV}=$HashConfi{$Level}{"crBegin"};
					if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				}
				$NumGradien--;
				$ShiftTmpStart=1;
			}

			my $Diff=($EndCountBin-$StartCountBin)/($NumGradien);
			if ($Diff==0) {$Diff=1;}
			foreach my $k ($StartCountBin..$EndCountBin)
			{
				my $VV=$ValueArry[$k];
				my $KKey=int(($k-$StartCountBin)/$Diff)+$ShiftTmpStart;
				$hashValue2Col{$VV}= $ArryCol[$KKey];
				if (exists $Value2SelfCol{$VV} ) {$hashValue2Col{$VV}=$Value2SelfCol{$VV};}
				$ArryValue[$KKey]||="$VV";
			}
		}
	}

	if (%Value2SelfCol)
	{
		my @TmpCol=keys %Value2SelfCol;
		if ($#TmpCol >=$ValueCount)
		{
			foreach my $yy (0..$MaxCol)
			{
				my $cc=$ArryValue[$yy];
				if  (exists $Value2SelfCol{$cc}) { $ArryCol[$yy]=$Value2SelfCol{$cc};}
			}
		}
	}



	my $LevelCorGra=$HashConfi{$Level}{"SizeGradienRatio"}*$CorGra;
	my $NumPlotArry=$#$PlotInfo+1;

	#################### Start  Plot ########
	if (($HashConfi{$Level}{"PType"}  eq  "heatmap")   ||  ($HashConfi{$Level}{"PType"}  eq  "highlights"))
	{
		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;

		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}

		my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};

		foreach my $tmpkk (1..$NumPlotArry) 
		{
			my $ThisBoxbin=$tmpkk-1;
			my $NowPlot=$PlotInfo->[$ThisBoxbin];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}

			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;				
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				my $binYYHeat=($YY2-$YY1)/$NumPlotArry;
				$YY1=$YY1+$ThisBoxbin*$binYYHeat;
				$YY2=$YY1+$binYYHeat;
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => $hashValue2Col{$Value},
						'stroke'         => $hashValue2Col{$Value},
						'stroke-width'   => $HeatMapstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}
		}
	}

	elsif (( $HashConfi{$Level}{"PType"}  eq  "LinkSelf" )   || ( $HashConfi{$Level}{"PType"}  eq  "LinkS" )   )  ## link自我的基因组
	{

		my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};

		if ( $HashConfi{$Level}{"ChrWidth"} <25 )
		{
			print "Bad at Level $Level  For  [-PType]  is  [LinkS] , For LinkS the input  [ChrWidth] is Suggest to be biger, like ChrWidth=100 \n";
		}

		if ( ($HashConfi{$Level}{"crBG"}  eq  "#FFFFFF" ) ||  (exists $HashConfi{$Level}{"NoShowBackGroup"}) )
		{
		}
		else
		{
			print "Bad at Level $Level  For  [-PType]  is  [LinkS] , For LinkS the input  [NoShowBackGroup] is Suggest to be 1, like NoShowBackGroup=1 \n";
		}


		my $LineType=1;
		if ((exists $HashConfi{$Level}{"lineType"})   && ($HashConfi{$Level}{"lineType"} eq "line")  )
		{
			$LineType=0;
		}


		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;

		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);		
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}


		my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};



		my $StartCount=0;

		my $NowPlot=$PlotInfo->[0];
		my $FileNow=$NowPlot->[0];
		my $CoumnNow=$NowPlot->[1];
		my $B1=$CoumnNow+1; my $B2=$CoumnNow+2; my $B3=$CoumnNow+3; 

		if ($NumPlotArry!=4)
		{
			print "Bad at Level $Level  For  [-PType]  is  [LinkS] , For LinkS the input  CoumnNow  must be 4 (Value chrB StartB EndB)\n";

			print " so you can set the  [  ShowColumn=File$FileNow:$CoumnNow  File$FileNow:$B1   File$FileNow:$B2   File$FileNow:$B3   ]\n";
			next ;
		}
		else
		{
			my $NowPlot1=$PlotInfo->[1];my $FileNow1=$NowPlot1->[0];
			my $NowPlot2=$PlotInfo->[2];my $FileNow2=$NowPlot2->[0];
			my $NowPlot3=$PlotInfo->[3];my $FileNow3=$NowPlot3->[0];
			if ($FileNow!=$FileNow1   || $FileNow!=$FileNow2 ||$FileNow!=$FileNow3)
			{
				print "Bad at Level $Level  For  [-PType]  is  [LinkS] , For LinkS the input  CoumnNow  must be 4 (Value chrB StartB EndB),and the File must be the same\n";
				print " so you can set the para like as   [  ShowColumn=File$FileNow:$CoumnNow,$B1,$B2,$B3 ]\n";
				next ;
			}
			$B1=$NowPlot1->[1];$B2=$NowPlot2->[1];$B3=$NowPlot3->[1];
		}


		if (defined($FileData[$FileNow][0][0]) &&  ($FileData[$FileNow][0][0] =~s/#/#/))
		{
			$StartCount=1;
		}


		if ($LineType == 0 )
		{
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName}) ;				
				my $StartA=$FileData[$FileNow][$StartCount][1];
				my $EndA  =$FileData[$FileNow][$StartCount][2];

				my $chrB=$FileData[$FileNow][$StartCount][$B1];
				my $StartB=$FileData[$FileNow][$StartCount][$B2];
				my $EndB=$FileData[$FileNow][$StartCount][$B3];
				next if (!exists $hashYY1{$chrB}) ;


				my  $ZRTF=1;
				if ( exists $HashConfi{"global"}{"ZoomRegion"})
				{
					my $regionArry=$HashConfi{"global"}{"ZoomRegion"};

					$ZRTF=0;
					next if  ( $chrB  ne $$regionArry[0] );
					next if ( ( $StartB< $$regionArry[1])  && ($EndB < $$regionArry[1] ));
					next if ( ( $StartB> $$regionArry[2])  && ($EndB > $$regionArry[2] ));
					$ZRTF=1;

					if ( ($StartB>=$$regionArry[1])  &&     ($StartB<=$$regionArry[2]))
					{
						$StartB=$StartB-$$regionArry[1]+1;
					}
					elsif ($StartB<$$regionArry[1])
					{
						$StartB=1;
					}
					else
					{
						$StartB=$$regionArry[2]-$$regionArry[1]+1;
					}


					if ( ($EndB>=$$regionArry[1])  &&  ($EndB<=$$regionArry[2]))
					{
						$EndB=$EndB-$$regionArry[1]+1;
					}
					elsif ($EndB<$$regionArry[1])
					{
						$EndB=1;
					}
					else
					{
						$EndB=$$regionArry[2]-$$regionArry[1]+1;
					}


				}
				next if  ($ZRTF!=1);










				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				my $YY1_AA=$YY1;
				my $YY2_AA=$YY1;
				my $XStart_AA=sprintf ("%.1f",($StartA/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XEnd_AA=sprintf ("%.1f",($EndA/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

				my $YY1_BB=$YY2;
				my $YY2_BB=$YY2;
				my $XStart_BB=sprintf ("%.1f",($StartB/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$chrB}{$Level});
				my $XEnd_BB=sprintf ("%.1f",($EndB/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$chrB}{$Level});


				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				$path = $svg->get_path(
					x => [$XStart_AA, $XEnd_AA, $XEnd_BB,$XStart_BB],
					y => [$YY2_AA, $YY2_AA, $YY1_BB,$YY1_BB],
					-type => 'polygon');
				$svg->polygon(
					%$path,
					style => {
						'opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill'           => $hashValue2Col{$Value},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						'stroke'         => $hashValue2Col{$Value},
						'stroke-width'   => $HHstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
					},
				);
			}
		}
		else
		{

			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName}) ;				
				my $StartA=$FileData[$FileNow][$StartCount][1];
				my $EndA  =$FileData[$FileNow][$StartCount][2];

				my $chrB=$FileData[$FileNow][$StartCount][$B1];
				my $StartB=$FileData[$FileNow][$StartCount][$B2];
				my $EndB=$FileData[$FileNow][$StartCount][$B3];
				next if (!exists $hashYY1{$chrB}) ;				



				my  $ZRTF=1;
				if ( exists $HashConfi{"global"}{"ZoomRegion"})
				{
					my $regionArry=$HashConfi{"global"}{"ZoomRegion"};

					$ZRTF=0;
					next if  ( $chrB  ne $$regionArry[0] );
					next if ( ( $StartB< $$regionArry[1])  && ($EndB < $$regionArry[1] ));
					next if ( ( $StartB> $$regionArry[2])  && ($EndB > $$regionArry[2] ));
					$ZRTF=1;

					if ( ($StartB>=$$regionArry[1])  &&     ($StartB<=$$regionArry[2]))
					{
						$StartB=$StartB-$$regionArry[1]+1;
					}
					elsif ($StartB<$$regionArry[1])
					{
						$StartB=1;
					}
					else
					{
						$StartB=$$regionArry[2]-$$regionArry[1]+1;
					}


					if ( ($EndB>=$$regionArry[1])  &&  ($EndB<=$$regionArry[2]))
					{
						$EndB=$EndB-$$regionArry[1]+1;
					}
					elsif ($EndB<$$regionArry[1])
					{
						$EndB=1;
					}
					else
					{
						$EndB=$$regionArry[2]-$$regionArry[1]+1;
					}


				}
				next if  ($ZRTF!=1);






				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				my $YY1_AA=$YY1;
				my $YY2_AA=$YY1;
				my $XStart_AA=sprintf ("%.1f",($StartA/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XEnd_AA=sprintf ("%.1f",($EndA/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

				my $YY1_BB=$YY2;
				my $YY2_BB=$YY2;
				my $XStart_BB=sprintf ("%.1f",($StartB/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$chrB}{$Level});
				my $XEnd_BB=sprintf ("%.1f",($EndB/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$chrB}{$Level});

				my $MidHH=($YY1+$YY2)*0.5;

				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				my $MidXX_Start=($XStart_AA+$XStart_BB)*0.5;
				my $MidYY=($YY2_AA+$YY1_BB)*0.5;
				my $MidXX_End=($XEnd_AA+$XEnd_BB)*0.5;

				my $kk=($XEnd_AA-$MidXX_End)*0.4/$MidHH;
				my $QQBB_XX=($XEnd_AA + $MidXX_End)*0.5+$MidHH*$kk;
				my $QQBB_YY=($YY2_AA+ $MidYY)*0.5;

				$kk=($XStart_BB-$MidXX_Start)*0.4/$MidHH;
				my $QQAA_XX=($XStart_BB+$MidXX_Start)*0.5+$MidHH*$kk;
				my $QQAA_YY=($MidYY+$YY1_BB)*0.5;

				$svg->path(
					'd'=>"M$XStart_AA $YY2_AA L $XEnd_AA $YY2_AA  Q $QQBB_XX $QQBB_YY , $MidXX_End $MidYY T $XEnd_BB $YY1_BB  L $XStart_BB $YY1_BB Q $QQAA_XX $QQAA_YY , $MidXX_Start $MidYY T $XStart_AA $YY2_AA  Z",
					style => {
						'opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill'           => $hashValue2Col{$Value},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
						'stroke'         => $hashValue2Col{$Value},
						'stroke-width'   => $HHstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
					},
				);
			}
		}





	}


	elsif (( $HashConfi{$Level}{"PType"}  eq  "pairwiselinkV2" )  || ( $HashConfi{$Level}{"PType"}  eq  "PairWiseLinkV2" ))
	{

		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;
		my %hashHHC=();
		my $HH=($HashConfi{$Level}{"ChrWidth"}) ;
		my $HHbinS=$HH/($MaxCol+1);
		$hashHHC{$HashConfi{$Level}{"crEnd"}}=$MaxCol;
		$hashHHC{$HashConfi{$Level}{"crBegin"}}=0;

		foreach my $k (0..$MaxCol)
		{
			$hashHHC{$ArryCol[$k]}=($k+1)*$HHbinS;
			my $HTML=RGB2HTML($ArryCol[$k]);
			$hashHHC{$HTML}=($k+1)*$HHbinS;
			if ((exists ($HashConfi{$Level}{"SameHigh"}))   &&  ($HashConfi{$Level}{"SameHigh"}!=0) )
			{
				$hashHHC{$ArryCol[$k]}=$HH;
				$hashHHC{$HTML}=$HH;
			}
		}







		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}

		my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};




		my $NowPlot=$PlotInfo->[0];
		my $FileNow=$NowPlot->[0];
		my $FileNow1=$FileNow;
		my $FileNow2=$FileNow;
		my $CoumnNow=$NowPlot->[1];
		my $B1=$CoumnNow+1; my $B2=$CoumnNow+2;

		if ($NumPlotArry!=3)
		{
			print "Bad at Level $Level  For  [-PType]  is  [PairWiseLinkV2] , For PairWiseLinkV2 the input  CoumnNow  must be 3 (Value chrB SiteB)\n";

			print " so you can set the  [  ShowColumn=File$FileNow:$CoumnNow  File$FileNow:$B1   File$FileNow:$B2    ]\n";
			next ;
		}
		else
		{
			my $NowPlot1=$PlotInfo->[1]; $FileNow1=$NowPlot1->[0];
			my $NowPlot2=$PlotInfo->[2]; $FileNow2=$NowPlot2->[0];
			if ($FileNow!=$FileNow1   || $FileNow!=$FileNow2)
			{
				print "Bad at Level $Level  For  [-PType]  is  [PairWiseLinkV2] , For LinkS the input  CoumnNow  must be 3 (Value chrB SiteB),and the File must be the same\n";
				print " so you can set the para like as   [  ShowColumn=File$FileNow:$CoumnNow,$B1,$B2 ]\n";
				next ;
			}
			$B1=$NowPlot1->[1];$B2=$NowPlot2->[1];
		}






		#my $ThisBoxbin=0
		#my $NowPlot=$PlotInfo->[$ThisBoxbin];
		#			my $FileNow=$NowPlot->[0];
		my $StartCount=0;
		if  ($FileData[$FileNow][0][0] =~s/#/#/) 
		{
			$StartCount=1;
		}

		if ( (exists ($HashConfi{$Level}{"lineType"}))   &&  ( $HashConfi{$Level}{"lineType"} eq "line") )
		{
			if ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUp" ))
			{
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} );				
					my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
					next if (!exists $hashYY2{$ThisChrNameBB});
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
					my $EndSite=$FileData[$FileNow][$StartCount][$B2];
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
				}
			}
			else
			{
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;	
					my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
					next if (!exists $hashYY2{$ThisChrNameBB} ) ;	
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
					my $EndSite=$FileData[$FileNow][$StartCount][$B2];
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
				}
			}
		}
		elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownDown" ))
		{
			#cx = (x - (Math.pow(1 - t, 2) * x1) - Math.pow(t, 2) * x2) / (2 * t * (1 - t))
			#cy = (y - (Math.pow(1 - t, 2) * y1) - Math.pow(t, 2) * y2) / (2 * t * (1 - t))
			#t[0-1]
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;
				my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
				next if (!exists $hashYY2{$ThisChrNameBB} ) ;
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
				my $EndSite=$FileData[$FileNow][$StartCount][$B2];
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});
				my $Q1_X=($XX1+$XX2)*0.5;
				my $Q1_Y=$YY2-(2*$hashHHC{$hashValue2Col{$Value}});
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				if ( $XX1 ==  $XX2 )
				{
					$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY2-$hashHHC{$hashValue2Col{$Value}} , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					next ;
				}
				$svg->path(
					'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,  $XX2 $YY2 ",
					style => {
						'fill'           =>  'none',
						'stroke'         =>  $hashValue2Col{$Value},
						'stroke-width'   =>  $HeatMapstrokewidth,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}


		}
		elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "UpDownV2" ))
		{
			my $MidHH=$HashConfi{$Level}{"ChrWidth"};
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} );
				my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
				next if (!exists $hashYY2{$ThisChrNameBB} );
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][$B2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});

				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

				if ( $XX1 ==  $XX2 )
				{
					$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					next ;
				}

				my $M1_X=($XX1+$XX2)*0.5;
				my $M1_Y=($YY1+$YY2)*0.5;

				my $kk=($XX2-$M1_X)*0.4/$MidHH;
				my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
				my $Q1_Y=($YY1+$M1_Y)*0.5;
				$svg->path(
					'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY2  ",
					style => {
						'fill'           =>  'none',
						'stroke'         =>  $hashValue2Col{$Value},
						'stroke-width'   =>  $HeatMapstrokewidth,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}


		}
		elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "UpDown") )
		{
			my $MidHH=$HashConfi{$Level}{"ChrWidth"};
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName}) ;
				my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
				next if (!exists $hashYY2{$ThisChrNameBB}) ;
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][$B2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});

				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

				if ( $XX1 ==  $XX2 )
				{
					$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					next ;
				}

				my $M1_X=($XX1+$XX2)*0.5;
				my $M1_Y=($YY1+$YY2)*0.5;

				my $kk=($XX1-$M1_X)*0.4/$MidHH;
				my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
				my $Q1_Y=($YY1+$M1_Y)*0.5;
				$svg->path(
					'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY2  ",
					style => {
						'fill'           =>  'none',
						'stroke'         =>  $hashValue2Col{$Value},
						'stroke-width'   =>  $HeatMapstrokewidth,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}
		}

		elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUpV2" ))
		{
			my $MidHH=$HashConfi{$Level}{"ChrWidth"};
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;
				my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
				next if (!exists $hashYY2{$ThisChrNameBB} ) ;
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][$B2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});

				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

				if ( $XX1 ==  $XX2 )
				{
					$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					next ;
				}

				my $M1_X=($XX1+$XX2)*0.5;
				my $M1_Y=($YY1+$YY2)*0.5;

				my $kk=($XX2-$M1_X)*0.4/$MidHH;
				my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
				my $Q1_Y=($YY2+$M1_Y)*0.5;
				$svg->path(
					'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY1  ",
					style => {
						'fill'           =>  'none',
						'stroke'         =>  $hashValue2Col{$Value},
						'stroke-width'   =>  $HeatMapstrokewidth,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}


		}
		elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUp") )
		{
			my $MidHH=$HashConfi{$Level}{"ChrWidth"};
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;
				my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
				next if (!exists $hashYY2{$ThisChrNameBB} ) ;
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][$B2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});

				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

				if ( $XX1 ==  $XX2 )
				{
					$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					next ;
				}

				my $M1_X=($XX1+$XX2)*0.5;
				my $M1_Y=($YY1+$YY2)*0.5;


				my $kk=($XX2-$M1_X)*0.4/$MidHH;
				my $Q1_X=($XX1+$M1_X)*0.5-$MidHH*$kk;
				my $Q1_Y=($YY2+$M1_Y)*0.5;
				$svg->path(
					'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY1  ",
					style => {
						'fill'           =>  'none',
						'stroke'         =>  $hashValue2Col{$Value},
						'stroke-width'   =>  $HeatMapstrokewidth,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);


			}
		}

		else
		{

			for (; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;				
				my $ThisChrNameBB=$FileData[$FileNow][$StartCount][$B1];
				next if (!exists $hashYY2{$ThisChrNameBB} ) ;				
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][$B2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrNameBB}{$Level};
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrNameBB}{$Level});
				my $Q1_X=($XX1+$XX2)*0.5;
				my $Q1_Y=$YY1+2*$hashHHC{$hashValue2Col{$Value}};
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				if ($XX1 ==  $XX2 )
				{
					$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX1,'y2', $YY1+$hashHHC{$hashValue2Col{$Value}} , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					next ;
				}
				$svg->path(
					'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,  $XX2 $YY1 ",
					style => {
						'fill'           =>  'none',
						'stroke'         =>  $hashValue2Col{$Value},
						'stroke-width'   =>  $HeatMapstrokewidth,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}



		}









	}






	elsif (( $HashConfi{$Level}{"PType"}  eq  "pairwiselink" )  || ( $HashConfi{$Level}{"PType"}  eq  "PairWiseLink" ))
	{

		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;
		my %hashHHC=();
		my $HH=($HashConfi{$Level}{"ChrWidth"}) ;
		my $HHbinS=$HH/($MaxCol+1);
		$hashHHC{$HashConfi{$Level}{"crEnd"}}=$MaxCol;
		$hashHHC{$HashConfi{$Level}{"crBegin"}}=0;

		foreach my $k (0..$MaxCol)
		{
			$hashHHC{$ArryCol[$k]}=($k+1)*$HHbinS;
			my $HTML=RGB2HTML($ArryCol[$k]);
			$hashHHC{$HTML}=($k+1)*$HHbinS;
			if ((exists ($HashConfi{$Level}{"SameHigh"}))   &&  ($HashConfi{$Level}{"SameHigh"}!=0) )
			{
				$hashHHC{$ArryCol[$k]}=$HH;
				$hashHHC{$HTML}=$HH;
			}
		}







		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}

		my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};

		foreach my $tmpkk (1..$NumPlotArry)
		{
			my $ThisBoxbin=$tmpkk-1;
			my $NowPlot=$PlotInfo->[$ThisBoxbin];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}

			if ( (exists ($HashConfi{$Level}{"lineType"}))   &&  ( $HashConfi{$Level}{"lineType"} eq "line") )
			{
				if ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUp" ))				
				{
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $hashYY1{$ThisChrName} ) ;				
						my $StartSite=$FileData[$FileNow][$StartCount][1];
						my $EndSite=$FileData[$FileNow][$StartCount][2];
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
						$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					}
				}
				else
				{
					for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
					{
						my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
						next if  ($Value eq "NA");
						my $ThisChrName=$FileData[$FileNow][$StartCount][0];
						next if (!exists $hashYY1{$ThisChrName} ) ;				
						my $StartSite=$FileData[$FileNow][$StartCount][1];
						my $EndSite=$FileData[$FileNow][$StartCount][2];
						my $YY1=$hashYY1{$ThisChrName}{$Level};
						my $YY2=$hashYY2{$ThisChrName}{$Level};
						my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
						if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
						$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
					}
				}
			}
			elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownDown" ))
			{
				#cx = (x - (Math.pow(1 - t, 2) * x1) - Math.pow(t, 2) * x2) / (2 * t * (1 - t))
				#cy = (y - (Math.pow(1 - t, 2) * y1) - Math.pow(t, 2) * y2) / (2 * t * (1 - t))
				#t[0-1]
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;				
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $Q1_X=($XX1+$XX2)*0.5;
					my $Q1_Y=$YY2-(2*$hashHHC{$hashValue2Col{$Value}});
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					if ($XX1 == $XX2)
					{
						$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY2-$hashHHC{$hashValue2Col{$Value}} , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						next ;
					}
					$svg->path(
						'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,  $XX2 $YY2 ",
						style => {
							'fill'           =>  'none',
							'stroke'         =>  $hashValue2Col{$Value},
							'stroke-width'   =>  $HeatMapstrokewidth,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}


			}
			elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "UpDownV2" ))
			{
				my $MidHH=$HashConfi{$Level}{"ChrWidth"};
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;				
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

					if ( $XX1 ==  $XX2 )
					{
						$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						next ;
					}

					my $M1_X=($XX1+$XX2)*0.5;
					my $M1_Y=($YY1+$YY2)*0.5;

					my $kk=($XX2-$M1_X)*0.4/$MidHH;
					my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
					my $Q1_Y=($YY1+$M1_Y)*0.5;
					$svg->path(
						'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY2  ",
						style => {
							'fill'           =>  'none',
							'stroke'         =>  $hashValue2Col{$Value},
							'stroke-width'   =>  $HeatMapstrokewidth,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}


			}
			elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "UpDown") )
			{
				my $MidHH=$HashConfi{$Level}{"ChrWidth"};
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;				
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

					if ( $XX1 ==  $XX2 )
					{
						$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2', $YY2 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						next ;
					}

					my $M1_X=($XX1+$XX2)*0.5;
					my $M1_Y=($YY1+$YY2)*0.5;

					my $kk=($XX1-$M1_X)*0.4/$MidHH;
					my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
					my $Q1_Y=($YY1+$M1_Y)*0.5;
					$svg->path(
						'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY2  ",
						style => {
							'fill'           =>  'none',
							'stroke'         =>  $hashValue2Col{$Value},
							'stroke-width'   =>  $HeatMapstrokewidth,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}
			}

			elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUpV2" ))
			{
				my $MidHH=$HashConfi{$Level}{"ChrWidth"};
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;				
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

					if ( $XX1 ==  $XX2 )
					{
						$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						next ;
					}

					my $M1_X=($XX1+$XX2)*0.5;
					my $M1_Y=($YY1+$YY2)*0.5;

					my $kk=($XX2-$M1_X)*0.4/$MidHH;
					my $Q1_X=($XX1+$M1_X)*0.5+$MidHH*$kk;
					my $Q1_Y=($YY2+$M1_Y)*0.5;
					$svg->path(
						'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY1  ",
						style => {
							'fill'           =>  'none',
							'stroke'         =>  $hashValue2Col{$Value},
							'stroke-width'   =>  $HeatMapstrokewidth,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}


			}
			elsif ((exists ($HashConfi{$Level}{"StyleUpDown"}))   &&  ($HashConfi{$Level}{"StyleUpDown"} eq "DownUp") )
			{
				my $MidHH=$HashConfi{$Level}{"ChrWidth"};
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++ )
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;				
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

					if ( $XX1 ==  $XX2 )
					{
						$svg->line('x1',$XX1,'y1',$YY2,'x2',$XX2,'y2', $YY1 , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						next ;
					}

					my $M1_X=($XX1+$XX2)*0.5;
					my $M1_Y=($YY1+$YY2)*0.5;


					my $kk=($XX2-$M1_X)*0.4/$MidHH;
					my $Q1_X=($XX1+$M1_X)*0.5-$MidHH*$kk;
					my $Q1_Y=($YY2+$M1_Y)*0.5;
					$svg->path(
						'd'=>"M$XX1 $YY2 Q $Q1_X $Q1_Y ,$M1_X , $M1_Y  T $XX2 $YY1  ",
						style => {
							'fill'           =>  'none',
							'stroke'         =>  $hashValue2Col{$Value},
							'stroke-width'   =>  $HeatMapstrokewidth,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);


				}
			}

			else
			{

				for (; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;				
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $Q1_X=($XX1+$XX2)*0.5;
					my $Q1_Y=$YY1+2*$hashHHC{$hashValue2Col{$Value}};
					if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
					if ($XX1 ==  $XX2 )
					{
						$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX1,'y2', $YY1+$hashHHC{$hashValue2Col{$Value}} , 'stroke',$hashValue2Col{$Value},'stroke-width',$HeatMapstrokewidth,'fill',$hashValue2Col{$Value}); 
						next ;
					}
					$svg->path(
						'd'=>"M$XX1 $YY1 Q $Q1_X $Q1_Y ,  $XX2 $YY1 ",
						style => {
							'fill'           =>  'none',
							'stroke'         =>  $hashValue2Col{$Value},
							'stroke-width'   =>  $HeatMapstrokewidth,
							'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
							'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
						},
					);
				}



			}
		}








	}
	elsif (( $HashConfi{$Level}{"PType"}  eq  "histogram" )  || ( $HashConfi{$Level}{"PType"}  eq  "hist" ))
	{
		if ($NumPlotArry>2)
		{
			print "Error:\tFor -PType histogram  on Level [$Level] only One/two Plot,you can modify to add the Level for it or change the -PType\n";
			for (my $i=0; $i<$NumPlotArry; $i++)
			{
				my $NowPlot=$PlotInfo->[$i];
				print "\t\tFile$NowPlot->[0]\tCoumn$NowPlot->[1]\n";
			}
			print "\t:you can change the [-PType] as [histAnimated] have a try\n";
			exit;
		}

		if ($NumPlotArry==2)
		{
			$ArryCol[1]=$ArryCol[$MaxCol];
			$MaxCol=1;
			my $NowPlot=$PlotInfo->[0];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			$ArryValue[0]="U:$FileData[$FileNow][0][$CoumnNow]";
			$NowPlot=$PlotInfo->[1];
			$FileNow=$NowPlot->[0];
			$CoumnNow=$NowPlot->[1];
			$ArryValue[1]="D:$FileData[$FileNow][0][$CoumnNow]";
		}

		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;

		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);
			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);  
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}

		my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
		my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};


		if ($NumPlotArry==1)
		{
			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}		


			my $NowPlot=$PlotInfo->[0];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');
				$svg->polygon(
					%$path,
					style => {
						'fill'           => $hashValue2Col{$Value},
						'stroke'         => $hashValue2Col{$Value},
						'stroke-width'   => $HHstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}
		}
		else
		{

			if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
			{
				my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
				my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
				my $countTmpChr=$#ChrArry;
				if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
				{
					$countTmpChr=0;
				}
				foreach my $thisChr (0..$countTmpChr)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
					my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
					my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
					$svg->text('text-anchor','middle','x',$XX2,'y',($YY2+$YY1)/2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				}
			}
			my $NowPlot=$PlotInfo->[0];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				$YY2=($YY1+$YY2)/2;
				$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');
				$svg->polygon(
					%$path,
					style => {
						'fill'           => $ArryCol[0],
						'stroke'         => $ArryCol[0],
						'stroke-width'   => $HHstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}



			$NowPlot=$PlotInfo->[1];
			$FileNow=$NowPlot->[0];
			$CoumnNow=$NowPlot->[1];
			$StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				$YY1=($YY1+$YY2)/2;
				$YY2=$YY1+($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');
				$svg->polygon(
					%$path,
					style => {
						'fill'           => $ArryCol[1],
						'stroke'         => $ArryCol[1],
						'stroke-width'   => $HHstrokewidth,
						'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
					},
				);
			}


		}




		if (exists $HashConfi{$Level}{"Cutline"})
		{
			my $Value=$HashConfi{$Level}{"Cutline"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}
		if (exists $HashConfi{$Level}{"Cutline1"})
		{
			my $Value=$HashConfi{$Level}{"Cutline1"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}


		if (exists $HashConfi{$Level}{"Cutline2"})
		{
			my $Value=$HashConfi{$Level}{"Cutline2"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}






	}
	elsif (($HashConfi{$Level}{"PType"}  eq  "scatter" )  || ( $HashConfi{$Level}{"PType"}  eq  "point" ) || ( $HashConfi{$Level}{"PType"}  eq  "points" ))
	{

		my $cirsize=$LevelCorGra/12;
		if  ( (exists $HashConfi{$Level}{"CirsizeRatio"} )  && ( $HashConfi{$Level}{"CirsizeRatio"} >0 ) )
		{
			$cirsize=$cirsize*$HashConfi{$Level}{"CirsizeRatio"};
		}
		my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};

		if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
		{
			my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
			my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
			my $countTmpChr=$#ChrArry;
			if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
			{
				$countTmpChr=0;
			}
			foreach my $thisChr (0..$countTmpChr)
			{
				my $ThisChrName=$ChrArry[$thisChr];
				my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
				my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
				my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
			}
		}

		if ($NumPlotArry==1)
		{

			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.8+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			$XX2=$XX1+$LevelCorGra;
			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;
					$svg->circle(cx=>$XX1, cy=>$YY2, r=>$cirsize*5, fill => "$ArryCol[$k]" );
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}


			my $NowPlot=$PlotInfo->[0];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}
			my %Uniq=();
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				$YY1=sprintf ("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $key=$XX1."_".$YY1;
				next if (exists $Uniq{$key});
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				$svg->circle(cx=>$XX1, cy=>$YY1, r=>$cirsize, fill => "$hashValue2Col{$Value}" );
				$Uniq{$key}=1;
			}
		}
		else
		{			
			my $NumGradien=$NumPlotArry;

			if (! exists $HashConfi{$Level}{"ColorBrewer"} )
			{			
				my @StartRGB;
				($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
				my @EndRGB;
				($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
				my @MidRGB;
				($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

				my $MidNumGradien=int($NumGradien/2);
				foreach my $k (0..$MidNumGradien)
				{
					my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
					my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
					my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
				my $MidNumGradienBB=$MidNumGradien+1;
				$NumGradien--;
				foreach my $k ($MidNumGradienBB..$NumGradien)
				{
					my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
				$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
				if ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
			}
			else
			{
				@ArryCol=();
				my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
				GetColGradien($ColFlag,$NumGradien,\@ArryCol);
				if (exists  $HashConfi{$Level}{"ReverseColor"})
				{
					my @cccTmpCor=();
					foreach my $k (0..$#ArryCol)
					{
						my $Tho=$#ArryCol-$k;
						$cccTmpCor[$Tho]=$ArryCol[$k];
					}
					foreach my $k (0..$#ArryCol)
					{
						$ArryCol[$k]=$cccTmpCor[$k];
					}
				}
			}
			foreach my $k (1..$NumPlotArry)
			{
				my	$NowPlot=$PlotInfo->[$k-1];
				my  $FileNow=$NowPlot->[0];
				my	$CoumnNow=$NowPlot->[1];
				my  $StartCount=0;
				$ArryValue[$k-1]="$FileData[$FileNow][0][$CoumnNow]";

				$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
				$XX2=$XX1+$LevelCorGra;
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*($k-1)+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;
				if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
				{
				}
				else
				{
					$svg->circle(cx=>$XX1, cy=>$YY1, r=>$cirsize*5, fill => "$ArryCol[$k-1]" );
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k-1])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k-1]",'font-family','Arial','font-size',$LevelCorGra);
				}


				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}
				my %Uniq=();
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");	
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;	
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					$YY1=sprintf ("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $key=$XX1."_".$YY1;
					next if (exists $Uniq{$key});
					$svg->circle(cx=>$XX1, cy=>$YY1, r=>$cirsize, fill => "$ArryCol[$k-1]" );
					$Uniq{$key}=1;
				}
			}
		}
		if (exists $HashConfi{$Level}{"Cutline"})
		{
			my $Value=$HashConfi{$Level}{"Cutline"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};  
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}

				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}
		if (exists $HashConfi{$Level}{"Cutline1"})
		{
			my $Value=$HashConfi{$Level}{"Cutline1"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}

				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}

		if (exists $HashConfi{$Level}{"Cutline2"})
		{
			my $Value=$HashConfi{$Level}{"Cutline2"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}

				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}




	}
	elsif (($HashConfi{$Level}{"PType"}  eq  "shape" )  || ( $HashConfi{$Level}{"PType"}  eq  "shapes" ) || ( $HashConfi{$Level}{"PType"}  eq  "Shape" ))
	{

		my $cirsize=$LevelCorGra/12;
		if  ( (exists $HashConfi{$Level}{"CirsizeRatio"} )  && ( $HashConfi{$Level}{"CirsizeRatio"} >0 ) )
		{
			$cirsize=$cirsize*$HashConfi{$Level}{"CirsizeRatio"};
		}
		if  ( (exists $HashConfi{$Level}{"ShapesizeRatio"} )  && ( $HashConfi{$Level}{"ShapesizeRatio"} >0 ) )
		{
			$cirsize=$cirsize*$HashConfi{$Level}{"ShapesizeRatio"};
		}
		my	$MaxDiffValue=1;
		if ($HashConfi{$Level}{"IsNumber"}==1 )
		{
			$MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
		}

		if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
		{
			my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
			my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
			my $countTmpChr=$#ChrArry;
			if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical")
			{
				$countTmpChr=0;
			}
			foreach my $thisChr (0..$countTmpChr)
			{
				my $ThisChrName=$ChrArry[$thisChr];
				my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
				my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
				my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
			}
		}

		if ($NumPlotArry==1)
		{
			$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra*($MaxCol+1);
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.8+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			$XX2=$XX1+$LevelCorGra;
			my @shapeType=();
			foreach my $k (0..$MaxCol)
			{
				my $Type= $k % 14;
				$shapeType[$k]=$Type;
			}
			if (exists $HashConfi{$Level}{"ShapeType"})
			{
				my  @ccc=split/\,/,$HashConfi{$Level}{"ShapeType"};
				foreach my $k (0..$#ccc)
				{
					if ($ccc[$k]<14)
					{				
						$shapeType[$k]=$ccc[$k];
					}
				}
			}
			my %Col2Shape=();
			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{
				foreach my $k (0..$MaxCol)
				{
					$Col2Shape{"$ArryCol[$k]"}=$shapeType[$k];
				}
			}
			else
			{
				foreach my $k (0..$MaxCol)
				{
					$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
					$YY2=$YY1+$LevelCorGra;
					SVGgetShape($XX1,$YY2-$LevelCorGra*0.5,$LevelCorGra*0.5,$shapeType[$k],$ArryCol[$k],$svg);
					$Col2Shape{"$ArryCol[$k]"}=$shapeType[$k];
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
				}
			}


			my $NowPlot=$PlotInfo->[0];
			my $FileNow=$NowPlot->[0];
			my $CoumnNow=$NowPlot->[1];
			my $StartCount=0;
			if  ($FileData[$FileNow][0][0] =~s/#/#/) 
			{
				$StartCount=1;
			}
			my %Uniq=();
			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{
				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				next if  ($Value eq "NA");	
				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				my $YY1=$hashYY1{$ThisChrName}{$Level};
				my $YY2=$hashYY2{$ThisChrName}{$Level};
				if ($HashConfi{$Level}{"IsNumber"}==1 )
				{
					$YY1=sprintf ("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
				}
				else
				{
					$YY1=($YY1+$YY2)*0.5;
				}
				my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
				my $shapeT=$Col2Shape{$hashValue2Col{$Value}};
				my $key=$XX1."_".$YY1."_$shapeT";
				next if (exists $Uniq{$key});
				if (exists $Value2SelfCol{$Value}) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				SVGgetShape($XX1,$YY1,$cirsize,$shapeT,$hashValue2Col{$Value},$svg);
				$Uniq{$key}=1;
			}
		}
		else
		{
			my $NumGradien=$NumPlotArry;

			if (! exists $HashConfi{$Level}{"ColorBrewer"} )
			{			
				my @StartRGB;
				($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
				my @EndRGB;
				($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
				my @MidRGB;
				($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

				my $MidNumGradien=int($NumGradien/2);
				foreach my $k (0..$MidNumGradien)
				{
					my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
					my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
					my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
				my $MidNumGradienBB=$MidNumGradien+1;
				$NumGradien--;
				foreach my $k ($MidNumGradienBB..$NumGradien)
				{
					my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
				$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
				if ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
			}
			else
			{
				@ArryCol=();
				my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
				GetColGradien($ColFlag,$NumGradien,\@ArryCol);
				if (exists  $HashConfi{$Level}{"ReverseColor"})
				{
					my @cccTmpCor=();
					foreach my $k (0..$#ArryCol)
					{
						my $Tho=$#ArryCol-$k;
						$cccTmpCor[$Tho]=$ArryCol[$k];
					}
					foreach my $k (0..$#ArryCol)
					{
						$ArryCol[$k]=$cccTmpCor[$k];
					}
				}
			}


			my @shapeType=();
			foreach my $kk (1..$NumPlotArry)
			{
				my $k=$kk-1;
				my $Type= $k % 14;
				$shapeType[$k]=$Type;
			}

			if (exists $HashConfi{$Level}{"ShapeType"} )
			{
				my  @ccc=split/\,/,$HashConfi{$Level}{"ShapeType"};
				foreach my $k (0..$#ccc)
				{
					if ($ccc[$k]<14)
					{				
						$shapeType[$k]=$ccc[$k];
					}
				}
			}

			foreach my $k (1..$NumPlotArry)
			{
				my	$NowPlot=$PlotInfo->[$k-1];
				my  $FileNow=$NowPlot->[0];
				my	$CoumnNow=$NowPlot->[1];
				my  $StartCount=0;
				my  $shapeT=$shapeType[$k-1];
				$ArryValue[$k-1]="$FileData[$FileNow][0][$CoumnNow]";

				$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
				$XX2=$XX1+$LevelCorGra;
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*($k-1)+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;
				if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
				{

				}
				else
				{
					SVGgetShape($XX1,$YY2-$LevelCorGra*0.5,$LevelCorGra*0.5,$shapeT,$ArryCol[$k-1],$svg);
					$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k-1])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k-1]",'font-family','Arial','font-size',$LevelCorGra);
				}

				if  ($FileData[$FileNow][0][0] =~s/#/#/) 
				{
					$StartCount=1;
				}
				my %Uniq=();
				for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
				{
					my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
					next if  ($Value eq "NA");	
					my $ThisChrName=$FileData[$FileNow][$StartCount][0];
					next if (!exists $hashYY1{$ThisChrName} ) ;	
					my $StartSite=$FileData[$FileNow][$StartCount][1];
					my $EndSite=$FileData[$FileNow][$StartCount][2];
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					if ($HashConfi{$Level}{"IsNumber"}==1 )
					{
						$YY1=sprintf ("%.1f",$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue);
					}
					else
					{
						$YY1=($YY1+$YY2)*0.5;
					}
					my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $key=$XX1."_".$YY1."_$shapeT";
					next if (exists $Uniq{$key});
					SVGgetShape($XX1,$YY1,$cirsize,$shapeT,$ArryCol[$k-1],$svg);
					$Uniq{$key}=1;
				}
			}
		}


		if (exists $HashConfi{$Level}{"Cutline"})
		{
			my $Value=$HashConfi{$Level}{"Cutline"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}

				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}
		if (exists $HashConfi{$Level}{"Cutline1"})
		{
			my $Value=$HashConfi{$Level}{"Cutline1"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}

				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}

		if (exists $HashConfi{$Level}{"Cutline2"})
		{
			my $Value=$HashConfi{$Level}{"Cutline2"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};				
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}

				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}




	}
	elsif (	($HashConfi{$Level}{"PType"}  eq  "text" )	  )
	{

		if ($NumPlotArry>1)
		{
			print "Error:\tFor -PType txt  one Level [$Level] only One Plot,you can modify to add the Level for it or change the -PType\n";
			for (my $i=0; $i<$NumPlotArry; $i++)
			{
				my $NowPlot=$PlotInfo->[$i];
				print "\t\tFile$NowPlot->[0]\tCoumn$NowPlot->[1]\n";
			}
			exit;
		}

		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;
		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;
				$svg->text('text-anchor','middle','x',$XX1+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra,'stroke',$ArryCol[$k]);
			}
		}



		my $NowPlot=$PlotInfo->[0];
		my $FileNow=$NowPlot->[0];
		my $CoumnNow=$NowPlot->[1];
		my $StartCount=0;
		if  ($FileData[$FileNow][0][0] =~s/#/#/)
		{
			$StartCount=1;
		}
		my $text_font_size=$fontsize*0.5;
		if (exists $HashConfi{$Level}{"text-font-size"})
		{
			$text_font_size=$HashConfi{$Level}{"text-font-size"};
		}
		if (exists $HashConfi{$Level}{"TextFontRatio"})
		{
			$text_font_size=$text_font_size*$HashConfi{$Level}{"TextFontRatio"};
		}

		my $TextAnchor="middle"; 
		if (exists $HashConfi{$Level}{"TextAnchor"})
		{
			$TextAnchor=$HashConfi{$Level}{"TextAnchor"};
		}



		for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
		{
			my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
			next if  ($Value eq "NA");	
			my $ThisChrName=$FileData[$FileNow][$StartCount][0];
			next if (!exists $hashYY1{$ThisChrName} ) ;	
			my $StartSite=$FileData[$FileNow][$StartCount][1];
			my $EndSite=$FileData[$FileNow][$StartCount][2];
			$YY1=$hashYY1{$ThisChrName}{$Level};
			$YY2=$hashYY2{$ThisChrName}{$Level};
			$XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
			if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}

			if ($HashConfi{$Level}{"Rotate"}!=0) 
			{		
				my $Rotate=$HashConfi{$Level}{"Rotate"};
				$YY1=$YY1+($YY2-$YY1)*3/5;
				$svg->text('text-anchor',$TextAnchor,'x',$XX1,'y',$YY1,'-cdata',"$Value",'fill',$hashValue2Col{$Value},'font-family',$HashConfi{$Level}{"font-family"},'font-size',$text_font_size,'transform',"rotate($Rotate,$XX1,$YY1)");
			}
			else
			{
				$svg->text('text-anchor',$TextAnchor,'x',$XX1,'y',$YY2,'-cdata',"$Value",'fill',$hashValue2Col{$Value},'font-family',$HashConfi{$Level}{"font-family"},'font-size',$text_font_size);
			}
		}
	}
	elsif (( $HashConfi{$Level}{"PType"}  eq  "ridgeline" ) )
	{

		if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
		{
			my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
			my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
			my $countTmpChr=$#ChrArry;
			if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
			{
				$countTmpChr=0;
			}
			foreach my $thisChr (0..$countTmpChr)
			{
				my $ThisChrName=$ChrArry[$thisChr];
				my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
				my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
				my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
			}
		}	



		my $NumGradien=$NumPlotArry;

		if (! exists $HashConfi{$Level}{"ColorBrewer"} )
		{
			my @StartRGB;
			($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
			my @EndRGB;
			($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
			my @MidRGB;
			($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

			if  ($NumGradien!=1)
			{
				my $MidNumGradien=int($NumGradien/2);
				foreach my $k (0..$MidNumGradien)
				{
					my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
					my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
					my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
				my $MidNumGradienBB=$MidNumGradien+1;
				$NumGradien--;
				foreach my $k ($MidNumGradienBB..$NumGradien)
				{
					my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
			}
			else
			{
				$ArryCol[0]=$HashConfi{$Level}{"crBegin"};
			}
			$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
			if  ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
		}
		else
		{
			@ArryCol=();
			my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
			GetColGradien($ColFlag,$NumGradien,\@ArryCol);
			if  (exists  $HashConfi{$Level}{"ReverseColor"})
			{
				my @cccTmpCor=();
				foreach my $k (0..$#ArryCol)
				{
					my $Tho=$#ArryCol-$k;
					$cccTmpCor[$Tho]=$ArryCol[$k];
				}
				foreach my $k (0..$#ArryCol)
				{
					$ArryCol[$k]=$cccTmpCor[$k];
				}
			}
		}

		my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
		my $strokewidthV2=$HashConfi{"ALL"}{"strokewidth"}*0.88;
		if  (exists  $HashConfi{$Level}{"strokewidth"} ) {$strokewidthV2= $HashConfi{$Level}{"strokewidth"} ;}

		foreach my $tmpkk (1..$NumPlotArry)
		{
			my  $ThisBoxbin=$tmpkk-1;
			my	$NowPlot=$PlotInfo->[$ThisBoxbin];
			my  $FileNow=$NowPlot->[0];
			my	$CoumnNow=$NowPlot->[1];
			my  $StartCount=0;
			$ArryValue[$ThisBoxbin]="$FileData[$FileNow][0][$CoumnNow]";
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			$XX2=$XX1+$LevelCorGra;
			$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$tmpkk+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra;
			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2',$YY2,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$HashConfi{"ALL"}{"strokewidth"});
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$ThisBoxbin])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$ThisBoxbin]",'font-family','Arial','font-size',$LevelCorGra);
			}



			if ($FileData[$FileNow][0][0] =~s/#/#/)
			{
				$StartCount=1;
			}
			my $FirstPoint=1;
			my $pointAX; 
			my $pointAY;
			my $ChrThisNow="NA";

			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{

				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				if ($Value eq "NA")
				{
					$FirstPoint=1;
					next;
				}

				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				$YY1=$hashYY1{$ThisChrName}{$Level};
				$YY2=$hashYY2{$ThisChrName}{$Level};
				$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
				$XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

				if (($FirstPoint==1)   || ($ChrThisNow ne  $ThisChrName ) )
				{
					$pointAX=$XX1;
					$pointAY=$YY1;
					$ChrThisNow=$ThisChrName;
					$FirstPoint=0;
					next;
				}

				$svg->line('x1',$pointAX,'y1',$pointAY,'x2',$XX1,'y2',$YY1,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$strokewidthV2);
				$path = $svg->get_path(
					x => [$pointAX, $XX1, $XX1,$pointAX],
					y => [$pointAY, $YY1, $YY2,$YY2],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill' =>$ArryCol[$ThisBoxbin],
						'stroke'         =>  $ArryCol[$ThisBoxbin],
						'stroke-width'   =>  $strokewidthV2,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				$pointAX=$XX1;
				$pointAY=$YY1;
			}
		}

		if (exists $HashConfi{$Level}{"Cutline"})
		{
			my $Value=$HashConfi{$Level}{"Cutline"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};			
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}
		if (exists $HashConfi{$Level}{"Cutline1"})
		{
			my $Value=$HashConfi{$Level}{"Cutline1"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};			
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}


		if (exists $HashConfi{$Level}{"Cutline2"})
		{
			my $Value=$HashConfi{$Level}{"Cutline2"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};			
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}



	}

	elsif (( $HashConfi{$Level}{"PType"}  eq  "lines" )  || ( $HashConfi{$Level}{"PType"}  eq  "line" ))
	{

		if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
		{
			my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
			my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
			my $countTmpChr=$#ChrArry;
			if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
			{
				$countTmpChr=0;
			}
			foreach my $thisChr (0..$countTmpChr)
			{
				my $ThisChrName=$ChrArry[$thisChr];
				my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
				my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
				my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
			}
		}	



		my $NumGradien=$NumPlotArry;

		if (! exists $HashConfi{$Level}{"ColorBrewer"} )
		{
			my @StartRGB;
			($StartRGB[0],$StartRGB[1],$StartRGB[2] )=HTML2RGB($HashConfi{$Level}{"crBegin"});
			my @EndRGB;
			($EndRGB[0],$EndRGB[1],$EndRGB[2])=HTML2RGB($HashConfi{$Level}{"crEnd"});
			my @MidRGB;
			($MidRGB[0],$MidRGB[1],$MidRGB[2])=HTML2RGB($HashConfi{$Level}{"crMid"});

			if  ($NumGradien!=1)
			{
				my $MidNumGradien=int($NumGradien/2);
				foreach my $k (0..$MidNumGradien)
				{
					my $RR=int($StartRGB[0]+($MidRGB[0]-$StartRGB[0])*$k*1.0/$MidNumGradien);
					my $GG=int($StartRGB[1]+($MidRGB[1]-$StartRGB[1])*$k*1.0/$MidNumGradien);
					my $BB=int($StartRGB[2]+($MidRGB[2]-$StartRGB[2])*$k*1.0/$MidNumGradien);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
				my $MidNumGradienBB=$MidNumGradien+1;
				$NumGradien--;
				foreach my $k ($MidNumGradienBB..$NumGradien)
				{
					my $RR=int($MidRGB[0]+($EndRGB[0]-$MidRGB[0])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $GG=int($MidRGB[1]+($EndRGB[1]-$MidRGB[1])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					my $BB=int($MidRGB[2]+($EndRGB[2]-$MidRGB[2])*($k-$MidNumGradien)*1.0/$MidNumGradienBB);
					$ArryCol[$k]="rgb($RR,$GG,$BB)";
				}
			}
			else
			{
				$ArryCol[0]=$HashConfi{$Level}{"crBegin"};
			}
			$ArryCol[$NumPlotArry]=$HashConfi{$Level}{"crEnd"};
			if  ($NumPlotArry==2) {$ArryCol[1]=$HashConfi{$Level}{"crEnd"};}
		}
		else
		{
			@ArryCol=();
			my $ColFlag=$HashConfi{$Level}{"ColorBrewer"};
			GetColGradien($ColFlag,$NumGradien,\@ArryCol);
			if  (exists  $HashConfi{$Level}{"ReverseColor"})
			{
				my @cccTmpCor=();
				foreach my $k (0..$#ArryCol)
				{
					my $Tho=$#ArryCol-$k;
					$cccTmpCor[$Tho]=$ArryCol[$k];
				}
				foreach my $k (0..$#ArryCol)
				{
					$ArryCol[$k]=$cccTmpCor[$k];
				}
			}
		}
		if (exists $HashConfi{$Level}{"LinesColBB"} )
		{
			my $bbb=$HashConfi{$Level}{"LinesColBB"};
			open (IACCC,"$bbb") || die "input file can't open $!";
			while(<IACCC>)
			{
				chomp ;
				$_=~s/=/\t/;
				$_=~s/"//g;
				my @trt=split ;
				$ArryCol[$trt[0]]=$trt[-1];
			}
			close IACCC;
		}
		my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
		my $strokewidthV2=$HashConfi{"ALL"}{"strokewidth"}*0.88;
		if  (exists  $HashConfi{$Level}{"strokewidth"} ) {$strokewidthV2= $HashConfi{$Level}{"strokewidth"} ;}

		foreach my $tmpkk (1..$NumPlotArry)
		{
			my  $ThisBoxbin=$tmpkk-1;
			my	$NowPlot=$PlotInfo->[$ThisBoxbin];
			my  $FileNow=$NowPlot->[0];
			my	$CoumnNow=$NowPlot->[1];
			my  $StartCount=0;
			$ArryValue[$ThisBoxbin]="$FileData[$FileNow][0][$CoumnNow]";
			$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
			$XX2=$XX1+$LevelCorGra;
			$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$tmpkk+$HashConfi{$Level}{"ShiftGradienY"};
			$YY2=$YY1+$LevelCorGra;
			if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
			{

			}
			else
			{
				$svg->line('x1',$XX1,'y1',$YY1,'x2',$XX2,'y2',$YY2,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$HashConfi{"ALL"}{"strokewidth"});
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$ThisBoxbin])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$ThisBoxbin]",'font-family','Arial','font-size',$LevelCorGra);
			}



			if ($FileData[$FileNow][0][0] =~s/#/#/)
			{
				$StartCount=1;
			}
			my $FirstPoint=1;
			my $pointAX; 
			my $pointAY;
			my $ChrThisNow="NA";

			for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
			{

				my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
				if ($Value eq "NA")
				{
					$FirstPoint=1;
					next;
				}

				my $ThisChrName=$FileData[$FileNow][$StartCount][0];
				next if (!exists $hashYY1{$ThisChrName} ) ;	
				my $StartSite=$FileData[$FileNow][$StartCount][1];
				my $EndSite=$FileData[$FileNow][$StartCount][2];
				$YY1=$hashYY1{$ThisChrName}{$Level};
				$YY2=$hashYY2{$ThisChrName}{$Level};
				$YY1=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
				$XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});

				if (($FirstPoint==1)   || ($ChrThisNow ne  $ThisChrName ) )
				{
					$pointAX=$XX1;
					$pointAY=$YY1;
					$ChrThisNow=$ThisChrName;
					$FirstPoint=0;
					next;
				}
				$svg->line('x1',$pointAX,'y1',$pointAY,'x2',$XX1,'y2',$YY1,'stroke',$ArryCol[$ThisBoxbin],'stroke-width',$strokewidthV2);
				$pointAX=$XX1;
				$pointAY=$YY1;
			}
		}

		if (exists $HashConfi{$Level}{"Cutline"})
		{
			my $Value=$HashConfi{$Level}{"Cutline"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};			
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline"}) {$corCutline=$HashConfi{$Level}{"CorCutline"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}
		if (exists $HashConfi{$Level}{"Cutline1"})
		{
			my $Value=$HashConfi{$Level}{"Cutline1"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};			
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline1"}) {$corCutline=$HashConfi{$Level}{"CorCutline1"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}


		if (exists $HashConfi{$Level}{"Cutline2"})
		{
			my $Value=$HashConfi{$Level}{"Cutline2"};
			if (($Value < $HashConfi{$Level}{"YMax"})  &&  ( $Value >  $HashConfi{$Level}{"YMin"}) )
			{
				my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};			
				my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};
				if  ($HHstrokewidth<1) {$HHstrokewidth=1;}
				my $AA=$HHstrokewidth*3; my $BB=$HHstrokewidth*2;
				my $corCutline="red";  if  (exists $HashConfi{$Level}{"CorCutline2"}) {$corCutline=$HashConfi{$Level}{"CorCutline2"};}
				foreach my $thisChr (0..$#ChrArry)
				{
					my $ThisChrName=$ChrArry[$thisChr];
					my $XX1=sprintf ("%.1f",$hashXX1{$ThisChrName}{$Level});
					my $XX2=sprintf ("%.1f",($hashChr{$ThisChrName}/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
					my $YY1=$hashYY1{$ThisChrName}{$Level};
					my $YY2=$hashYY2{$ThisChrName}{$Level};
					my $labYY=$YY2-($YY2-$YY1)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;
					$svg->line('x1',$XX1,'y1',$labYY,'x2',$XX2,'y2',$labYY,'stroke',$corCutline,'stroke-width',$HHstrokewidth,'stroke-dasharray',"$AA $BB");
				}
			}
		}



	}
	elsif (($HashConfi{$Level}{"PType"}  eq  "heatmapAnimated")   ||  ($HashConfi{$Level}{"PType"}  eq  "highlightsAnimated"))
	{
		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;

		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);

			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}


		my $HeatMapstrokewidth=$HashConfi{$Level}{"strokewidth"};


		my $ThisBoxbin;my $NowPlot;my $CoumnNow;my $FileNow;
		my $StartCount=0;
		my @NowPLotCoumn=();
		my $textDataLine="";
		my $textData="";
		foreach my $tmpkk (1..1)
		{
			$ThisBoxbin=$tmpkk-1;
			$NowPlot=$PlotInfo->[$ThisBoxbin];
			$FileNow=$NowPlot->[0];
			$CoumnNow=$NowPlot->[1];
			$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
			$textDataLine=$FileData[$FileNow][0][$CoumnNow];
		}

		foreach my $tmpkk (2..$NumPlotArry)
		{
			$ThisBoxbin=$tmpkk-1;
			$NowPlot=$PlotInfo->[$ThisBoxbin];
			$FileNow=$NowPlot->[0];
			$CoumnNow=$NowPlot->[1];
			$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
			$textData=$FileData[$FileNow][0][$CoumnNow];
			$textDataLine=$textDataLine.";".$textData;
		}

		if  ($FileData[$FileNow][0][0] =~s/#/#/)
		{
			$StartCount=1;
		}
		$YY2=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"}-$LevelCorGra*2;
		my $textLength=$LevelCorGra*$NumPlotArry;
		$svg->text('text-anchor','start','x',$XX1,'y',$YY2,'textlength',$textLength,'-cdata',$textDataLine,'font-family','Arial','font-size',$LevelCorGra);
		$svg->rect('x',$XX1,'y',$YY2,'width',$textLength,'height',$LevelCorGra,'fill',"grey");
		my $animateTxt=$svg->text('text-anchor','start','x',$XX1,'y',$YY2+$LevelCorGra,'-cdata',"Time",'font-family','Arial','font-size',$LevelCorGra);
		$XX2=$XX1+$textLength;
		$animateTxt->animate(attributeName=>"x",from=>$XX1,to=>$XX2,begin=>"0s",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
		$hashValue2Col{"NA"}="white";


		for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
		{

			my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
			my $ThisChrName=$FileData[$FileNow][$StartCount][0];
			next if (!exists $hashYY1{$ThisChrName} ) ;				
			my $StartSite=$FileData[$FileNow][$StartCount][1];
			my $EndSite=$FileData[$FileNow][$StartCount][2];
			my $YY1=$hashYY1{$ThisChrName}{$Level};
			my $YY2=$hashYY2{$ThisChrName}{$Level};
			if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
			my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
			my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');


			my $Tag=$svg->polygon(
				%$path,
				style => {
					'fill'           => $hashValue2Col{$Value},
					'stroke'         => $hashValue2Col{$Value},
					'stroke-width'   => $HeatMapstrokewidth,
					'stroke-opacity' => $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   => $HashConfi{$Level}{"fill-opacity"},
				},
			);

			my $animateLine=$hashValue2Col{$Value};
			for (my $NowAA=$NumPlotArry-2;$NowAA>=0; $NowAA--)
			{
				$Value=$FileData[$FileNow][$StartCount][$NowPLotCoumn[$NowAA]];
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				$animateLine=$hashValue2Col{$Value}.";".$animateLine;
			}
			$Tag->animate(attributeName=>"fill",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			$Tag->animate(attributeName=>"stroke",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
		}
	}
	elsif (( $HashConfi{$Level}{"PType"}  eq  "histogramAnimated" )  || ( $HashConfi{$Level}{"PType"}  eq  "histAnimated" ))
	{
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		my $ThisBoxbin;my $NowPlot;my $CoumnNow;my $FileNow;
		my $StartCount=0;
		my @NowPLotCoumn=();
		my $textDataLine="";
		my $textData="";
		foreach my $tmpkk (1..1)
		{
			$ThisBoxbin=$tmpkk-1;
			$NowPlot=$PlotInfo->[$ThisBoxbin];
			$FileNow=$NowPlot->[0];
			$CoumnNow=$NowPlot->[1];
			$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
			$textDataLine=$FileData[$FileNow][0][$CoumnNow];
		}

		foreach my $tmpkk (2..$NumPlotArry)
		{
			$ThisBoxbin=$tmpkk-1;
			$NowPlot=$PlotInfo->[$ThisBoxbin];
			$FileNow=$NowPlot->[0];
			$CoumnNow=$NowPlot->[1];
			$NowPLotCoumn[$ThisBoxbin]=$CoumnNow;
			$textData=$FileData[$FileNow][0][$CoumnNow];
			$textDataLine=$textDataLine.";".$textData;
		}

		if ($FileData[$FileNow][0][0] =~s/#/#/)
		{
			$StartCount=1;
		}


		$YY2=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"}-$LevelCorGra*2;

		my $textLength=$LevelCorGra*$NumPlotArry;
		$svg->text('text-anchor','start','x',$XX1,'y',$YY2,'textlength',$textLength,'-cdata',$textDataLine,'font-family','Arial','font-size',$LevelCorGra);
		$svg->rect('x',$XX1,'y',$YY2,'width',$textLength,'height',$LevelCorGra,'fill',"grey");
		my $animateTxt=$svg->text('text-anchor','start','x',$XX1,'y',$YY2+$LevelCorGra,'-cdata',"Time",'font-family','Arial','font-size',$LevelCorGra);
		$XX2=$XX1+$textLength;
		$animateTxt->animate(attributeName=>"x",from=>$XX1,to=>$XX2,begin=>"0s",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
		$hashValue2Col{"NA"}="white";




		$YY1=$HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$HashConfi{$Level}{"ShiftGradienY"};
		$YY2=$YY1+$LevelCorGra*($MaxCol+1);
		$XX1=$HashConfi{"global"}{"left"}+$HashConfi{"global"}{"body"}+($Level-1)*$LevelCorGra*4.5+$HashConfi{$Level}{"ShiftGradienX"}+$ALLBetweenChrHH;
		$XX2=$XX1+$LevelCorGra;

		if ($HashConfi{$Level}{"NoShowGradien"}!=0   ||   $HashConfi{$Level}{"SizeGradienRatio"}<=0 )
		{

		}
		else
		{
			$path = $svg->get_path(
				x => [$XX1, $XX1, $XX2,$XX2],
				y => [$YY1, $YY2, $YY2,$YY1],
				-type => 'polygon');

			$svg->polygon(
				%$path,
				style => {
					'fill' =>'none',
					'stroke'         => 'black',
					'stroke-width'   =>  $HashConfi{"global"}{"strokewidth"},
					'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
					'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
				},
			);
			foreach my $k (0..$MaxCol)
			{
				$YY1= $HashConfi{"global"}{"up"}+$StarGradienRatio*$Bodyheight+$LevelCorGra*$k+$HashConfi{$Level}{"ShiftGradienY"};
				$YY2=$YY1+$LevelCorGra;

				$path = $svg->get_path(
					x => [$XX1, $XX1, $XX2,$XX2],
					y => [$YY1, $YY2, $YY2,$YY1],
					-type => 'polygon');

				$svg->polygon(
					%$path,
					style => {
						'fill'           => "$ArryCol[$k]",
						'stroke'         => 'black',
						'stroke-width'   =>  0,
						'stroke-opacity' =>  $HashConfi{$Level}{"stroke-opacity"},
						'fill-opacity'   =>  $HashConfi{$Level}{"fill-opacity"},
					},
				);  
				$svg->text('text-anchor','middle','x',$XX2+length($ArryValue[$k])+$LevelCorGra*1.88,'y',$YY2,'-cdata',"$ArryValue[$k]",'font-family','Arial','font-size',$LevelCorGra);
			}
		}

		my $MaxDiffValue=$HashConfi{$Level}{"YMax"}-$HashConfi{$Level}{"YMin"};
		my $HHstrokewidth=$HashConfi{$Level}{"strokewidth"};


		if ( (exists $HashConfi{$Level}{"ShowYaxis"} )  && ( $HashConfi{$Level}{"ShowYaxis"} >0 ) )
		{
			my $StartYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMin"}*1.0);
			my $EndYLevel=sprintf ($Precision,$HashConfi{$Level}{"YMax"}*1.0);
			my $countTmpChr=$#ChrArry;
			if ( $HashConfi{"global"}{"ChrArrayDirection"} ne "vertical" )
			{
				$countTmpChr=0;
			}
			foreach my $thisChr (0..$countTmpChr)
			{
				my $ThisChrName=$ChrArry[$thisChr];
				my $XX2=$HashConfi{"global"}{"left"}-$fontsize*0.5;
				my $YY1=$hashYY1{$ThisChrName}{$Level}+$fontsize*0.1;
				my $YY2=$hashYY2{$ThisChrName}{$Level}-$fontsize*0.1;
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY2,'-cdata',$StartYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
				$svg->text('text-anchor','middle','x',$XX2,'y',$YY1,'-cdata',$EndYLevel,'font-family',$HashConfi{"global"}{"font-family"},'font-size',$fontsize*0.32);
			}
		}





		for ( ; $StartCount<$FileRow[$FileNow]; $StartCount++)
		{
			my $Value=$FileData[$FileNow][$StartCount][$CoumnNow];
			my $ThisChrName=$FileData[$FileNow][$StartCount][0];
			next if (!exists $hashYY1{$ThisChrName} ) ;	
			my $StartSite=$FileData[$FileNow][$StartCount][1];
			my $EndSite=$FileData[$FileNow][$StartCount][2];

			my $YY1A=$hashYY1{$ThisChrName}{$Level};
			my $YY2=$hashYY2{$ThisChrName}{$Level};
			my $heightLL=0;
			if ($Value ne "NA") { $heightLL=($YY2-$YY1A)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;}
			my $YY1=$YY2-$heightLL;

			my $XX1=sprintf ("%.1f",($StartSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
			my $XX2=sprintf ("%.1f",($EndSite/$ChrMax)*$HashConfi{"global"}{"body"}+$hashXX1{$ThisChrName}{$Level});
			my $widthLL=$XX2-$XX1;
			my $Tag=$svg->rect('x',$XX1,'y',$YY2,'width',$widthLL,'height',$heightLL,'fill',$hashValue2Col{$Value},'stroke',$hashValue2Col{$Value},'stroke-width',$HHstrokewidth,'stroke-opacity', $HashConfi{$Level}{"stroke-opacity"},'fill-opacity',$HashConfi{$Level}{"fill-opacity"});
			my $animateLine=$hashValue2Col{$Value};
			my $YY1line=$YY1;
			my $heightLLline=$heightLL;
			for (my $NowAA=$NumPlotArry-2;$NowAA>=0; $NowAA--)
			{
				$Value=$FileData[$FileNow][$StartCount][$NowPLotCoumn[$NowAA]];
				if (exists $Value2SelfCol{$Value} ) {$hashValue2Col{$Value}=$Value2SelfCol{$Value};}
				$animateLine=$hashValue2Col{$Value}.";".$animateLine;
				$heightLL=0;
				if ($Value ne "NA") {$heightLL=($YY2-$YY1A)*($Value-$HashConfi{$Level}{"YMin"})/$MaxDiffValue;}
				$YY1=$YY2-$heightLL;
				$YY1line=$YY1.";".$YY1line;
				$heightLLline=$heightLL.";".$heightLLline;
			}
			$Tag->animate(attributeName=>"fill",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			$Tag->animate(attributeName=>"stroke",values=>"$animateLine",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			$Tag->animate(attributeName=>"y",values=>"$YY1line",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
			$Tag->animate(attributeName=>"height",values=>"$heightLLline",dur=>"3s", repeatDur=>'indefinite',"-method"=>"animate");
		}
	}


}

##########  

######################swimming in the sky and flying in the sea ###########################
svg2PNGfuntion($svg,$OutPut);

sub svg2PNGfuntion
{
	my $svg=shift;
	my $OutPutHere=shift;

	if (!($OutPutHere=~s/.svg$/.svg/))
	{
		$OutPutHere=$OutPutHere.".svg";
	}
	open (OUT,">$OutPutHere") || die "input file can't open $!";
	print OUT $svg->xmlify();
	close OUT ;

	print "convert   SVG ---> PNG ...\n";

	my $convert="/usr/bin/convert";
	if  ( !(-e $convert) )
	{
		$convert=`which convert  2> /dev/null `;chomp $convert;
	}

	my $SVG2XXX="$Bin/svg_kit/svg2xxx.pl";
	if  ( !(-e $SVG2XXX ))
	{
		$SVG2XXX="$RealBin/svg_kit/svg2xxx.pl";
	}

	my $bbb=$OutPutHere ;
	if ($bbb=~s/.svg$/.png/)
	{
	}
	else
	{
		$bbb=$bbb.".png";
	}
	my @arryStat=stat($OutPutHere);
	my $convertPara="";
	if  ($HashConfi{"global"}{"RotatePng"}!=0)
	{
		$convertPara="-rotate " . $HashConfi{"global"}{"RotatePng"} ;
	}
	if (  ( $arryStat[7]   <  500000000 )    &&   (-e $convert)  )
	{
		system (" $convert   $convertPara  $OutPutHere    $bbb   ");
		exit(1);
	}

	if  ( -e $SVG2XXX )
	{
		system ("  perl   $SVG2XXX    $OutPutHere   " );
		exit(1);
	}

	if  ( !(-e $convert) )
	{
		print "Can't find the [ convert ] bin in your \$PATH, You shoud install the [convert] First,then:\t\t";
		print " convert  $OutPutHere    $bbb  \n";
		exit(1);
	}
	else
	{
		system (" $convert $convertPara  $OutPutHere   $bbb ");
	}

}


######################swimming in the sky and flying in the sea ###########################

######################swimming in the sky and flying in the sea ###########################
